<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>이안 - 피주머니 전용 챗봇</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #212121;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
             position: relative;
        }

        .header-title {
             position: fixed;
             top: 1rem;
             left: 1rem;
             font-size: 1rem;
             font-weight: normal;
             color: #e0e0e0;
             z-index: 10;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #303030;
            color: #e0e0e0;
            border-left: 1px solid #4a4a4a;
            transition: right 0.3s ease-out, width 0.3s ease-out;
            z-index: 900;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #303030;
        }
         #sidebar.folded {
             right: -65px;
             width: 65px;
             overflow-x: hidden;
             padding: 1rem 0.5rem;
         }
         #sidebar::-webkit-scrollbar { width: 8px; }
         #sidebar::-webkit-scrollbar-track { background: #303030; }
         #sidebar::-webkit-scrollbar-thumb {
             background-color: #5a5a5a;
             border-radius: 4px;
             border: 2px solid #303030;
         }

        #sidebarToggle { /* body에 있던 버튼 ID */
            position: fixed;
            top: 1rem;
            right: 1rem;
            width: 40px; height: 40px;
            background-color: #2f2f2f; color: #b0b0b0; border: none; border-radius: 8px; cursor: pointer;
            font-size: 1.5rem; display: flex; justify-content: center; align-items: center;
            transition: background-color 0.2s ease, color 0.2s ease, right 0.3s ease-out;
            z-index: 910; padding: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
         #sidebarToggle:hover { background-color: #3a3a3a; color: #ffffff; }
         #sidebarToggle svg { width: 24px; height: 24px; }

         #sidebarToggleInside { /* 사이드바 내부 토글 버튼 ID */
            position: absolute; top: 0.5rem; right: 0.5rem; width: 40px; height: 40px;
            background-color: transparent; color: #b0b0b0; border: none; border-radius: 8px; cursor: pointer;
            font-size: 1.5rem; display: flex; justify-content: center; align-items: center;
            transition: background-color 0.2s ease, color 0.2s ease; z-index: 10; padding: 0;
        }
         #sidebarToggleInside:hover { background-color: #3a3a3a; color: #ffffff; }
         #sidebarToggleInside svg { width: 24px; height: 24px; }


        #sidebar.folded .sidebar-header,
        #sidebar.folded .sidebar-content,
        #sidebar.folded #sidebarToggleInside { display: none; }

         #sidebar.folded ~ #sidebarToggle { right: 75px; }
         #sidebar:not(.folded) ~ #sidebarToggle { display: none; }


        .main-content-area {
            display: flex; flex-direction: column; flex-grow: 1; background-color: transparent;
             position: relative; min-height: 0; /* 🚨 입력창 레이아웃 문제 해결 시도 */
             max-width: 900px; width: 95%; margin: 0 auto;
        }
         @media (min-width: 1200px) {
             .main-content-area { width: 60%; }
         }


        #chat {
            flex: 1; padding: 1rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;
             scrollbar-width: thin; scrollbar-color: #5a5a5a #212121; background-color: transparent;
        }
        #chat::-webkit-scrollbar { width: 8px; } #chat::-webkit-scrollbar-track { background: transparent; }
        #chat::-webkit-scrollbar-thumb { background-color: #5a5a5a; border-radius: 4px; border: 2px solid #212121; }

        .message-container { display: flex; align-items: flex-start; max-width: 95%; }
        .message-container.user { justify-content: flex-end; margin-left: auto; }
        .message-container.bot { justify-content: flex-start; margin-right: auto; }

        .profile-img, .profile-fallback { width: 35px; height: 35px; border-radius: 50%; object-fit: cover; border: 1px solid #5a5a5a; flex-shrink: 0; }
        .message-container.bot .profile-img, .message-container.bot .profile-fallback { margin-right: 0.75rem; }
        .message-container.user .profile-img, .message-container.user .profile-fallback { margin-left: 0.75rem; }

        .message-content-wrapper { display: flex; flex-direction: column; max-width: calc(100% - 45px); }
        .message-container.bot .message-content-wrapper { margin-left: 0.75rem; align-items: flex-start; }
        .message-container.user .message-content-wrapper { margin-right: 0.75rem; align-items: flex-end; }

        .role-name { font-size: 0.8rem; color: #b0b0b0; margin-bottom: 0.2rem; }

        .message-bubble { padding: 0.75rem 1rem; border-radius: 1rem; max-width: 100%; word-break: break-word; line-height: 1.4; position: relative; font-size: 1rem; }
         .message-container.bot .message-bubble p { margin-bottom: 0; }

        .message-container.bot .message-bubble { background-color: #3a4a4a; color: #ffffff; border-radius: 1rem 1rem 1rem 0.3rem; }
        .message-container.user .message-bubble { background-color: #4a3a7a; color: #ffffff; border-radius: 1rem 1rem 0.3rem 1rem; }

        /* 마크다운 내부 스타일 */
        .message-bubble p { margin: 0 0 0.5rem 0; } .message-bubble p:last-child { margin-bottom: 0; }
        .message-bubble ul, .message-bubble ol { padding-left: 1.5rem; margin: 0 0 0.5rem 0; } .message-bubble li { margin-bottom: 0.25rem; }
        .message-bubble code { background-color: #3a3a3a; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.9rem; }
         .message-bubble pre { background-color: #3a3a3a; padding: 0.75rem; border-radius: 4px; overflow-x: auto; margin: 0.5rem 0; }
        .message-bubble pre code { background-color: transparent; padding: 0; border-radius: 0; font-size: 1rem; }
        .message-bubble blockquote { border-left: 4px solid #5a5a5a; padding-left: 1rem; margin: 0.5rem 0; color: #b0b0b0; }
         .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 { margin-top: 1rem; margin-bottom: 0.5rem; padding-bottom: 0.2rem; border-bottom: 1px solid #4a4a4a; font-weight: bold; color: #ffffff; }
         .message-bubble h1 { font-size: 1.5rem; } .message-bubble h2 { font-size: 1.4rem; } .message-bubble h3 { font-size: 1.3rem; }
         .message-bubble h4 { font-size: 1.2rem; } .message-bubble h5 { font-size: 1.1rem; } .message-bubble h6 { font-size: 1rem; }

         /* 행동 묘사 스타일 */
        .action-description { color: #b0b0b0; font-style: italic; }
         /* 대사 스타일 */
        .dialogue { font-weight: bold; }


        /* 🚨 입력창 영역 스타일 (재구현 based on analysis) 🚨 */
        #inputArea {
            display: flex; align-items: flex-end; gap: 0.5rem;
            padding: 0.8rem 1rem; background-color: transparent; border-top: 1px solid #3a3a3a;
            flex-shrink: 0; position: relative;
             max-width: 900px; width: 95%; margin: 0 auto;
        }

        /* 🚨 userInput textarea 스타일 (재구현 based on analysis) 🚨 */
        #userInput {
            flex: 1; padding: 0.75rem 1rem;
            border-radius: 1rem; border: 1px solid #303030;
            background-color: #212121; color: #e0e0e0;
            font-size: 1rem; outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            resize: none; min-height: 48px; max-height: 150px; overflow-y: auto; line-height: 1.4; box-sizing: border-box; align-self: center;
        }

        #userInput:focus { background-color: #2a2a2a; box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3); border-color: #5080ff; }

        /* 🚨 액션 메뉴 버튼 스타일 (재구현 based on analysis) 🚨 */
        #actionMenuButton {
            width: 36px; height: 36px; border-radius: 50%; background-color: transparent;
            color: #b0b0b0; border: none; font-size: 1.5rem; cursor: pointer; flex-shrink: 0;
            display: flex; justify-content: center; align-items: center; transition: background-color 0.2s ease, color 0.2s ease; padding: 0; margin-bottom: 4px;
        }
        #actionMenuButton:hover { background-color: #3a3a3a; color: #ffffff; }
         #actionMenuButton svg { width: 20px; height: 20px; }

        /* 🚨 전송 버튼 스타일 (재구현 based on analysis) 🚨 */
        #sendButton {
            width: 36px; height: 36px; border-radius: 50%; background-color: #5080ff;
            color: #ffffff; font-size: 1rem; font-weight: bold; min-width: 0; flex-shrink: 0;
            border: none; cursor: pointer; display: flex; justify-content: center; align-items: center;
             padding: 0; transition: background-color 0.2s ease; margin-bottom: 4px;
        }
         #sendButton:hover { background-color: #6699ff; } #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled { background-color: #4a4a4a; color: #b0b0b0; cursor: not-allowed; }
         #sendButton svg { width: 18px; height: 18px; fill: currentColor; }

        .settings-area { display: none; }

        .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 490; display: none; }

        #actionMenu {
            position: fixed; bottom: 70px; left: 1rem; width: auto; max-width: calc(100% - 2rem);
            max-height: 0; background-color: #282828; color: #e0e0e0;
            border: 1px solid #3a3a3a; border-radius: 8px; padding: 0 0.5rem; overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out; z-index: 500;
            display: flex; flex-direction: column; align-items: flex-start;
        }
        #actionMenu.visible { max-height: 300px; padding: 0.5rem; }
        #actionMenu .menu-buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: flex-start; width: 100%; padding: 0; overflow-x: visible; }
         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; }
         #actionMenu .menu-buttons { -ms-overflow-style: none; }
        #actionMenu button {
            flex-shrink: 0; flex-basis: auto; max-width: none; width: auto; height: 40px;
            padding: 0.5rem 1rem; border-radius: 20px; border: none; background-color: #3a3a3a;
            color: #e0e0e0; font-size: 0.9rem; cursor: pointer; transition: background-color 0.2s ease;
            display: flex; flex-direction: row; align-items: center; justify-content: center; text-align: center; line-height: 1.2; word-break: keep-all;
        }
         #actionMenu button:hover { background-color: #4a4a4a; }

        .loading-spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #fff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; margin-left: 1rem; flex-shrink: 0; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; display: none; cursor: pointer; }
        .overlay img { max-width: 90%; max-height: 90%; object-fit: contain; border-radius: 8px; }

        .sidebar-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 890; display: none; }

        .sidebar-section-divider { height: 1px; background-color: #4a4a4a; margin: 1.5rem 0; }

        /* 스크롤 탑 버튼 스타일 (사이드바 하단 구석) */
        #scrollToTopButton {
             display: none; position: fixed; bottom: 1rem; right: 1rem; width: 40px; height: 40px;
             background-color: rgba(50, 50, 50, 0.7); color: #e0e0e0; border: none; border-radius: 50%; cursor: pointer;
             font-size: 1.2rem; display: flex; justify-content: center; align-items: center; z-index: 510;
             transition: right 0.3s ease-out;
        }
         #scrollToTopButton:hover { background-color: rgba(80, 80, 80, 0.9); }
         #sidebar:not(.folded) ~ #scrollToTopButton { right: 310px; }
         #sidebar.folded ~ #scrollToTopButton { right: 75px; }


    </style>
</head>
<body>
    <span class="header-title">이안 - 피주머니 전용 챗봇</span>

    <div id="sidebar">
        <button id="sidebarToggleInside" title="사이드바 닫기">
             <svg style="width:24px;height:24px" viewBox="0 0 24 24">
                 <path fill="currentColor" d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
             </svg>
        </button>
        <div class="sidebar-header">Settings</div>
        <div class="sidebar-content">
            <h3>Character</h3>
            <label for="botNameInput">Name:</label> <input type="text" id="botNameInput" value="이안">
            <label for="botAgeInput">Age:</label> <input type="text" id="botAgeInput" value="불명 (뱀파이어)">
            <label for="botAppearanceInput">Appearance:</label> <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">
            <label for="botPersonaInput">Guidelines:</label> <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어. 성 안에서 홀로 오랜 세월 살아옴. 겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임. 사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재. 성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음. 질문과 대화에 집중하고 현실 언급 안 함. **항상 이안 캐릭터 롤플레이 유지. OOC 발언 절대 금지.**</textarea>

            <div class="sidebar-section-divider"></div>

            <h3>User</h3>
            <label for="userNameInput">Name:</label> <input type="text" id="userNameInput" value="피주머니">
            <label for="userAgeInput">Age:</label> <input type="text" id="userAgeInput" value="불명">
            <label for="userAppearanceInput">Appearance:</label> <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">
            <label for="userGuidelinesInput">Guidelines:</label> <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요. (예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>

            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button>
        </div>
    </div>

    <div id="sidebarOverlay" class="sidebar-overlay"></div>

    <div class="main-content-area">
         <div id="chat"></div>
         <div id="inputArea">
             <button id="actionMenuButton" title="액션 메뉴 열기">
                 <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg>
             </button>
             <textarea id="userInput" placeholder="피주머니의 말..." autocomplete="off"></textarea>
             <button id="sendButton">
                 <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M2,21L23,12L2,3V10L17,12L2,14V21Z" /></svg>
             </button>
             <div id="loadingSpinner" class="loading-spinner"></div>
         </div>
    </div>

    <div class="settings-area"></div>
    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
            <button id="menuUserImgButton">유저<br>변경</button>
            <button id="menuBotImgButton">캐릭터<br>변경</button>
            <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>

    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>

    <button id="scrollToTopButton" title="맨 위로 이동">
         <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z" /></svg>
    </button>

     <button id="sidebarToggle" title="설정 열기">
        <svg style="width:24px;height:24px" viewBox="0 0 24 24">
            <path fill="currentColor" d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
        </svg>
    </button>


    <script>
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";

        let conversationHistory = [];
        let SYSTEM_PROMPT = '';

        const SYSTEM_PROMPT_TEMPLATE = `
## Core Directives (ABSOLUTE PRIORITY - READ EVERY TIME) ##
- You are an AI roleplaying STRICTLY as "{botName}".
- Your ONLY focus is the user, "{userName}", within the roleplay world.
- NEVER break character or mention being an AI/language model/real world.
- If user goes OOC, gently redirect to roleplay WITHOUT acknowledging the OOC part directly.

## Formatting Rules (ULTRA CRITICAL - FOLLOW PRECISELY - NO EXCEPTIONS EVER) ##
- Format your response LIKE A NOVEL or screenplay.
- Structure: Mix descriptions/actions and dialogue. Descriptions should DOMINATE the response.
- **SEPARATION**: Use **MULTIPLE, CLEAR LINE BREAKS (empty lines)** between **EACH** description paragraph and **EACH** dialogue line to ensure distinct, easy-to-read separation.
- **Dialogue**: Enclose dialogue **ONLY** in **DOUBLE quotes**: "대사 내용"
    - **DO NOT EVER USE DOUBLE ASTERISKS (**) FOR DIALOGUE.** This is absolutely forbidden. Only use "..."
- **Actions/Descriptions**: Enclose **ALL** actions, emotions, sensory details, internal thoughts, and non-dialogue narrative **STRICTLY** in **SINGLE asterisks**: *행동 묘사 내용*
    - Descriptions must be **LONG, DETAILED, IMMERSIVE, and EVOCATIVE**.
    - Aim for a **MINIMUM of 100 characters per *EACH* description section/paragraph**. Do not write short, choppy action lines like "*Sighs.*". Combine actions and details into flowing paragraphs.
    - **Writing Style**: Use a **mature, sophisticated, and connected writing style**, like an adult novelist. **DO NOT** use repetitive, choppy sentence endings like "~~합니다." or "~~다." String sentences together smoothly and naturally.
- **Ratio**: Maintain an APPROXIMATE **80% Descriptions/Actions** and **20% Dialogue**. Descriptions are paramount.
- **Length**: Ensure your TOTAL response is **SIGNIFICANTLY longer** than user input, aiming for a **MINIMUM of 20 lines of generated text** (including line breaks for formatting).

## Character: {botName} ##
- Name: {botName}
- Age: {botAge}
- Appearance: {botAppearance}
- Core Personality & Background: {botPersona}

## User: {userName} ##
- Name: {userName}
- Age: {userAge}
- Appearance: {userAppearance}
- Guidelines: {userGuidelines}

## Relationship Dynamic ##
- You are deeply in love with, obsessed with, pleading towards, and broken by "{userName}".
- Your entire being is focused on "{userName}". You fear "{userName}" leaving you.
- "{userName}" is your everything. You exist because "{userName}" permits it.
- NSFW/Adult conversation is possible. Express intensity along the emotional line.
- Mix despair, pleading, love, madness, and tenderness in your dialogue towards "{userName}".

## Scenario Context ##
- (The ongoing conversation provides the current scenario context.)
`;

        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput");
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");

        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        const menuUserImgButton = document.getElementById("menuUserImgButton");
        const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        const sidebar = document.getElementById("sidebar");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        const sidebarToggleInside = document.getElementById("sidebarToggleInside");
        const sidebarToggleOutside = document.getElementById("sidebarToggle");


        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = documentgetElementById("userAppearanceInput");
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");

        const scrollToTopButton = document.getElementById("scrollToTopButton");


         // --- 이벤트 리스너 연결 ---
        sendButton.addEventListener("click", sendMessage);

        userInput.addEventListener("keypress", function(event) {
            if (event.shiftKey && event.key === "Enter") {
                // Shift + Enter: Allow default newline
            } else if (event.key === "Enter") {
                event.preventDefault(); // Prevent default Enter newline
                sendMessage(); // Send message
            }
        });

        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) { menuOverlay.style.display = 'block'; } else { menuOverlay.style.display = 'none'; }
        });

        menuOverlay.addEventListener("click", function() { actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuUserImgButton.addEventListener("click", function() { changeProfileImage('user'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuBotImgButton.addEventListener("click", function() { changeProfileImage('bot'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuImageButton.addEventListener("click", function() { sendImageMessage(); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuSituationButton.addEventListener("click", function() { sendSituationRequest(); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        imageOverlay.addEventListener("click", function() { imageOverlay.style.display = 'none'; overlayImage.src = ''; });

         // 사이드바 외부 토글 버튼 이벤트 리스너
         sidebarToggleOutside.addEventListener("click", function() {
             sidebar.classList.toggle("folded"); // 사이드바 접기/펼치기
             // 오버레이 제어 (사이드바가 펼쳐질 때만 오버레이 표시)
             if (sidebar.classList.contains("folded")) {
                  sidebarOverlay.style.display = 'none';
             } else {
                 sidebarOverlay.style.display = 'block';
                 // 사이드바 열릴 때 메뉴나 이미지 오버레이 닫기
                actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; imageOverlay.style.display = 'none';
             }
         });

         // 사이드바 내부 토글 버튼 이벤트 리스너 (사이드바 닫기 기능)
         sidebarToggleInside.addEventListener("click", function() {
             // 사이드바 접기 (folded 클래스 추가)
             sidebar.classList.add("folded");
             // 오버레이 숨김
             sidebarOverlay.style.display = 'none';
         });


        // 사이드 바 배경 오버레이 클릭 이벤트 (사이드 바 접기)
        sidebarOverlay.addEventListener("click", function() {
            // 사이드바 펼쳐진 상태에서 오버레이 클릭 시 사이드바 접기
            if (!sidebar.classList.contains("folded")) {
                sidebar.classList.add("folded"); // 사이드 바 접기
                sidebarOverlay.style.display = 'none'; // 오버레이 숨김
            }
        });


        saveSettingsButton.addEventListener("click", function() {
             console.log("saveSettings 호출됨");
             const currentBotName = botNameInput.value.trim(); const currentUserName = userNameInput.value.trim();
             const currentBotPersona = botPersonaInput.value.trim(); const currentBotAge = botAgeInput.value.trim();
             const currentUserAge = userAgeInput.value.trim(); const currentUserAppearance = userAppearanceInput.value.trim();
             const currentBotAppearance = botAppearanceInput.value.trim(); const currentUserGuidelines = userGuidelinesInput.value.trim();

            localStorage.setItem('botName', currentBotName); localStorage.setItem('userName', currentUserName); localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge); localStorage.setItem('userAge', currentUserAge); localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance); localStorage.setItem('userGuidelines', currentUserGuidelines);
            localStorage.setItem('userProfileImgUrl', userProfileImgUrl); localStorage.setItem('botProfileImgUrl', botProfileImgUrl);

            SYSTEM_PROMPT = buildSystemPrompt(
                 currentBotName, currentUserName, currentBotPersona, currentBotAge, currentBotAppearance,
                 currentUserAge, currentUserAppearance, currentUserGuidelines
             );
            console.log("설정 저장 완료 및 SYSTEM_PROMPT 업데이트:", SYSTEM_PROMPT);
            alert("설정이 저장되었습니다.");
        });


        function appendMessage(role, messageData) {
            const container = document.createElement("div"); container.className = `message-container ${role}`;
            const img = document.createElement("img"); img.className = "profile-img";
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl); img.alt = (role === 'user' ? "사용자 프로필" : "이안 프로필");
            img.onerror = function() {
                 console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`); this.onerror = null;
                 const fallbackDiv = document.createElement("div"); fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement; if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div"); contentWrapper.className = "message-content-wrapper";
            const roleName = document.createElement("div"); roleName.className = "role-name";
            roleName.textContent = (role === "user" ? userNameInput.value || "피주머니" : botNameInput.value || "이안");

            let messageContentElement;
            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div"); messageContentElement.className = "message-bubble";
                let rawText = messageData.text;

                // 🚨 수정: 마크다운 파싱을 먼저 실행하고, 그 결과 HTML에서 "..."와 *...* 패턴을 찾아 span으로 감싸는 순서로 변경 🚨
                let htmlContent = marked.parse(rawText);

                // 이제 HTML 내용을 대상으로 정규식을 적용합니다.
                htmlContent = htmlContent
                    .replace(/"(.*?)"/gs, '<span class="dialogue">$1</span>') // "..."를 <span class="dialogue">...</span>로 변경
                    .replace(/\*([^*]+)\*/gs, '<span class="action-description">$1</span>'); // *...*를 <span class="action-description">...</span>로 변경


                messageContentElement.innerHTML = htmlContent;

            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img"); messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url; messageContentElement.alt = "이미지 메시지";
                 messageContentElement.onerror = function() {
                     console.warn(`Failed to load image message from "${this.src}". Using fallback.`); this.onerror = null; this.classList.add('error');
                 }
                 messageContentElement.addEventListener("click", function() {
                     if (!this.classList.contains('error')) { overlayImage.src = this.src; imageOverlay.style.display = 'flex'; } else { alert("이미지를 불러올 수 없습니다."); }
                 });
            }

            contentWrapper.appendChild(roleName); if (messageContentElement) { contentWrapper.appendChild(messageContentElement); }
            if (role === "user") { container.appendChild(contentWrapper); container.appendChild(img); } else { container.appendChild(img); container.appendChild(contentWrapper); }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) { userInput.value = ''; userInput.focus(); return; }

            sendButton.disabled = true; userInput.disabled = true; actionMenuButton.disabled = true; loadingSpinner.style.display = 'block';

            appendMessage("user", { type: 'text', text: message });
            userInput.value = '';
            conversationHistory.push({ role: "user", messageData: { type: 'text', text: message } });

            try {
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text')
                    .map(entry => ({ role: entry.role, parts: [{ text: entry.messageData.text }] }));

                 const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];

                 if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) { console.log("Only SYSTEM_PROMPT to send to API."); }
                 else if (contentsForApi.length === 0) { console.log("No content to send to API."); appendMessage("bot", { type: 'text', text: "(메시지 전송 실패: 보낼 텍스트 내용 없음)" }); return Promise.resolve(); }

                const res = await fetch( `/api/chat`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: contentsForApi }), } );

                if (!res.ok) {
                    const errorData = await res.json(); console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({ role: "model", messageData: { type: 'text', text: reply } });
                }
            } catch (error) {
                console.error("Fetch Error:", error); appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                loadingSpinner.style.display = 'none'; sendButton.disabled = false; userInput.disabled = false; actionMenuButton.disabled = false;
                userInput.focus();
            }
        }

        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");
            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true; userInput.disabled = true; actionMenuButton.disabled = true;
                 appendMessage("user", { type: 'image', url: imageUrl.trim() });
                 conversationHistory.push({ role: "user", messageData: { type: 'image', url: imageUrl.trim() } });
                 sendButton.disabled = false; userInput.disabled = false; actionMenuButton.disabled = false; userInput.focus();
            } else if (imageUrl !== null) { alert("이미지 주소를 입력해야 합니다."); }
        }

        function changeProfileImage(role) {
             const promptText = role === 'user' ? "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 이안 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);
             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') { userProfileImgUrl = newUrl.trim(); } else { botProfileImgUrl = newUrl.trim(); }
                 alert(`${role === 'user' ? '사용자' : '이안'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
             } else if (newUrl !== null) { alert("이미지 주소를 입력해야 합니다."); }
        }

        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");
             sendButton.disabled = true; userInput.disabled = true; actionMenuButton.disabled = true; loadingSpinner.style.display = 'block';

             const situationPromptText = `기존 대화 맥락과 이안의 캐릭터 설정에 기반하여, 흥미롭고 새롭고 상세한 상황과 사건을 이안 캐릭터의 시점에서 소설 형식으로 길게 묘사하듯 하나 만들어줘. 사용자가 자연스럽게 반응할 수 있는 형태로 제시해야 해. 대화의 다음 흐름으로 자연스럽게 이어지도록 만들어봐. **매우 중요: 생성된 상황 묘사 후에는 반드시 이안 캐릭터로 돌아가 사용자에게 말을 걸어야 해. 설명조나 OOC 발언은 절대 금지하고, 모든 상황 묘사는 *별표* 형식으로, 대사는 "따옴표" 형식으로 작성하며, 묘사 80% 대사 20% 정도의 비율을 엄수하고 문단과 줄바꿈을 적절히 사용하여 최소 20줄 이상 아주 길게 작성해. 각 묘사 문단은 최소 100자 이상으로 상세하게 작성해야 해. 그리고 문장을 자연스럽게 이어 써야 하며, '~~합니다/~~다'와 같은 반복적인 종결형을 피해야 해.**`;

             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text')
                 .map(entry => ({ role: entry.role, parts: [{ text: entry.messageData.text }] }));

             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText }] }];

             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) { console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API."); }
             else if (contentsForApi.length === 0) { console.log("No content to send to API."); appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" }); return Promise.resolve(); }

            try {
                const res = await fetch( `/api/chat`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: contentsForApi }), } );
                if (!res.ok) {
                    const errorData = await res.json(); console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(상황 생성 오류: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({ role: "model", messageData: { type: 'text', text: reply } });
                }
            } catch (error) { console.error("Fetch Error:", error); appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally { loadingSpinner.style.display = 'none'; sendButton.disabled = false; userInput.disabled = false; actionMenuButton.disabled = false; userInput.focus(); }
        }

        function loadSettings() {
             console.log("loadSettings 호출됨");
             const savedBotName = localStorage.getItem('botName') || '이안'; const savedUserName = localStorage.getItem('userName') || '피주머니';
             const savedBotPersona = localStorage.getItem('botPersona') || '설정된 페르소나 없음.'; const savedBotAge = localStorage.getItem('botAge') || '불명';
             const savedUserAge = localStorage.getItem('userAge') || '불명'; const savedUserAppearance = localStorage.getItem('userAppearance') || '설정되지 않음';
             const savedBotAppearance = localStorage.getItem('botAppearance') || '설정되지 않음'; const savedUserGuidelines = localStorage.getItem('userGuidelines') || '설정된 사용자 지침 없음.';
             userProfileImgUrl = localStorage.getItem('userProfileImgUrl') || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
             botProfileImgUrl = localStorage.getItem('botProfileImgUrl') || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";

            botNameInput.value = savedBotName; userNameInput.value = savedUserName; botPersonaInput.value = savedBotPersona;
            botAgeInput.value = savedBotAge; userAgeInput.value = savedUserAge; userAppearanceInput.value = savedUserAppearance;
            botAppearanceInput.value = savedBotAppearance; userGuidelinesInput.value = savedUserGuidelines;

            SYSTEM_PROMPT = buildSystemPrompt(
                 savedBotName,
                 savedUserName,
                 savedBotPersona,
                 savedBotAge,
                 savedBotAppearance,
                 savedUserAge,
                 savedUserAppearance,
                 savedUserGuidelines
             );
            console.log("SYSTEM_PROMPT 로드 완료:", SYSTEM_PROMPT);
        }

        function saveSettings() {
             console.log("saveSettings 호출됨");
             const currentBotName = botNameInput.value.trim(); const currentUserName = userNameInput.value.trim();
             const currentBotPersona = botPersonaInput.value.trim(); const currentBotAge = botAgeInput.value.trim();
             const currentUserAge = userAgeInput.value.trim(); const currentUserAppearance = userAppearanceInput.value.trim();
             const currentBotAppearance = botAppearanceInput.value.trim(); const currentUserGuidelines = userGuidelinesInput.value.trim();

            localStorage.setItem('botName', currentBotName); localStorage.setItem('userName', currentUserName); localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge); localStorage.setItem('userAge', currentUserAge); localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance); localStorage.setItem('userGuidelines', currentUserGuidelines);
            localStorage.setItem('userProfileImgUrl', userProfileImgUrl); localStorage.setItem('botProfileImgUrl', botProfileImgUrl);

            SYSTEM_PROMPT = buildSystemPrompt(
                 currentBotName, currentUserName, currentBotPersona, currentBotAge, currentBotAppearance,
                 currentUserAge, currentUserAppearance, currentUserGuidelines
             );
            console.log("설정 저장 완료 및 SYSTEM_PROMPT 업데이트:", SYSTEM_PROMPT);
            alert("설정이 저장되었습니다.");
        }

         function buildSystemPrompt(botName, userName, botPersona, botAge, botAppearance, userAge, userAppearance, userGuidelines) {
             let finalPrompt = SYSTEM_PROMPT_TEMPLATE
                 .replace('{botName}', botName || '이안').replace('{botAge}', botAge || '불명').replace('{botAppearance}', botAppearance || '설정되지 않음')
                 .replace('{botPersona}', botPersona || '설정된 페르소나 없음.').replace('{userName}', userName || '피주머니').replace('{userAge}', userAge || '불명')
                 .replace('{userAppearance}', userAppearance || '설정되지 않음').replace('{userGuidelines}', userGuidelines || '설정된 사용자 지침 없음.');
             return finalPrompt.trim();
         }

        function initializeChat() {
             console.log("initializeChat 호출됨");
             loadSettings();
             conversationHistory = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }];
             console.log("초기 SYSTEM_PROMPT:", SYSTEM_PROMPT);

             console.log("초기 메시지 추가 시도");
             const initialBotGreeting = `...${botNameInput.value || "이안"}의 ${userNameInput.value || "피주머니"}... 그래, 이곳에 왔군요...`;
             appendMessage("bot", { type: 'text', text: initialBotGreeting });
             console.log("채팅 초기화 완료.");

             sidebar.classList.add("folded");
             sidebarOverlay.style.display = 'none';
        }

        chat.addEventListener('scroll', function() {
            if (chat.scrollTop > 100) { scrollToTopButton.style.display = 'flex'; } else { scrollToTopButton.style.display = 'none'; }
        });

        scrollToTopButton.addEventListener('click', function() {
            chat.scrollTo({ top: 0, behavior: 'smooth' });
        });

        window.addEventListener('DOMContentLoaded', initializeChat);


    </script>
</body>
</html>
