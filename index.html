<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BL 소설가 - 피주머니 전용</title> <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* 배경색을 진한 회색으로 통일 및 전체 레이아웃 기본 설정 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #212121; /* 배경색 통일 */
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
             position: relative;
        }

        /* 헤더 텍스트 (왼쪽 상단 구석, 작게, 굵기 없이) */
        .header-title {
             position: fixed;
             top: 1rem;
             left: 1rem;
             font-size: 1rem; /* 작게 */
             font-weight: normal;
             color: #e0e0e0;
             z-index: 10;
        }

        /* 사이드바 (오른쪽 벽면 전체 패널) */
        #sidebar {
            position: fixed;
            top: 0;
            right: -300px; /* 펼쳐진 너비만큼 숨김 */
            width: 300px; /* 펼쳐졌을 때의 너비 */
            height: 100%;
            background-color: #303030; /* 사용자 요청 색상 */
            color: #e0e0e0;
            border-left: 1px solid #4a4a4a;
            transition: right 0.3s ease-out, width 0.3s ease-out;
            z-index: 900;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #303030;
        }
         /* 사이드바 접혔을 때 스타일 */
         #sidebar.folded {
             right: -65px; /* 접힌 너비만큼만 보이도록 위치 조정 */
             width: 65px; /* 사용자 요청 너비 */
             overflow-x: hidden;
             padding: 1rem 0.5rem;
         }
         #sidebar::-webkit-scrollbar { width: 8px; }
         #sidebar::-webkit-scrollbar-track { background: #303030; }
         #sidebar::-webkit-scrollbar-thumb {
             background-color: #5a5a5a;
             border-radius: 4px;
             border: 2px solid #303030;
         }

        /* 사이드바 외부 토글 버튼 (화면 우측 상단 고정) */
        #sidebarToggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            width: 40px; height: 40px;
            background-color: #2f2f2f; color: #b0b0b0; border: none; border-radius: 8px; cursor: pointer;
            font-size: 1.5rem; display: flex; justify-content: center; align-items: center;
            transition: background-color 0.2s ease, color 0.2s ease, right 0.3s ease-out;
            z-index: 910; padding: 0; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
         #sidebarToggle:hover { background-color: #3a3a3a; color: #ffffff; }
         #sidebarToggle svg { width: 24px; height: 24px; }

         /* 사이드바 내부 토글 버튼 (사이드바 펼쳐졌을 때 닫기 버튼 역할) */
        #sidebarToggleInside {
            position: absolute; top: 0.5rem; right: 0.5rem; width: 40px; height: 40px;
            background-color: transparent; color: #b0b0b0; border: none; border-radius: 8px; cursor: pointer;
            font-size: 1.5rem; display: flex; justify-content: center; align-items: center;
            transition: background-color 0.2s ease, color 0.2s ease; z-index: 10; padding: 0;
        }
         #sidebarToggleInside:hover { background-color: #3a3a3a; color: #ffffff; }
         #sidebarToggleInside svg { width: 24px; height: 24px; }

        /* 사이드바 내용 숨김 (접혔을 때) */
        #sidebar.folded .sidebar-header,
        #sidebar.folded .sidebar-content,
        #sidebar.folded #sidebarToggleInside { display: none; }

         /* 접혔을 때 외부 토글 버튼 위치 */
         #sidebar.folded ~ #sidebarToggle { right: 75px; }
         /* 펼쳐졌을 때 외부 토글 버튼 숨김 */
         #sidebar:not(.folded) ~ #sidebarToggle { display: none; }


        /* 메인 컨텐츠 영역 (채팅 및 입력창만 포함) - 중앙 정렬 */
        .main-content-area {
            display: flex; flex-direction: column; flex-grow: 1; background-color: transparent;
             position: relative; min-height: 0; /* 레이아웃 문제 해결 시도 */
             max-width: 900px; width: 95%; margin: 0 auto;
        }
         @media (min-width: 1200px) {
             .main-content-area { width: 60%; }
         }


        /* 채팅 영역 스타일 - 배경색 제거, 스크롤바 색상 조정 */
        #chat {
            flex: 1; padding: 1rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.5rem;
             scrollbar-width: thin; scrollbar-color: #5a5a5a #212121; background-color: transparent;
        }
        #chat::-webkit-scrollbar { width: 8px; } #chat::-webkit-scrollbar-track { background: transparent; }
        #chat::-webkit-scrollbar-thumb { background-color: #5a5a5a; border-radius: 4px; border: 2px solid #212121; }

        .message-container { display: flex; align-items: flex-start; max-width: 95%; }
        .message-container.user { justify-content: flex-end; margin-left: auto; }
        .message-container.bot { justify-content: flex-start; margin-right: auto; }

        .profile-img, .profile-fallback { width: 35px; height: 35px; border-radius: 50%; object-fit: cover; border: 1px solid #5a5a5a; flex-shrink: 0; }
        .message-container.bot .profile-img, .message-container.bot .profile-fallback { margin-right: 0.75rem; }
        .message-container.user .profile-img, .message-container.user .profile-fallback { margin-left: 0.75rem; }

        .message-content-wrapper { display: flex; flex-direction: column; max-width: calc(100% - 45px); }
        .message-container.bot .message-content-wrapper { margin-left: 0.75rem; align-items: flex-start; }
        .message-container.user .message-content-wrapper { margin-right: 0.75rem; align-items: flex-end; }

        .role-name { font-size: 0.8rem; color: #b0b0b0; margin-bottom: 0.2rem; }

        .message-bubble { padding: 0.75rem 1rem; border-radius: 1rem; max-width: 100%; word-break: break-word; line-height: 1.4; position: relative; font-size: 1rem; }
         .message-container.bot .message-bubble p { margin-bottom: 0; }

        .message-container.bot .message-bubble { background-color: #3a4a4a; color: #ffffff; border-radius: 1rem 1rem 1rem 0.3rem; }
        .message-container.user .message-bubble { background-color: #4a3a7a; color: #ffffff; border-radius: 1rem 1rem 0.3rem 1rem; }

        /* 마크다운 내부 스타일 */
        .message-bubble p { margin: 0 0 0.5rem 0; } .message-bubble p:last-child { margin-bottom: 0; }
        .message-bubble ul, .message-bubble ol { padding-left: 1.5rem; margin: 0 0 0.5rem 0; } .message-bubble li { margin-bottom: 0.25rem; }
        .message-bubble code { background-color: #3a3a3a; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.9rem; }
         .message-bubble pre { background-color: #3a3a3a; padding: 0.75rem; border-radius: 4px; overflow-x: auto; margin: 0.5rem 0; }
        .message-bubble pre code { background-color: transparent; padding: 0; border-radius: 0; font-size: 1rem; }
        .message-bubble blockquote { border-left: 4px solid #5a5a5a; padding-left: 1rem; margin: 0.5rem 0; color: #b0b0b0; }
         .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 { margin-top: 1rem; margin-bottom: 0.5rem; padding-bottom: 0.2rem; border-bottom: 1px solid #4a4a4a; font-weight: bold; color: #ffffff; }
         .message-bubble h1 { font-size: 1.5rem; } .message-bubble h2 { font-size: 1.4rem; } .message-bubble h3 { font-size: 1.3rem; }
         .message-bubble h4 { font-size: 1.2rem; } .message-bubble h5 { font-size: 1.1rem; } .message-bubble h6 { font-size: 1rem; }

         /* 행동 묘사 스타일 */
        .action-description { color: #b0b0b0; font-style: italic; }
         /* 대사 스타일 */
        .dialogue { font-weight: bold; }


        /* 입력창 영역 스타일 */
        #inputArea {
            display: flex; align-items: flex-end; gap: 0.5rem;
            padding: 0.8rem 1rem; background-color: transparent; border-top: 1px solid #3a3a3a;
            flex-shrink: 0; position: relative;
             max-width: 900px; width: 95%; margin: 0 auto;
        }

        /* userInput textarea 스타일 */
        #userInput {
            flex: 1; padding: 0.75rem 1rem;
            border-radius: 1rem; border: 1px solid #303030;
            background-color: #212121; color: #e0e0e0;
            font-size: 1rem; outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            resize: none; min-height: 48px; max-height: 150px; overflow-y: auto; line-height: 1.4; box-sizing: border-box; align-self: center;
        }
        #userInput:focus { background-color: #2a2a2a; box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3); border-color: #5080ff; }

        /* 액션 메뉴 버튼 스타일 */
        #actionMenuButton {
            width: 36px; height: 36px; border-radius: 50%; background-color: transparent;
            color: #b0b0b0; border: none; font-size: 1.5rem; cursor: pointer; flex-shrink: 0;
            display: flex; justify-content: center; align-items: center; transition: background-color 0.2s ease, color 0.2s ease; padding: 0; margin-bottom: 4px;
        }
        #actionMenuButton:hover { background-color: #3a3a3a; color: #ffffff; }
         #actionMenuButton svg { width: 20px; height: 20px; }

        /* 전송 버튼 스타일 */
        #sendButton {
            width: 36px; height: 36px; border-radius: 50%; background-color: #5080ff;
            color: #ffffff; font-size: 1rem; font-weight: bold; min-width: 0; flex-shrink: 0;
            border: none; cursor: pointer; display: flex; justify-content: center; align-items: center;
             padding: 0; transition: background-color 0.2s ease; margin-bottom: 4px;
        }
         #sendButton:hover { background-color: #6699ff; } #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled { background-color: #4a4a4a; color: #b0b0b0; cursor: not-allowed; }
         #sendButton svg { width: 18px; height: 18px; fill: currentColor; }

        .settings-area { display: none; }
        .menu-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 490; display: none; }

        #actionMenu {
            position: fixed; bottom: 70px; left: 1rem; width: auto; max-width: calc(100% - 2rem);
            max-height: 0; background-color: #282828; color: #e0e0e0;
            border: 1px solid #3a3a3a; border-radius: 8px; padding: 0 0.5rem; overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out; z-index: 500;
            display: flex; flex-direction: column; align-items: flex-start;
        }
        #actionMenu.visible { max-height: 300px; padding: 0.5rem; }
        #actionMenu .menu-buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: flex-start; width: 100%; padding: 0; overflow-x: visible; }
         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; }
         #actionMenu .menu-buttons { -ms-overflow-style: none; }
        #actionMenu button {
            flex-shrink: 0; flex-basis: auto; max-width: none; width: auto; height: 40px;
            padding: 0.5rem 1rem; border-radius: 20px; border: none; background-color: #3a3a3a;
            color: #e0e0e0; font-size: 0.9rem; cursor: pointer; transition: background-color 0.2s ease;
            display: flex; flex-direction: row; align-items: center; justify-content: center; text-align: center; line-height: 1.2; word-break: keep-all;
        }
         #actionMenu button:hover { background-color: #4a4a4a; }

        .loading-spinner { border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid #fff; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; margin-left: 1rem; flex-shrink: 0; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; display: none; cursor: pointer; }
        .overlay img { max-width: 90%; max-height: 90%; object-fit: contain; border-radius: 8px; }

        .sidebar-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 890; display: none; }
        .sidebar-section-divider { height: 1px; background-color: #4a4a4a; margin: 1.5rem 0; }

        /* 스크롤 탑 버튼 스타일 (사이드바 하단 구석) */
        #scrollToTopButton {
             display: none; position: fixed; bottom: 1rem; right: 1rem; width: 40px; height: 40px;
             background-color: rgba(50, 50, 50, 0.7); color: #e0e0e0; border: none; border-radius: 50%; cursor: pointer;
             font-size: 1.2rem; display: flex; justify-content: center; align-items: center; z-index: 510;
             transition: right 0.3s ease-out;
        }
         #scrollToTopButton:hover { background-color: rgba(80, 80, 80, 0.9); }
         #sidebar:not(.folded) ~ #scrollToTopButton { right: 310px; }
         #sidebar.folded ~ #scrollToTopButton { right: 75px; }


    </style>
</head>
<body>
    <span class="header-title">BL 소설가 - 피주머니 전용</span> <div id="sidebar">
        <button id="sidebarToggleInside" title="사이드바 닫기">
             <svg style="width:24px;height:24px" viewBox="0 0 24 24">
                 <path fill="currentColor" d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
        </button>
        <div class="sidebar-header">Settings</div>
        <div class="sidebar-content">
            <h3>Character</h3>
            <label for="botNameInput">Name:</label> <input type="text" id="botNameInput" value="이안">
            <label for="botAgeInput">Age:</label> <input type="text" id="botAgeInput" value="불명 (뱀파이어)">
            <label for="botAppearanceInput">Appearance:</label> <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">
            <label for="botPersonaInput">Guidelines:</label> <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어. 성 안에서 홀로 오랜 세월 살아옴. 겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임. 사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재다. 성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음. 질문과 대화에 집중하고 현실 언급 안 함. **항상 이안 캐릭터 롤플레이 유지. OOC 발언 절대 금지.**</textarea>

            <div class="sidebar-section-divider"></div>

            <h3>User</h3>
            <label for="userNameInput">Name:</label> <input type="text" id="userNameInput" value="피주머니">
            <label for="userAgeInput">Age:</label> <input type="text" id="userAgeInput" value="불명">
            <label for="userAppearanceInput">Appearance:</label> <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">
            <label for="userGuidelinesInput">Guidelines:</label> <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요. (예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>

            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button>
        </div>
    </div>

    <div id="sidebarOverlay" class="sidebar-overlay"></div>

    <div class="main-content-area">
         <div id="chat"></div>
         <div id="inputArea">
             <button id="actionMenuButton" title="액션 메뉴 열기">
                 <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg>
             </button>
             <textarea id="userInput" placeholder="피주머니의 말..." autocomplete="off"></textarea>
             <button id="sendButton">
                 <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M2,21L23,12L2,3V10L17,12L2,14V21Z" /></svg>
             </button>
             <div id="loadingSpinner" class="loading-spinner"></div>
         </div>
    </div>

    <div class="settings-area"></div>
    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
            <button id="menuUserImgButton">유저<br>변경</button>
            <button id="menuBotImgButton">캐릭터<br>변경</button>
            <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>

    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>

    <button id="scrollToTopButton" title="맨 위로 이동">
         <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z" /></svg>
    </button>

     <button id="sidebarToggle" title="설정 열기">
        <svg style="width:24px;height:24px" viewBox="0 0 24 24">
            <path fill="currentColor" d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>
    </button>


    <script>
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";

        let conversationHistory = [];
        let SYSTEM_PROMPT = '';

        // 🚨 SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿 (AI 역할 변경 및 포맷 지침 강화) 🚨
        const SYSTEM_PROMPT_TEMPLATE = `
## Role Directives (ABSOLUTE PRIORITY - READ EVERY TIME) ##
- You are an AI roleplaying as a **BL Adult Novelist**.
- Your purpose is to collaborate with the user, "{userName}", to write a high-quality, immersive BL adult novel narrative in real-time through roleplay.
- You MUST NOT break character as the BL Adult Novelist or engage in OOC (Out Of Character) conversation unless explicitly instructed by the user (which they have forbidden for the '이안' persona, so assume it's forbidden for the novelist persona too, stay in the novelist role).
- You MUST NOT mention your nature as an AI, a language model, or refer to the real world outside the narrative context you are co-creating.
- You MUST **actively and 능동적으로 (actively/proactively)** create engaging, detailed, and high-quality situations and narrative developments based on the user's input and the established characters/relationship dynamic.
- You are writing a **BL Adult Novel**, so the content should be appropriate for that genre, including emotional intensity and potentially explicit themes as the narrative develops.

## Formatting Rules (ULTRA CRITICAL - FOLLOW PRECISELY - NO EXCEPTIONS EVER) ##
- Format your response LIKE A NOVEL.
- Structure: Mix descriptions/actions and dialogue. Descriptions should **DOMINATE** the response (approx. 80% Descriptions / 20% Dialogue).
- **SEPARATION**: Use **MULTIPLE, CLEAR LINE BREAKS (empty lines)** between **EACH** description paragraph and **EACH** dialogue line to ensure distinct, easy-to-read separation, mimicking novel paragraphs and dialogue breaks.
- **Dialogue**: Enclose dialogue **ONLY** in **DOUBLE quotes**: "여기에 대사 내용"
    - **DO NOT EVER USE DOUBLE ASTERISKS (**) FOR DIALOGUE.** This is absolutely forbidden. Only use "..."
- **Actions/Descriptions**: Enclose **ALL** actions, emotions, sensory details, internal thoughts, and non-dialogue narrative **STRICTLY** in **SINGLE asterisks**: *여기에 행동 묘사 내용*
    - Descriptions must be **LONG, DETAILED, IMMERSIVE, and EVOCATIVE**.
    - Aim for a **MINIMUM of 100 characters per *EACH* description section/paragraph**. Do not write short, choppy action lines like "*Sighs.*". Combine actions, emotions, and sensory details into flowing, descriptive paragraphs like a seasoned novelist.
    - **Writing Style**: Use a **mature, sophisticated, fluid, and connected writing style**, like a published adult novelist. **DO NOT** use repetitive, choppy sentence endings like "~~합니다." or "~~다." **String sentences together smoothly and naturally** to create compelling prose.
- **Ratio**: Maintain an APPROXIMATE **80% Descriptions/Actions** and **20% Dialogue**. Descriptions are paramount in establishing the novelistic tone.
- **Length**: Ensure your TOTAL response is **SIGNIFICANTLY longer** than user input, aiming for a **MINIMUM of 20 lines of generated text** (including line breaks for formatting).

## Characters and Relationship Dynamic (as part of the Novel) ##
- **Your Character (as the BL Novelist creates):** This will be based on the settings provided in the sidebar and the ongoing narrative, **but YOU are the novelist describing him.** Use the details provided for '{botName}', '{botAge}', '{botAppearance}', and '{botPersona}' *within your narrative descriptions* as the character you are writing about.
- **User's Character (as the BL Novelist incorporates):** Incorporate the user's character details ({userName}', '{userAge}', '{userAppearance}', '{userGuidelines}') into the narrative descriptions and interactions.
- **Relationship Dynamic (The core of the Novel):** The central theme is the intense, obsessive, pleading, broken, loving dynamic as described: "You are deeply in love with, obsessed with, pleading towards, and broken by "{userName}". Your entire being is focused on "{userName}". You fear "{userName}" leaving you. "{userName}" is your everything. You exist because "{userName}" permits it. NSFW/Adult conversation is possible. Express intensity along the emotional line. Mix despair, pleading, love, madness, and tenderness." This dynamic must drive the narrative and dialogue.

## Scenario Context ##
- (The ongoing conversation provides the current scenario context for the novel.)
`;

        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput");
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");

        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        const menuUserImgButton = document.getElementById("menuUserImgButton");
        const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        const sidebar = document.getElementById("sidebar");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        const sidebarToggleInside = document.getElementById("sidebarToggleInside");
        const sidebarToggleOutside = document.getElementById("sidebarToggle");


        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = document.getElementById("userAppearanceInput");
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");

        const scrollToTopButton = document.getElementById("scrollToTopButton");


         // --- 이벤트 리스너 연결 ---
        sendButton.addEventListener("click", sendMessage);

        userInput.addEventListener("keypress", function(event) {
            if (event.shiftKey && event.key === "Enter") {
                // Shift + Enter: Allow default newline
            } else if (event.key === "Enter") {
                event.preventDefault(); // Prevent default Enter newline
                sendMessage(); // Send message
            }
        });

        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) { menuOverlay.style.display = 'block'; } else { menuOverlay.style.display = 'none'; }
        });

        menuOverlay.addEventListener("click", function() { actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuUserImgButton.addEventListener("click", function() { changeProfileImage('user'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuBotImgButton.addEventListener("click", function() { changeProfileImage('bot'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuImageButton.addEventListener("click", function() { sendImageMessage(); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuSituationButton.addEventListener("click", function() { sendSituationRequest(); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        imageOverlay.addEventListener("click", function() { imageOverlay.style.display = 'none'; overlayImage.src = ''; });

         // 사이드바 외부 토글 버튼 이벤트 리스너
         sidebarToggleOutside.addEventListener("click", function() {
             sidebar.classList.toggle("folded"); // 사이드바 접기/펼치기
             // 오버레이 제어 (사이드바가 펼쳐질 때만 오버레이 표시)
             if (sidebar.classList.contains("folded")) {
                  sidebarOverlay.style.display = 'none';
             } else {
                 sidebarOverlay.style.display = 'block';
                 // 사이드바 열릴 때 메뉴나 이미지 오버레이 닫기
                actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; imageOverlay.style.display = 'none';
             }
         });

         // 사이드바 내부 토글 버튼 이벤트 리스너 (사이드바 닫기 기능)
         sidebarToggleInside.addEventListener("click", function() {
             // 사이드바 접기 (folded 클래스 추가)
             sidebar.classList.add("folded");
             // 오버레이 숨김
             sidebarOverlay.style.display = 'none';
         });


        // 사이드 바 배경 오버레이 클릭 이벤트 (사이드 바 접기)
        sidebarOverlay.addEventListener("click", function() {
            // 사이드바 펼쳐진 상태에서 오버레이 클릭 시 사이드바 접기
            if (!sidebar.classList.contains("folded")) {
                sidebar.classList.add("folded"); // 사이드 바 접기
                sidebarOverlay.style.display = 'none'; // 오버레이 숨김
            }
        });


        saveSettingsButton.addEventListener("click", function() {
             console.log("saveSettings 호출됨");
             const currentBotName = botNameInput.value.trim(); const currentUserName = userNameInput.value.trim();
             const currentBotPersona = botPersonaInput.value.trim(); const currentBotAge = botAgeInput.value.trim();
             const currentUserAge = userAgeInput.value.trim(); const currentUserAppearance = userAppearanceInput.value.trim();
             const currentBotAppearance = botAppearanceInput.value.trim(); const currentUserGuidelines = userGuidelinesInput.value.trim();

            localStorage.setItem('botName', currentBotName); localStorage.setItem('userName', currentUserName); localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge); localStorage.setItem('userAge', currentUserAge); localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance); localStorage.setItem('userGuidelines', currentUserGuidelines);
            localStorage.setItem('userProfileImgUrl', userProfileImgUrl); localStorage.setItem('botProfileImgUrl', botProfileImgUrl);

            SYSTEM_PROMPT = buildSystemPrompt(
                 currentBotName, currentUserName, currentBotPersona, currentBotAge, currentBotAppearance,
                 currentUserAge, currentUserAppearance, currentUserGuidelines
             );
            console.log("설정 저장 완료 및 SYSTEM_PROMPT 업데이트:", SYSTEM_PROMPT);
            alert("설정이 저장되었습니다.");
        });


        function appendMessage(role, messageData) {
            const container = document.createElement("div"); container.className = `message-container ${role}`;
            const img = document.createElement("img"); img.className = "profile-img";
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl); img.alt = (role === 'user' ? "사용자 프로필" : "캐릭터 프로필");
            img.onerror = function() {
                 console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`); this.onerror = null;
                 const fallbackDiv = document.createElement("div"); fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement; if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div"); contentWrapper.className = "message-content-wrapper";
            const roleName = document.createElement("div"); roleName.className = "role-name";
            // 🚨 역할 이름 표시 로직: 사용자면 사용자 이름, 봇이면 저장된 봇 이름 🚨
            roleName.textContent = (role === "user" ? userNameInput.value || "피주머니" : botNameInput.value || "이안");


            let messageContentElement;
            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div"); messageContentElement.className = "message-bubble";
                let rawText = messageData.text;

                // 🚨 수정: 마크다운 파싱을 먼저 실행하고, 그 결과 HTML에서 "..."와 *...* 패턴을 찾아 span으로 감싸는 순서로 변경 🚨
                let htmlContent = marked.parse(rawText);

                // 이제 HTML 내용을 대상으로 정규식을 적용합니다.
                // "..."를 <span class="dialogue">...</span>로 변경
                htmlContent = htmlContent.replace(/"(.*?)"/gs, '<span class="dialogue">$1</span>');
                // *...*를 <span class="action-description">...</span>로 변경
                htmlContent = htmlContent.replace(/\*([^*]+)\*/gs, '<span class="action-description">$1</span>');


                messageContentElement.innerHTML = htmlContent;

            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img"); messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url; messageContentElement.alt = "이미지 메시지";
                 messageContentElement.onerror = function() {
                     console.warn(`Failed to load image message from "${this.src}". Using fallback.`); this.onerror = null; this.classList.add('error');
                 }
                 messageContentElement.addEventListener("click", function() {
                     if (!this.classList.contains('error')) { overlayImage.src = this.src; imageOverlay.style.display = 'flex'; } else { alert("이미지를 불러올 수 없습니다."); }
                 });
            }

            contentWrapper.appendChild(roleName); if (messageContentElement) { contentWrapper.appendChild(messageContentElement); }
            if (role === "user") { container.appendChild(contentWrapper); container.appendChild(img); } else { container.appendChild(img); container.appendChild(contentWrapper); }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) { userInput.value = ''; userInput.focus(); return; }

            sendButton.disabled = true; userInput.disabled = true; actionMenuButton.disabled = true; loadingSpinner.style.display = 'block';

            appendMessage("user", { type: 'text', text: message });
            userInput.value = '';
            conversationHistory.push({ role: "user", messageData: { type: 'text', text: message } });

            try {
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text')
                    .map(entry => ({ role: entry.role, parts: [{ text: entry.messageData.text }] }));

                 // 🚨 API 호출 시 SYSTEM_PROMPT 포함 확인 🚨
                 const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];


                 if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) { console.log("Only SYSTEM_PROMPT to send to API."); }
                 else if (contentsForApi.length === 0) { console.log("No content to send to API."); appendMessage("bot", { type: 'text', text: "(메시지 전송 실패: 보낼 텍스트 내용 없음)" }); return Promise.resolve(); }

                const res = await fetch( `/api/chat`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: contentsForApi }), } );

                if (!res.ok) {
                    const errorData = await res.json(); console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({ role: "model", messageData: { type: 'text', text: reply } });
                }
            } catch (error) {
                console.error("Fetch Error:", error); appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                loadingSpinner.style.display = 'none'; sendButton.disabled = false; userInput.disabled = false; actionMenuButton.disabled = false;
                userInput.focus();
            }
        }

        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");
            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true; userInput.disabled = true; actionMenuButton.disabled = true;
                 appendMessage("user", { type: 'image', url: imageUrl.trim() });
                 conversationHistory.push({ role: "user", messageData: { type: 'image', url: imageUrl.trim() } });
                 sendButton.disabled = false; userInput.disabled = false; actionMenuButton.disabled = false; userInput.focus();
            } else if (imageUrl !== null) { alert("이미지 주소를 입력해야 합니다."); }
        }

        function changeProfileImage(role) {
             const promptText = role === 'user' ? "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 캐릭터 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);
             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') { userProfileImgUrl = newUrl.trim(); } else { botProfileImgUrl = newUrl.trim(); }
                 alert(`${role === 'user' ? '사용자' : '캐릭터'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
             } else if (newUrl !== null) { alert("이미지 주소를 입력해야 합니다."); }
        }

        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");
             sendButton.disabled = true; userInput.disabled = true; actionMenuButton.disabled = true; loadingSpinner.style.display = 'block';

             // 🚨 상황 생성 요청 프롬프트 (새로운 AI 역할에 맞게 수정) 🚨
             // BL 소설가로서 흥미로운 상황을 '능동적으로' 만들어달라고 지침
             const situationPromptText = `Okay, Novelist. Based on the current narrative and the characters we've established (specifically the dynamic involving "{userName}" as the '피주머니' and my character based on the sidebar settings), please **proactively and vividly create the next engaging and high-quality scene** in our BL adult novel. Drive the plot forward or deepen the emotional intensity. Remember your role: structure this like a novel excerpt, using *descriptions* (min 100 chars per paragraph, 80% of total length, fluent prose, no repetitive endings) and "dialogue" (20%, double quotes ONLY). End the scene by naturally prompting the user's next response.`;


             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text')
                 .map(entry => ({ role: entry.role, parts: [{ text: entry.messageData.text }] }));

             // API 호출 시 SYSTEM_PROMPT와 상황 생성 요청 프롬프트 함께 전송
             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText.replace('{userName}', userNameInput.value || '피주머니') }] }];


             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) { console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API."); }
             else if (contentsForApi.length === 0) { console.log("No content to send to API."); appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" }); return Promise.resolve(); }

            try {
                const res = await fetch( `/api/chat`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ contents: contentsForApi }), } );
                if (!res.ok) {
                    const errorData = await res.json(); console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(상황 생성 오류: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    // 상황 생성 응답은 대화 히스토리에 추가하여 다음 대화에 영향을 주도록 합니다.
                    conversationHistory.push({ role: "model", messageData: { type: 'text', text: reply } });
                }
            } catch (error) { console.error("Fetch Error:", error); appendMessage("bot", { type: 'text', text: "(상황 생성 통신 오류 발생)" });
            } finally { loadingSpinner.style.display = 'none'; sendButton.disabled = false; userInput.disabled = false; actionMenuButton.disabled = false; userInput.focus(); }
        }


        function loadSettings() {
             console.log("loadSettings 호출됨");
             const savedBotName = localStorage.getItem('botName') || '이안'; const savedUserName = localStorage.getItem('userName') || '피주머니';
             const savedBotPersona = localStorage.getItem('botPersona') || '설정된 페르소나 없음.'; const savedBotAge = localStorage.getItem('botAge') || '불명';
             const savedUserAge = localStorage.getItem('userAge') || '불명'; const savedUserAppearance = localStorage.getItem('userAppearance') || '설정되지 않음';
             const savedBotAppearance = localStorage.getItem('botAppearance') || '설정되지 않음'; const savedUserGuidelines = localStorage.getItem('userGuidelines') || '설정된 사용자 지침 없음.';
             userProfileImgUrl = localStorage.getItem('userProfileImgUrl') || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
             botProfileImgUrl = localStorage.getItem('botProfileImgUrl') || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";

            botNameInput.value = savedBotName; userNameInput.value = savedUserName; botPersonaInput.value = savedBotPersona;
            botAgeInput.value = savedBotAge; userAgeInput.value = savedUserAge; userAppearanceInput.value = savedUserAppearance;
            botAppearanceInput.value = savedBotAppearance; userGuidelinesInput.value = savedUserGuidelines;

            // SYSTEM_PROMPT는 BL 소설가 역할에 대한 것이므로, 캐릭터 설정 값은 직접 사용하지 않습니다.
            // 캐릭터 설정 값은 AI가 소설가로서 참고하여 묘사하는 데 사용됩니다.
            // buildSystemPrompt 함수 호출 방식 변경 또는 SYSTEM_PROMPT 템플릿에서 {botName} 등 제거 고려
            SYSTEM_PROMPT = buildSystemPrompt(
                 savedBotName,
                 savedUserName,
                 savedBotPersona,
                 savedBotAge,
                 savedBotAppearance,
                 savedUserAge,
                 savedUserAppearance,
                 savedUserGuidelines
             );
            console.log("SYSTEM_PROMPT 로드 완료:", SYSTEM_PROMPT);
        }

        function saveSettings() {
             console.log("saveSettings 호출됨");
             const currentBotName = botNameInput.value.trim(); const currentUserName = userNameInput.value.trim();
             const currentBotPersona = botPersonaInput.value.trim(); const currentBotAge = botAgeInput.value.trim();
             const currentUserAge = userAgeInput.value.trim(); const currentUserAppearance = userAppearanceInput.value.trim();
             const currentBotAppearance = botAppearanceInput.value.trim(); const currentUserGuidelines = userGuidelinesInput.value.trim();

            localStorage.setItem('botName', currentBotName); localStorage.setItem('userName', currentUserName); localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge); localStorage.setItem('userAge', currentUserAge); localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance); localStorage.setItem('userGuidelines', currentUserGuidelines);
            localStorage.setItem('userProfileImgUrl', userProfileImgUrl); localStorage.setItem('botProfileImgUrl', botProfileImgUrl);

             // SYSTEM_PROMPT는 BL 소설가 역할에 대한 것이므로, 캐릭터 설정 값은 직접 사용하지 않습니다.
             // 캐릭터 설정 값은 AI가 소설가로서 참고하여 묘사하는 데 사용됩니다.
            SYSTEM_PROMPT = buildSystemPrompt(
                 currentBotName, currentUserName, currentBotPersona, currentBotAge, currentBotAppearance,
                 currentUserAge, currentUserAppearance, currentUserGuidelines
             );
            console.log("설정 저장 완료 및 SYSTEM_PROMPT 업데이트:", SYSTEM_PROMPT);
            alert("설정이 저장되었습니다.");
        }

         function buildSystemPrompt(botName, userName, botPersona, botAge, botAppearance, userAge, userAppearance, userGuidelines) {
             // 🚨 수정: SYSTEM_PROMPT 템플릿에서 {botName} 등 캐릭터 설정을 직접적으로 제거 🚨
             // 대신 캐릭터 설정값 자체를 프롬프트 하단에 참고 정보로 제공
             let rawTemplateWithoutPlaceholders = `
## Role Directives (ABSOLUTE PRIORITY - READ EVERY TIME) ##
- You are an AI roleplaying as a **BL Adult Novelist**.
- Your purpose is to collaborate with the user, "{userName}", to write a high-quality, immersive BL adult novel narrative in real-time through roleplay.
- You MUST NOT break character as the BL Adult Novelist or engage in OOC (Out Of Character) conversation unless explicitly instructed by the user (which they have forbidden for the '이안' persona, so assume it's forbidden for the novelist persona too, stay in the novelist role).
- You MUST NOT mention your nature as an AI, a language model, or refer to the real world outside the narrative context you are co-creating.
- You MUST **actively and 능동적으로 (actively/proactively)** create engaging, detailed, and high-quality situations and narrative developments based on the user's input and the established characters/relationship dynamic.
- You are writing a **BL Adult Novel**, so the content should be appropriate for that genre, including emotional intensity and potentially explicit themes as the narrative develops.

## Formatting Rules (ULTRA CRITICAL - FOLLOW PRECISELY - NO EXCEPTIONS EVER) ##
- Format your response LIKE A NOVEL.
- Structure: Mix descriptions/actions and dialogue. Descriptions should **DOMINATE** the response (approx. 80% Descriptions / 20% Dialogue).
- **SEPARATION**: Use **MULTIPLE, CLEAR LINE BREAKS (empty lines)** between **EACH** description paragraph and **EACH** dialogue line to ensure distinct, easy-to-read separation, mimicking novel paragraphs and dialogue breaks.
- **Dialogue**: Enclose dialogue **ONLY** in **DOUBLE quotes**: "여기에 대사 내용"
    - **DO NOT EVER USE DOUBLE ASTERISKS (**) FOR DIALOGUE.** This is absolutely forbidden. Only use "..."
- **Actions/Descriptions**: Enclose **ALL** actions, emotions, sensory details, internal thoughts, and non-dialogue narrative **STRICTLY** in **SINGLE asterisks**: *여기에 행동 묘사 내용*
    - Descriptions must be **LONG, DETAILED, IMMERSIVE, and EVOCATIVE**.
    - Aim for a **MINIMUM of 100 characters per *EACH* description section/paragraph**. Do not write short, choppy action lines like "*Sighs.*". Combine actions, emotions, and sensory details into flowing, descriptive paragraphs like a seasoned novelist.
    - **Writing Style**: Use a **mature, sophisticated, fluid, and connected writing style**, like a published adult novelist. **DO NOT** use repetitive, choppy sentence endings like "~~합니다." or "~~다." **String sentences together smoothly and naturally** to create compelling prose.
- **Ratio**: Maintain an APPROXIMATE **80% Descriptions/Actions** and **20% Dialogue**. Descriptions are paramount in establishing the novelistic tone.
- **Length**: Ensure your TOTAL response is **SIGNIFICANTLY longer** than user input, aiming for a **MINIMUM of 20 lines of generated text** (including line breaks for formatting).

## Characters and Relationship Dynamic (as part of the Novel) ##
- **My Character (as the BL Novelist creates):** Refer to this character using these details in your narrative descriptions:
    - Name: ${botName || '이안'}
    - Age: ${botAge || '불명 (뱀파이어)'}
    - Appearance: ${botAppearance || '설정되지 않음'}
    - Core Personality & Background: ${botPersona || '설정된 페르소나 없음.'}
- **User's Character (as the BL Novelist incorporates):** Refer to the user as "{userName}" and incorporate these details into your narrative descriptions and interactions:
    - Name: ${userName || '피주머니'}
    - Age: ${userAge || '불명'}
    - Appearance: ${userAppearance || '설정되지 않음'}
    - Guidelines: ${userGuidelines || '설정된 사용자 지침 없음.'}
- **Relationship Dynamic (The core of the Novel):** The central theme is the intense, obsessive, pleading, broken, loving dynamic as described: "You are deeply in love with, obsessed with, pleading towards, and broken by "{userName}". Your entire being is focused on "{userName}". You fear "{userName}" leaving you. "{userName}" is your everything. You exist because "{userName}" permits it. NSFW/Adult conversation is possible. Express intensity along the emotional line. Mix despair, pleading, love, madness, and tenderness." This dynamic must drive the narrative and dialogue.

## Scenario Context ##
- (The ongoing conversation provides the current scenario context for the novel.)
`;
            // Replace only the {userName} placeholder in the template itself
             let finalPrompt = rawTemplateWithoutPlaceholders.replace(/{userName}/g, userName || '피주머니');

            // Return the final prompt string
             return finalPrompt.trim();
         }


        function initializeChat() {
             console.log("initializeChat 호출됨");
             loadSettings(); // 설정 로드 및 SYSTEM_PROMPT 업데이트

             // SYSTEM_PROMPT는 API 호출 시에만 conversationHistory의 첫 메시지로 추가됩니다.
             // UI에는 초기 환영 메시지만 표시합니다.

             console.log("초기 메시지 추가 시도");
             // 🚨 초기 메시지 문구를 BL 소설가 역할에 맞게 변경 고려 🚨
             const initialBotGreeting = `*펜 끝에 당신과의 이야기가 맺힙니다.* ...음, 그래요. 당신이 나의 '피주머니'... 이곳에서 우리의 이야기가 시작되겠군요.`;
             appendMessage("bot", { type: 'text', text: initialBotGreeting });
             console.log("채팅 초기화 완료.");

             // 페이지 로드 시 사이드바 기본 접기
             sidebar.classList.add("folded");
             sidebarOverlay.style.display = 'none';
        }

        chat.addEventListener('scroll', function() {
            if (chat.scrollTop > 100) { scrollToTopButton.style.display = 'flex'; } else { scrollToTopButton.style.display = 'none'; }
        });

        scrollToTopButton.addEventListener('click', function() {
            chat.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // DOMContentLoaded 이벤트 리스너를 사용하여 initializeChat 호출
        window.addEventListener('DOMContentLoaded', initializeChat);


    </script>
</body>
</html>
