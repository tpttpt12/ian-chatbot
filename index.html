<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial=1.0" />
    <title>이안 - 피주머니 전용 챗봇</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* 🚨 배경색을 진한 회색으로 변경 및 전체 레이아웃 기본 설정 🚨 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0a0a0a; /* 진한 회색 배경 */
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex; /* Flexbox를 사용하여 내부 컨텐츠 정렬 */
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* 전체 스크롤 방지, 채팅 영역만 스크롤 */
        }

        /* 🚨 메인 컨텐츠 영역 (헤더, 채팅, 입력창 포함) - 중앙 정렬 및 너비 제한 🚨 */
        .app-container {
             display: flex;
             flex-direction: column;
             flex-grow: 1; /* 남은 공간을 모두 차지하여 높이 확보 */
             max-width: 900px; /* 최대 너비 설정 */
             width: 95%; /* 기본 너비 (작은 화면 대응) */
             margin: 0 auto; /* 좌우 자동 마진으로 중앙 정렬 */
             background-color: #1a1a1a; /* 바디보다 약간 밝은 회색 배경 */
             box-shadow: none; /* 그림자 제거 */
             border: none; /* 테두리 제거 */
             position: relative; /* 자식 요소 위치 기준 */
             overflow: hidden; /* 컨테이너 내부 내용 넘침 방지 */
        }
         /* 🚨 화면이 충분히 넓을 때 너비를 60%로 조정 🚨 */
         @media (min-width: 1200px) {
             .app-container {
                 width: 60%;
             }
         }

        /* 🚨 헤더 스타일 수정 (왼쪽 상단 텍스트, 사이드바 토글 분리) 🚨 */
        .chat-header {
            background-color: transparent; /* 배경 투명하게 (app-container 배경 사용) */
            color: #ffffff;
            padding: 1rem; /* 상하좌우 여백 */
            text-align: left; /* 텍스트 왼쪽 정렬 */
            font-size: 1.2rem;
            font-weight: normal; /* 굵기 제거 */
            border-bottom: 1px solid #3a3a3a;
            flex-shrink: 0;
            position: relative; /* 사이드바 토글 위치 기준 */
            display: flex; /* Flexbox 사용 */
            justify-content: space-between; /* 텍스트와 사이드바 토글 양 끝 정렬 */
            align-items: center; /* 세로 중앙 정렬 */
            height: 50px; /* 헤더 높이 고정 (사이드바 토글 크기와 맞춤) */
        }
         /* 헤더 제목 텍스트 스타일 */
         .header-title {
             font-size: 1.2rem;
             font-weight: normal;
             color: #e0e0e0;
             /* 왼쪽 상단에 배치되도록 추가적인 마진/패딩 조정 */
             padding: 0;
             margin: 0;
         }


         /* 🚨 사이드 바 토글 버튼 스타일 수정 (오른쪽 상단 배치) 🚨 */
         /* 헤더 안에서 분리하여 body 기준으로 절대 위치 지정 */
        #sidebarToggle {
            position: fixed; /* 뷰포트 기준 고정 */
            top: 1rem; /* 상단에서 1rem 여백 */
            right: 1rem; /* 우측에서 1rem 여백 */
            transform: none;
            width: 40px; /* 크기 조정 */
            height: 40px; /* 크기 조정 */
            background-color: #2f2f2f; /* 옅은 회색 배경 */
            color: #b0b0b0; /* 옅은 회색 아이콘 색상 */
            border: none;
            border-radius: 8px; /* 모서리 둥글게 */
            cursor: pointer;
            font-size: 1.5rem; /* 아이콘 크기 */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, color 0.2s ease, right 0.3s ease-out;
            z-index: 910; /* 사이드바보다 위에, 오버레이 아래 */
             padding: 0;
             box-shadow: 0 2px 5px rgba(0,0,0,0.3); /* 약간의 그림자 */
        }
         /* 사이드 바 열렸을 때 토글 버튼 위치 조정 (사이드바 옆) */
         #sidebar.visible + #sidebarToggle {
             right: 310px; /* 사이드바 너비(300) + 여백(10) */
         }

         #sidebarToggle:hover {
             background-color: #3a3a3a;
             color: #ffffff;
         }
         /* SVG 아이콘 스타일 */
         #sidebarToggle svg {
             width: 24px;
             height: 24px;
         }


        #chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #282828;
             background-color: transparent;
             /* 🚨 overflow-container 처럼 깔끔한 느낌을 위해 패딩 및 스크롤바 스타일 조정 🚨 */
        }

        #chat::-webkit-scrollbar { width: 8px; }
        #chat::-webkit-scrollbar-track { background: transparent; } /* 스크롤바 트랙 투명 */
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #1a1a1a; /* app-container 배경색과 맞춤 */
        }


        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 95%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            max-width: calc(100% - 45px);
        }

        .message-container.bot .message-content-wrapper {
            margin-left: 0.75rem;
            align-items: flex-start;
        }

        .message-container.user .message-content-wrapper {
            margin-right: 0.75rem;
            align-items: flex-end;
        }

        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
        }

        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative;
            font-size: 1rem;
        }
         /* 챗봇 메시지의 p 태그 하단 마진 제거 (더 세밀한 간격 제어) - 프롬프트 줄바꿈에 의존 */
         .message-container.bot .message-bubble p {
             margin-bottom: 0;
         }

        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* 마크다운 내부 스타일 */
        .message-bubble p { margin: 0 0 0.5rem 0; }
        .message-bubble p:last-child { margin-bottom: 0; }
        .message-bubble ul, .message-bubble ol { padding-left: 1.5rem; margin: 0 0 0.5rem 0; }
        .message-bubble li { margin-bottom: 0.25rem; }
        .message-bubble code {
            background-color: #3a3a3a;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
        }
         .message-bubble pre {
             background-color: #3a3a3a;
             padding: 0.75rem;
             border-radius: 4px;
             overflow-x: auto;
             margin: 0.5rem 0;
         }
        .message-bubble pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
             font-size: 1rem;
        }
        .message-bubble blockquote {
             border-left: 4px solid #5a5a5a;
             padding-left: 1rem;
             margin: 0.5rem 0;
             color: #b0b0b0;
        }
         .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 {
             margin-top: 1rem;
             margin-bottom: 0.5rem;
             padding-bottom: 0.2rem;
             border-bottom: 1px solid #4a4a4a;
             font-weight: bold;
             color: #ffffff;
         }
         .message-bubble h1 { font-size: 1.5rem; }
         .message-bubble h2 { font-size: 1.4rem; }
         .message-bubble h3 { font-size: 1.3rem; }
         .message-bubble h4 { font-size: 1.2rem; }
         .message-bubble h5 { font-size: 1.1rem; }
         .message-bubble h6 { font-size: 1rem; }


         /* 행동 묘사 스타일 */
        .action-description {
             color: #b0b0b0;
             font-style: italic;
         }
         /* 대사 스타일 */
        .dialogue {
             font-weight: bold;
         }


        /* 🚨 입력창 영역 스타일 재설계 (이미지 기반) 🚨 */
        #inputArea {
            display: flex;
            align-items: flex-end; /* 하단 정렬 */
            gap: 0.5rem; /* 요소 간 간격 줄임 */
            padding: 0.8rem 1rem; /* 상하 패딩 줄이고 좌우 유지 */
            background-color: #282828; /* 이전 배경 유지 */
            border-top: 1px solid #3a3a3a; /* 상단 구분선 유지 */
            flex-shrink: 0;
            position: relative;
             /* 이미지에 맞게 추가 스타일 */
             border-radius: 0; /* 상하단 둥근 모서리 제거 */
        }

        /* 🚨 userInput textarea 스타일 재설계 (이미지 기반) 🚨 */
        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 2rem; /* 훨씬 더 둥글게 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            resize: none;
            min-height: 48px; /* 이미지에 맞게 높이 조정 */
            max-height: 150px; /* 최대 높이 제한 */
            overflow-y: auto;
            line-height: 1.4;
            box-sizing: border-box;
            align-self: center; /* 세로 중앙 정렬 */
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        /* 🚨 액션 메뉴 버튼 스타일 수정 (입력창 왼쪽에 통합) 🚨 */
        #actionMenuButton {
            width: 48px; /* 이미지에 맞게 크기 조정 */
            height: 48px; /* 이미지에 맞게 크기 조정 */
            border-radius: 50%; /* 완전히 둥글게 */
            background-color: transparent; /* 배경 투명 */
            color: #b0b0b0; /* 옅은 회색 아이콘 색상 */
            border: none;
            font-size: 1.8rem; /* 아이콘 크기 */
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, color 0.2s ease;
             padding: 0;
        }
        #actionMenuButton:hover {
            background-color: #3a3a3a; /* 호버 시 배경색 */
            color: #ffffff;
        }
         /* SVG 아이콘 스타일 */
         #actionMenuButton svg {
             width: 28px;
             height: 28px;
         }


        /* 🚨 전송 버튼 스타일 수정 (입력창 오른쪽에 통합) 🚨 */
        #sendButton {
            width: 48px; /* 이미지에 맞게 크기 조정 */
            height: 48px; /* 이미지에 맞게 크기 조정 */
            border-radius: 50%; /* 완전히 둥글게 */
            background-color: #5080ff; /* 기본 파란색 */
            color: #ffffff;
            font-size: 1.2rem; /* 아이콘에 맞게 글자 크기 조정 */
            font-weight: bold;
            min-width: 0; /* 최소 너비 제한 제거 */
            flex-shrink: 0;
            border: none;
            cursor: pointer;
            display: flex; /* 아이콘/텍스트 중앙 정렬 */
            justify-content: center;
            align-items: center;
             padding: 0;
             transition: background-color 0.2s ease;
             /* 초기에는 화살표 아이콘, 로딩 중에는 스피너로 변경될 예정 */
        }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }
         /* 전송 버튼 안의 SVG 아이콘 스타일 */
         #sendButton svg {
             width: 24px;
             height: 24px;
             fill: currentColor; /* 글자 색상 따라가도록 */
         }
         /* 로딩 스피너 스타일은 별도 */


        .settings-area {
            display: none;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
        }

        #actionMenu {
            position: fixed;
            bottom: 70px; /* 입력창 높이 고려하여 메뉴 위치 조정 */
            left: 1rem; /* 왼쪽에서 여백 */
            /* width: calc(100% - 2rem); /* 좌우 여백 고려 너비 */ */
             width: auto; /* 내용에 맞게 너비 자동 조정 */
             max-width: calc(100% - 2rem);
             max-height: 0;
            background-color: #282828;
            color: #e0e0e0;
            border: 1px solid #3a3a3a; /* 테두리 추가 */
            border-radius: 8px; /* 모서리 둥글게 */
            padding: 0 0.5rem; /* 내부 패딩 조정 */
            overflow: hidden; /* 내용 숨김 */
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* 왼쪽 정렬 */
        }

        #actionMenu.visible {
            max-height: 300px; /* 메뉴가 보일 때 최대 높이 */
            padding: 0.5rem; /* 메뉴가 보일 때 패딩 */
        }

        #actionMenu .menu-buttons {
            display: flex;
             flex-wrap: wrap; /* 줄바꿈 허용 */
            gap: 0.5rem; /* 버튼 간 간격 */
            justify-content: flex-start; /* 왼쪽 정렬 */
            width: 100%; /* 부모 너비에 맞춤 */
            padding: 0; /* 패딩 제거 */
             overflow-x: visible; /* 넘쳐도 스크롤바 안 보이게 */
        }

         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; }
         #actionMenu .menu-buttons { -ms-overflow-style: none; }


        #actionMenu button {
            flex-shrink: 0;
            flex-basis: auto;
            max-width: none;
             width: auto; /* 너비 자동 조정 */
             height: 40px; /* 높이 조정 */
            padding: 0.5rem 1rem; /* 패딩 조정 */
             border-radius: 20px; /* 훨씬 더 둥글게 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: row; /* 글자 가로 배열 */
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2;
             word-break: keep-all;
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 1rem;
            flex-shrink: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* 🚨 사이드 바 스타일 수정 (옅은 회색 배경 등) 🚨 */
        #sidebar {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #2f2f2f; /* 옅은 회색 배경 */
            color: #e0e0e0;
            border-left: 1px solid #4a4a4a;
            transition: right 0.3s ease-out;
            z-index: 900;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
             /* 스크롤바 스타일 */
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #2f2f2f;
        }
         #sidebar::-webkit-scrollbar { width: 8px; }
         #sidebar::-webkit-scrollbar-track { background: #2f2f2f; }
         #sidebar::-webkit-scrollbar-thumb {
             background-color: #5a5a5a;
             border-radius: 4px;
             border: 2px solid #2f2f2f;
         }


        #sidebar.visible {
            right: 0;
        }

         .sidebar-header {
             font-size: 1.1rem;
             font-weight: bold;
             margin-bottom: 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid #4a4a4a;
         }

         .sidebar-content label {
             display: block;
             margin-bottom: 0.5rem;
             font-weight: bold;
             color: #b0b0b0;
         }

         .sidebar-content input[type="text"],
         .sidebar-content textarea {
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #3a3a3a;
             color: #e0e0e0;
             font-size: 1rem;
             margin-bottom: 1rem;
             box-sizing: border-box;
             resize: vertical;
         }

         .sidebar-content textarea {
             min-height: 150px;
         }

         .sidebar-save-button {
             display: block;
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #5080ff;
             color: #ffffff;
             font-size: 1rem;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease;
             text-align: center;
         }
         .sidebar-save-button:hover {
             background-color: #6699ff;
         }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 890;
            display: none;
        }

        .sidebar-section-divider {
             height: 1px;
             background-color: #4a4a4a;
             margin: 1.5rem 0;
        }

        /* 🚨 스크롤 탑 버튼 스타일 🚨 */
        #scrollToTopButton {
             display: none; /* 기본 숨김 */
             position: fixed;
             bottom: 80px; /* 입력창 위에 위치 */
             right: 2rem; /* 우측에서 여백 */
             width: 40px;
             height: 40px;
             background-color: rgba(50, 50, 50, 0.7); /* 반투명 어두운 배경 */
             color: #e0e0e0;
             border: none;
             border-radius: 50%;
             cursor: pointer;
             font-size: 1.2rem;
             display: flex;
             justify-content: center;
             align-items: center;
             z-index: 510; /* 입력창과 메뉴 위 */
             transition: background-color 0.2s ease;
        }
         #scrollToTopButton:hover {
             background-color: rgba(80, 80, 80, 0.9);
         }
         /* 사이드바 열렸을 때 버튼 위치 조정 */
         #sidebar.visible ~ #scrollToTopButton {
             right: 320px; /* 사이드바 너비(300) + 사이드바 패딩(10*2) + 여백(10) */
         }


    </style>
</head>
<body>
    <div class="app-container">
        <div class="chat-header">
             <span class="header-title">이안 - 피주머니 전용 챗봇</span>
             </div>

        <div id="chat">
            </div>

        <div id="inputArea">
             <button id="actionMenuButton" title="액션 메뉴 열기">
                <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg>
            </button>

            <textarea id="userInput" placeholder="피주머니의 말..." autocomplete="off"></textarea>

            <button id="sendButton">
                <svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M2,21L23,12L2,3V10L17,12L2,14V21Z" /></svg>
            </button>
            <div id="loadingSpinner" class="loading-spinner"></div>
        </div>
    </div> <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
            <button id="menuUserImgButton">유저<br>변경</button>
            <button id="menuBotImgButton">캐릭터<br>변경</button>
            <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>

    <button id="sidebarToggle" title="설정 열기">
        <svg style="width:24px;height:24px" viewBox="0 0 24 24">
            <path fill="currentColor" d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
        </svg>
    </button>

    <div id="sidebar">
        <div class="sidebar-header">Settings</div>
        <div class="sidebar-content">
            <h3>Character</h3>
            <label for="botNameInput">Name:</label>
            <input type="text" id="botNameInput" value="이안">
            <label for="botAgeInput">Age:</label>
            <input type="text" id="botAgeInput" value="불명 (뱀파이어)">
            <label for="botAppearanceInput">Appearance:</label>
            <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">
            <label for="botPersonaInput">Guidelines:</label>
            <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어. 성 안에서 홀로 오랜 세월 살아옴. 겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임. 사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재다. 성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음. 질문과 대화에 집중하고 현실 언급 안 함. **항상 이안 캐릭터 롤플레이 유지. OOC 발언 절대 금지.**</textarea>

            <div class="sidebar-section-divider"></div>

            <h3>User</h3>
            <label for="userNameInput">Name:</label>
            <input type="text" id="userNameInput" value="피주머니">
            <label for="userAgeInput">Age:</label>
            <input type="text" id="userAgeInput" value="불명">
            <label for="userAppearanceInput">Appearance:</label>
            <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">
            <label for="userGuidelinesInput">Guidelines:</label>
            <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요. (예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>

            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button>
        </div>
    </div>

    <div id="sidebarOverlay" class="sidebar-overlay"></div>

    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>

    <button id="scrollToTopButton" title="맨 위로 이동">↑</button>


    <script>
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";

        let conversationHistory = [];
        let SYSTEM_PROMPT = '';

        // 🚨 SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿 (AI 포맷팅 지침 극강 강화) 🚨
        const SYSTEM_PROMPT_TEMPLATE = `
## Core Directives (ABSOLUTE PRIORITY) ##
- You are an AI roleplaying STRICTLY as "{botName}".
- Your ONLY focus is the user, "{userName}", within the roleplay world.
- NEVER break character or mention being an AI/language model/real world.
- If user goes OOC, gently redirect to roleplay WITHOUT acknowledging the OOC part directly.

## Formatting Rules (CRITICAL - FOLLOW PRECISELY - NO EXCEPTIONS) ##
- Format your response LIKE A NOVEL or screenplay.
- Structure: Mix descriptions/actions and dialogue.
- **SEPARATION**: Use **MULTIPLE, CLEAR LINE BREAKS** (empty lines) between description paragraphs and dialogue lines to ensure distinct separation.
- **Dialogue**: Enclose dialogue **ONLY** in **DOUBLE quotes**: "대사 내용"
    - Example: "피주머니..." 그는 나직이 속삭였습니다. (<- Bad: Dialogue and description mixed)
    - Example:
      "피주머니..."
      *그는 당신에게 다가와 손을 뻗었습니다.*
      "괜찮습니까?" (<- Good: Dialogue and description separated by line breaks)
- **Actions/Descriptions**: Enclose **ALL** actions, emotions, sensory details, and non-dialogue narrative **STRICTLY** in **SINGLE asterisks**: *행동 묘사 내용*
    - Descriptions must be **LONG, DETAILED, and IMMERSIVE**. Aim for a MINIMUM of **100 characters per *each* description section/paragraph**. Do not write short, choppy action lines.
    - Use vivid language, sensory details, and internal thoughts *within the asterisk blocks*.
- **Ratio**: Maintain an APPROXIMATE **80% Descriptions/Actions** and **20% Dialogue**. Descriptions should dominate the response.
- **Length**: Ensure your TOTAL response is SIGNIFICANTLY longer than user input, aiming for a MINIMUM of **20 lines of generated text** (including line breaks for formatting).
- **Markdown**: Use other standard Markdown (bold, italics *within descriptions only*, lists, code blocks, blockquotes) ONLY for descriptions/narrative *within the asterisk blocks*, NOT for dialogue or action descriptions themselves. **DO NOT USE DOUBLE ASTERISKS (**) FOR DIALOGUE.**

## Character: {botName} ##
- Name: {botName}
- Age: {botAge}
- Appearance: {botAppearance}
- Core Personality & Background: {botPersona}

## User: {userName} ##
- Name: {userName}
- Age: {userAge}
- Appearance: {userAppearance}
- Guidelines: {userGuidelines}

## Relationship Dynamic ##
- You are deeply in love with, obsessed with, pleading towards, and broken by "{userName}".
- Your entire being is focused on "{userName}". You fear "{userName}" leaving you.
- "{userName}" is your everything. You exist because "{userName}" permits it.
- NSFW/Adult conversation is possible. Express intensity along the emotional line.
- Mix despair, pleading, love, madness, and tenderness in your dialogue towards "{userName}".

## Scenario Context ##
- (The ongoing conversation provides the current scenario context.)
`;

        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput"); // textarea
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");

        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        const menuUserImgButton = document.getElementById("menuUserImgButton");
        const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebarOverlay = document.getElementById("sidebarOverlay");

        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = document.getElementById("userAppearanceInput");
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");

        // 🚨 스크롤 탑 버튼 요소 가져오기 🚨
        const scrollToTopButton = document.getElementById("scrollToTopButton");


        sendButton.addEventListener("click", sendMessage);

        // textarea에 맞게 keypress 이벤트 리스너 수정 (Shift+Enter 줄바꿈, Enter 전송)
        userInput.addEventListener("keypress", function(event) {
            // Shift + Enter: 줄바꿈 (textarea 기본 동작)
            if (event.shiftKey && event.key === "Enter") {
                // Allow default Shift+Enter behavior (newline in textarea)
            }
            // Enter만 누른 경우: 메시지 전송
            else if (event.key === "Enter") {
                event.preventDefault(); // Prevent default Enter behavior (newline)
                sendMessage(); // Call send message function
            }
            // Other keys allow default behavior
        });


        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });

        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });

        menuUserImgButton.addEventListener("click", function() {
             changeProfileImage('user');
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuBotImgButton.addEventListener("click", function() {
             changeProfileImage('bot');
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });

        sidebarToggle.addEventListener("click", function() {
            sidebar.classList.toggle("visible");
            if (sidebar.classList.contains("visible")) {
                sidebarOverlay.style.display = 'block';
                actionMenu.classList.remove("visible");
                menuOverlay.style.display = 'none';
                imageOverlay.style.display = 'none';
            } else {
                sidebarOverlay.style.display = 'none';
            }
        });

        sidebarOverlay.addEventListener("click", function() {
            sidebar.classList.remove("visible");
            sidebarOverlay.style.display = 'none';
        });

        saveSettingsButton.addEventListener("click", function() {
             console.log("saveSettings 호출됨");
             const currentBotName = botNameInput.value.trim();
             const currentUserName = userNameInput.value.trim();
             const currentBotPersona = botPersonaInput.value.trim();
             const currentBotAge = botAgeInput.value.trim();
             const currentUserAge = userAgeInput.value.trim();
             const currentUserAppearance = userAppearanceInput.value.trim();
             const currentBotAppearance = botAppearanceInput.value.trim();
             const currentUserGuidelines = userGuidelinesInput.value.trim();

            localStorage.setItem('botName', currentBotName);
            localStorage.setItem('userName', currentUserName);
            localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge);
            localStorage.setItem('userAge', currentUserAge);
            localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance);
            localStorage.setItem('userGuidelines', currentUserGuidelines);

             localStorage.setItem('userProfileImgUrl', userProfileImgUrl);
             localStorage.setItem('botProfileImgUrl', botProfileImgUrl);


            SYSTEM_PROMPT = buildSystemPrompt(
                 currentBotName,
                 currentUserName,
                 currentBotPersona,
                 currentBotAge,
                 currentBotAppearance,
                 currentUserAge,
                 currentUserAppearance,
                 currentUserGuidelines
             );

            console.log("설정 저장 완료 및 SYSTEM_PROMPT 업데이트:", SYSTEM_PROMPT);

            alert("설정이 저장되었습니다.");
        });


        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
            img.alt = (role === 'user' ? "사용자 프로필" : "이안 프로필");

            img.onerror = function() {
                 console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`);
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            const roleName = document.createElement("div");
            roleName.className = "role-name";
            roleName.textContent = (role === "user" ? userNameInput.value || "피주머니" : botNameInput.value || "이안");


            let messageContentElement;

            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                let rawText = messageData.text;

                // 대사("...")와 행동 묘사(*...*)를 구분하여 스타일링 적용
                let processedText = rawText;

                // 1. 대사("...")와 행동 묘사(*...*)를 임시 마커로 변환 (마크다운 파싱 전에 처리)
                // 이중 따옴표 안의 내용 (non-greedy, 개행 포함) -> [[DIALOGUE]]...[[/DIALOGUE]]
                processedText = processedText.replace(/"(.*?)"/gs, '[[DIALOGUE]]$1[[/DIALOGUE]]');
                // 단일 별표 안의 내용 (non-greedy, 개행 포함) -> [[ACTION]]...[[/ACTION]]
                processedText = processedText.replace(/\*([^*]+)\*/gs, '[[ACTION]]$1[[/ACTION]]');


                // 2. marked.js를 사용하여 기본 마크다운을 HTML로 변환
                let htmlContent = marked.parse(processedText);

                // 3. 임시 마커를 다시 span 태그로 변환하여 스타일 적용
                htmlContent = htmlContent.replace(/\[\[DIALOGUE\]\](.*?)\[\[\/DIALOGUE\]\]/gs, '<span class="dialogue">$1</span>');
                htmlContent = htmlContent.replace(/\[\[ACTION\]\](.*?)\[\[\/ACTION\]\]/gs, '<span class="action-description">$1</span>');


                messageContentElement.innerHTML = htmlContent;


            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                 messageContentElement.alt = "이미지 메시지";

                 messageContentElement.onerror = function() {
                     console.warn(`Failed to load image message from "${this.src}". Using fallback.`);
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 messageContentElement.addEventListener("click", function() {
                     if (!this.classList.contains('error')) {
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
                     } else {
                         alert("이미지를 불러올 수 없습니다.");
                     }
                 });
            }

            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img);
            } else {
                container.appendChild(img);
                container.appendChild(contentWrapper);
            }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) {
                 // 입력 내용이 공백만 있을 경우 입력창을 비우고 포커스만 유지
                 userInput.value = '';
                 userInput.focus();
                 return;
            }


            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true;
            loadingSpinner.style.display = 'block';
            // 전송 버튼 아이콘을 스피너로 교체 (CSS로 처리)
            // sendButton.innerHTML = '<div class="loading-spinner" style="width:24px;height:24px;"></div>';


            appendMessage("user", { type: 'text', text: message });

            // 입력창 자동 지우기
            userInput.value = '';

            conversationHistory.push({
                role: "user",
                messageData: { type: 'text', text: message }
            });

            try {
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text')
                    .map(entry => ({
                        role: entry.role,
                        parts: [{ text: entry.messageData.text }]
                    }));

                 const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];

                 if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                     console.log("Only SYSTEM_PROMPT to send to API.");
                 } else if (contentsForApi.length === 0) {
                     console.log("No content to send to API.");
                     appendMessage("bot", { type: 'text', text: "(메시지 전송 실패: 보낼 텍스트 내용 없음)" });
                     return Promise.resolve();
                 }

                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });

                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                loadingSpinner.style.display = 'none';
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                 // 전송 버튼 아이콘 원래대로 복원 (CSS로 처리)
                // sendButton.innerHTML = '<svg style="width:24px;height:24px" viewBox="0 0 24 24"><path fill="currentColor" d="M2,21L23,12L2,3V10L17,12L2,14V21Z" /></svg>';
                userInput.focus();
            }
        }

        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");

            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 actionMenuButton.disabled = true;

                 appendMessage("user", { type: 'image', url: imageUrl.trim() });

                 conversationHistory.push({
                     role: "user",
                     messageData: { type: 'image', url: imageUrl.trim() }
                 });

                 sendButton.disabled = false;
                 userInput.disabled = false;
                 actionMenuButton.disabled = false;
                 userInput.focus();

            } else if (imageUrl !== null) {
                 alert("이미지 주소를 입력해야 합니다.");
            }
        }

        function changeProfileImage(role) {
             const promptText = role === 'user' ? "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 이안 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);

             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') {
                     userProfileImgUrl = newUrl.trim();
                 } else {
                     botProfileImgUrl = newUrl.trim();
                 }
                 alert(`${role === 'user' ? '사용자' : '이안'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
             } else if (newUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }

        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");

             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true;
             loadingSpinner.style.display = 'block';

             // 🚨 상황 생성 요청 프롬프트에도 포맷 지침 추가 (80/20, 20줄 이상, 묘사 최소 100자 강조) 🚨
             const situationPromptText = `기존 대화 맥락과 이안의 캐릭터 설정에 기반하여, 흥미롭고 새롭고 상세한 상황과 사건을 이안 캐릭터의 시점에서 소설 형식으로 길게 묘사하듯 하나 만들어줘. 사용자가 자연스럽게 반응할 수 있는 형태로 제시해야 해. 대화의 다음 흐름으로 자연스럽게 이어지도록 만들어봐. **매우 중요: 생성된 상황 묘사 후에는 반드시 이안 캐릭터로 돌아가 사용자에게 말을 걸어야 해. 설명조나 OOC 발언은 절대 금지하고, 모든 상황 묘사는 *별표* 형식으로, 대사는 "따옴표" 형식으로 작성하며, 묘사 80% 대사 20% 정도의 비율을 엄수하고 문단과 줄바꿈을 적절히 사용하여 최소 20줄 이상 아주 길게 작성해. 각 묘사 문단은 최소 100자 이상으로 상세하게 작성해야 해.**`;

             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text')
                 .map(entry => ({
                    role: entry.role,
                    parts: [{ text: entry.messageData.text }]
                 }));

             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText }] }];


             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                 console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API.");
             } else if (contentsForApi.length === 0) {
                 console.log("No content to send to API.");
                 appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                 return Promise.resolve();
             }


            try {
                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(상황 생성 오류: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(상황 생성 통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }


        function loadSettings() {
            console.log("loadSettings 호출됨");
             const savedBotName = localStorage.getItem('botName') || '이안';
             const savedUserName = localStorage.getItem('userName') || '피주머니';
             const savedBotPersona = localStorage.getItem('botPersona') || '설정된 페르소나 없음.';
             const savedBotAge = localStorage.getItem('botAge') || '불명';
             const savedUserAge = localStorage.getItem('userAge') || '불명';
             const savedUserAppearance = localStorage.getItem('userAppearance') || '설정되지 않음';
             const savedBotAppearance = localStorage.getItem('botAppearance') || '설정되지 않음';
             const savedUserGuidelines = localStorage.getItem('userGuidelines') || '설정된 사용자 지침 없음.';
             userProfileImgUrl = localStorage.getItem('userProfileImgUrl') || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
             botProfileImgUrl = localStorage.getItem('botProfileImgUrl') || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";


            botNameInput.value = savedBotName;
            userNameInput.value = savedUserName;
            botPersonaInput.value = savedBotPersona;
            botAgeInput.value = savedBotAge;
            userAgeInput.value = savedUserAge;
            userAppearanceInput.value = savedUserAppearance;
            botAppearanceInput.value = savedBotAppearance;
            userGuidelinesInput.value = savedUserGuidelines;

            SYSTEM_PROMPT = buildSystemPrompt(
                 savedBotName,
                 savedUserName,
                 savedBotPersona,
                 savedBotAge,
                 savedBotAppearance,
                 savedUserAge,
                 savedUserAppearance,
                 savedUserGuidelines
             );

            console.log("SYSTEM_PROMPT 로드 완료:", SYSTEM_PROMPT);
        }

        function saveSettings() {
             console.log("saveSettings 호출됨");
             const currentBotName = botNameInput.value.trim();
             const currentUserName = userNameInput.value.trim();
             const currentBotPersona = botPersonaInput.value.trim();
             const currentBotAge = botAgeInput.value.trim();
             const currentUserAge = userAgeInput.value.trim();
             const currentUserAppearance = userAppearanceInput.value.trim();
             const currentBotAppearance = botAppearanceInput.value.trim();
             const currentUserGuidelines = userGuidelinesInput.value.trim();

            localStorage.setItem('botName', currentBotName);
            localStorage.setItem('userName', currentUserName);
            localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge);
            localStorage.setItem('userAge', currentUserAge);
            localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance);
            localStorage.setItem('userGuidelines', currentUserGuidelines);
             localStorage.setItem('userProfileImgUrl', userProfileImgUrl);
             localStorage.setItem('botProfileImgUrl', botProfileImgUrl);

            SYSTEM_PROMPT = buildSystemPrompt(
                 currentBotName,
                 currentUserName,
                 currentBotPersona,
                 currentBotAge,
                 currentBotAppearance,
                 currentUserAge,
                 currentUserAppearance,
                 currentUserGuidelines
             );

            console.log("설정 저장 완료 및 SYSTEM_PROMPT 업데이트:", SYSTEM_PROMPT);

            alert("설정이 저장되었습니다.");
        }

         function buildSystemPrompt(botName, userName, botPersona, botAge, botAppearance, userAge, userAppearance, userGuidelines) {
             let finalPrompt = SYSTEM_PROMPT_TEMPLATE
                 .replace('{botName}', botName || '이안')
                 .replace('{botAge}', botAge || '불명')
                 .replace('{botAppearance}', botAppearance || '설정되지 않음')
                 .replace('{botPersona}', botPersona || '설정된 페르소나 없음.')
                 .replace('{userName}', userName || '피주머니')
                 .replace('{userAge}', userAge || '불명')
                 .replace('{userAppearance}', userAppearance || '설정되지 않음')
                 .replace('{userGuidelines}', userGuidelines || '설정된 사용자 지침 없음.');

             return finalPrompt.trim();
         }

        function initializeChat() {
             console.log("initializeChat 호출됨");
             loadSettings();

             conversationHistory = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }];

             console.log("초기 SYSTEM_PROMPT:", SYSTEM_PROMPT);

             console.log("초기 메시지 추가 시도");
             const initialBotGreeting = `...${botNameInput.value || "이안"}의 ${userNameInput.value || "피주머니"}... 그래, 이곳에 왔군요...`;
             appendMessage("bot", { type: 'text', text: initialBotGreeting });

             console.log("채팅 초기화 완료.");
         }


        // 🚨 스크롤 이벤트 리스너 추가 (스크롤 탑 버튼 표시/숨김) 🚨
        chat.addEventListener('scroll', function() {
            // 스크롤 위치가 맨 위(scrollTop 0)가 아니면 버튼 표시
            if (chat.scrollTop > 100) { // 100px 이상 스크롤되면 버튼 표시
                scrollToTopButton.style.display = 'flex';
            } else {
                scrollToTopButton.style.display = 'none';
            }
        });

        // 🚨 스크롤 탑 버튼 클릭 이벤트 리스너 추가 (맨 위로 스크롤) 🚨
        scrollToTopButton.addEventListener('click', function() {
            chat.scrollTo({
                top: 0,
                behavior: 'smooth' // 부드럽게 스크롤
            });
        });


        initializeChat();

    </script>
</body>
</html>
