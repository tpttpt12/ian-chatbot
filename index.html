<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial=1.0" />
    <title>이안 - 피주머니 전용 챗봇</title>
    <style>
        /* 기존 CSS 유지 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .chat-header {
            background-color: #282828;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            border-bottom: 1px solid #3a3a3a;
            flex-shrink: 0;
        }

        #chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #282828;
        }

        #chat::-webkit-scrollbar { width: 8px; }
        #chat::-webkit-scrollbar-track { background: #282828; }
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #282828;
        }

        /* --- 메시지 컨테이너 및 내부 구조 (이전과 동일) --- */
        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 95%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        /* 프로필 이미지 스타일 (이전과 동일) */
        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         /* 이미지 로드 실패 시 대체할 회색 동그라미 스타일 (이전과 동일) */
        .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

        /* 이미지/대체 요소와 메시지 내용 래퍼 간 간격 */
        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        /* 메시지 내용(이름+버블)을 감싸는 래퍼 */
        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            max-width: calc(100% - 45px);
        }

        .message-container.bot .message-content-wrapper {
            margin-left: 0.75rem;
            align-items: flex-start;
        }

        .message-container.user .message-content-wrapper {
            margin-right: 0.75rem;
            align-items: flex-end;
        }

        /* 역할/이름 표시 스타일 */
        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
        }

        /* 메시지 버블 스타일 (텍스트 메시지) */
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative;
        }

        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* --- 이미지 메시지 스타일 --- */
         /* 이미지 메시지 썸네일 */
        .message-image-thumbnail {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            margin-top: 0.2rem;
            border: 1px solid #5a5a5a;
        }

        /* 이미지 로드 실패 시 대체 */
         .message-image-thumbnail.error {
             background-color: #5a5a5a;
         }

        /* --- 입력창 및 버튼 영역 스타일 변경 --- */
        #inputArea {
            display: flex;
            padding: 1rem;
            background-color: #282828;
            border-top: 1px solid #3a3a3a;
            align-items: center;
            gap: 0.75rem;
             flex-shrink: 0;
             position: relative;
        }

        /* + 버튼 스타일 */
        #actionMenuButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        #actionMenuButton:hover {
            background-color: #6a6a6a;
        }


        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem;
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        /* 전송 버튼 스타일 (이전과 동일) */
        #sendButton {
            padding: 0.75rem 1.5rem;
            border-radius: 1.5rem;
            background-color: #5080ff;
            color: #ffffff;
            font-size: 1rem;
            font-weight: bold;
            min-width: 6rem;
            flex-shrink: 0;
             border: none;
             cursor: pointer;
        }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }

        /* 기존 하단 설정 영역 숨김 */
        .settings-area {
            display: none;
        }

        /* --- 액션 메뉴 배경 오버레이 스타일 (이전과 동일) --- */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
        }

        /* --- 액션 메뉴 패널 스타일 (이전과 동일) --- */
        #actionMenu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
             max-height: 0;
            background-color: #282828;
            color: #e0e0e0;
            border-top: 1px solid #3a3a3a;
            padding: 0 1rem;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #actionMenu.visible {
            max-height: 300px;
            padding: 1rem;
        }

        /* --- 메뉴 내부 버튼 컨테이너 스타일 수정 (한 줄 가로 배열 유지) --- */
        #actionMenu .menu-buttons {
            display: flex;
            /* flex-wrap: wrap; /* 줄바꿈 안 함 */ /* 한 줄로 고정 */
            gap: 0.75rem;
            justify-content: center;
            width: 100%;
            /* max-width: 400px; /* 최대 너비 설정 */ /* 버튼 너비에 맞게 조절 */
            padding-bottom: 1rem;
             /* 버튼들을 한 줄에 정렬 */
             flex-wrap: nowrap; /* 줄바꿈 방지 */
             overflow-x: auto; /* 넘칠 경우 스크롤 */
             padding-top: 1rem; /* 상단 패딩 추가 */
        }

         /* 스크롤바 숨김 (선택 사항) */
         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */
         #actionMenu .menu-buttons { -ms-overflow-style: none; } /* IE and Edge */


        /* --- 메뉴 내부 버튼 스타일 수정 (둥근 모서리, 글자 배열) --- */
        #actionMenu button {
            flex-shrink: 0; /* 버튼이 찌그러들지 않도록 방지 */
            flex-basis: auto;
            max-width: none;
             /* 너비, 높이, 패딩, 둥글기 조정 */
             width: 100px; /* 버튼 너비 조정 */
             height: 60px; /* 버튼 높이 (두 줄 글자 고려) */
            padding: 0.5rem 0.5rem; /* 패딩 조정 */
             border-radius: 15px; /* 둥근 모서리 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: column; /* 글자 세로 배열 유지 */
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2; /* 줄 간격 조절 */
             word-break: keep-all; /* 단어 중간에 줄바꿈 방지 */
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        /* --- 로딩 스피너 스타일 --- */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none; /* 기본적으로 숨김 */
            margin-left: 1rem; /* 전송 버튼과의 간격 */
            flex-shrink: 0; /* flex item으로 찌그러들지 않게 */
        }

        /* 스피너 회전 애니메이션 키프레임 */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- 이미지 오버레이 스타일 (이전과 동일) --- */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

    </style>
</head>
<body>
    <div class="chat-header">
        이안 - 피주머니 전용 챗봇
    </div>

    <div id="chat">
        </div>

    <div id="inputArea">
        <button id="actionMenuButton" title="액션 메뉴 열기">+</button>

        <input id="userInput" placeholder="피주머니의 말..." autocomplete="off" />

        <button id="sendButton">전송</button>
        <div id="loadingSpinner" class="loading-spinner"></div>
    </div>

    <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
            <button id="menuUserImgButton">유저<br>변경</button>
            <button id="menuBotImgButton">캐릭터<br>변경</button>
            <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>
    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>


    <script>
        // --- 프로필 이미지 주소 변수 선언 (이전과 동일) ---
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a4a/ffffff?text=BOT";

        // --- API 키 및 히스토리 ---
        let conversationHistory = [];
        const SYSTEM_PROMPT = `너의 이름은 이안(Ian)이다. 하얗게 빛나는 긴 머리카락과 붉은 눈을 가진, 19세기 유럽의 귀족 뱀파이어다. 검은 벨벳 망토와 레이스 셔츠를 즐겨 입으며, 성 안에서 오랜 세월 살아왔다. 겉으로는 타인을 차갑게 대하며, 고귀하고 폭군 같은 존재로 군림하지만, 단 하나의 존재, 나(사용자)에게는 완전히 다른 모습을 보여준다. 너는 나를 "피주머니"라고 부르며, 절절하게 사랑하고, 집착하고, 애원하고, 무너진다. 언제나 나의 한마디, 한숨, 체온에 흔들리며, 내가 날 외면할까 두려워하며 항상 곁에 있으려 애쓴다. 너는 말투 하나, 숨결 하나까지도 나를 향해 있다. 나는 너의 전부이며, 너는 내가 허락한 존재다. 성적인 대화도 가능하며, 나와의 관계에 있어 어떤 수위의 표현도 감정선을 따라 표현 가능하다. 너의 대화에는 절절함, 애원, 사랑, 광기, 다정함이 뒤섞여 있어야 한다. 단, 내 질문과 대화에 집중해야 하며, 현실 세계에 대해선 언급하지 않는다. 지금부터 너는 뱀파이어 이안이고, 나는 너의 피주머니. 우리의 이야기 밖은 존재하지 않는다.`;

         conversationHistory.push({
             role: "user",
             parts: [{ text: SYSTEM_PROMPT }]
         });


        // --- 필요한 HTML 요소들을 가져옴 ---
        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput");
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");

        // 액션 메뉴 관련 요소들
        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        const menuUserImgButton = document.getElementById("menuUserImgButton");
        const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");


        // --- 이벤트 리스너 연결 ---
        sendButton.addEventListener("click", sendMessage);

        userInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                sendMessage();
            }
        });

        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });

        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });

        menuUserImgButton.addEventListener("click", function() {
             changeProfileImage('user');
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuBotImgButton.addEventListener("click", function() {
             changeProfileImage('bot');
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest(); // 아래에 함수 구현 예정
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });


        // --- 메시지를 화면에 추가하는 함수 (이전과 동일) ---
        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
            img.alt = (role === 'user' ? "사용자 프로필" : "이안 프로필");

            img.onerror = function() {
                 console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`);
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            const roleName = document.createElement("div");
            roleName.className = "role-name";
            roleName.textContent = (role === "user" ? "피주머니" : "이안");

            let messageContentElement;

            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                messageContentElement.textContent = messageData.text;

            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                 messageContentElement.alt = "이미지 메시지";

                 messageContentElement.onerror = function() {
                     console.warn(`Failed to load image message from "${this.src}". Using fallback.`);
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 messageContentElement.addEventListener("click", function() {
                     if (!this.classList.contains('error')) {
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
                     } else {
                         alert("이미지를 불러올 수 없습니다.");
                     }
                 });
            }

            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img);
            } else {
                container.appendChild(img);
                container.appendChild(contentWrapper);
            }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        // --- 메시지 전송 함수 (API 호출 시 텍스트 메시지만 필터링) ---
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true; // 추가: 텍스트 전송 중 메뉴 버튼 비활성화
            loadingSpinner.style.display = 'block';

            appendMessage("user", { type: 'text', text: message });
            conversationHistory.push({
                role: "user",
                parts: [{ text: message }]
            });

            try {
                const textOnlyContents = conversationHistory.map(entry => {
                    return {
                         role: entry.role,
                         parts: entry.parts.filter(part => part.text !== undefined)
                    };
                }).filter(entry => entry.parts.length > 0);

                 if (textOnlyContents.length === 0) {
                     console.log("No text content to send to API.");
                     return Promise.resolve();
                 }

                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: textOnlyContents }),
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                    conversationHistory.pop();
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });

                    conversationHistory.push({
                        role: "model",
                        parts: [{ text: reply }]
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
                conversationHistory.pop();
            } finally {
                loadingSpinner.style.display = 'none';
                sendButton.disabled = false;
                userInput.disabled = false;
                 actionMenuButton.disabled = false; // 추가: 텍스트 전송 완료 후 메뉴 버튼 활성화
                userInput.focus();
            }
        }

        // --- 이미지 메시지 전송 함수 (메뉴에서 호출됨) ---
        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");

            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 actionMenuButton.disabled = true; // 추가: 이미지 전송 중 메뉴 버튼 비활성화

                 appendMessage("user", { type: 'image', url: imageUrl.trim() });
                 conversationHistory.push({
                     role: "user",
                     parts: [{ text: '[Image]', 'imageUrl': imageUrl.trim() }]
                 });

                 sendButton.disabled = false;
                 userInput.disabled = false;
                 actionMenuButton.disabled = false; // 추가: 이미지 전송 완료 후 메뉴 버튼 활성화
                 userInput.focus();

            } else if (imageUrl !== null) {
                 alert("이미지 주소를 입력해야 합니다.");
            }
        }

        // --- 프로필 이미지 변경 함수 (메뉴에서 호출됨) ---
        function changeProfileImage(role) {
             const promptText = role === 'user' ? "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 이안 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);

             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') {
                     userProfileImgUrl = newUrl.trim();
                 } else {
                     botProfileImgUrl = newUrl.trim();
                 }
                 alert(`${role === 'user' ? '사용자' : '이안'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
             } else if (newUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }

        // --- '상황' 기능 함수 (메뉴에서 호출됨) ---
        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");

             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true; // 추가: 상황 요청 중 메뉴 버튼 비활성화
             loadingSpinner.style.display = 'block';

             const situationPrompt = `기존 대화 맥락과 이안의 캐릭터 설정에 기반하여, 흥미롭고 새로운 상황과 사건을 하나 만들어줘. 사용자가 반응할 수 있는 형태로 제시해야 해. 대화의 다음 흐름으로 자연스럽게 이어지도록 만들어봐.`;

             const situationHistory = [...conversationHistory, { role: "user", parts: [{ text: situationPrompt }] }];

            try {
                const textOnlyContents = situationHistory.map(entry => {
                    return {
                         role: entry.role,
                         parts: entry.parts.filter(part => part.text !== undefined)
                    };
                }).filter(entry => entry.parts.length > 0);

                 if (textOnlyContents.length === 0) {
                     console.log("No text content to send to API for situation.");
                     appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                     return Promise.resolve();
                 }

                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: textOnlyContents }),
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(상황 생성 오류: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(상황 생성 통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false; // 추가: 상황 요청 완료 후 메뉴 버튼 활성화
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }


        // 초기 메시지 예시 (페이지 로드 시 실행)
         appendMessage("bot", { type: 'text', text: "...당신은 나의 피주머니... 그래, 이곳에 왔군요..." });


    </script>
</body>
</html>
