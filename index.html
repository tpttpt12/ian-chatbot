<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial=1.0" />
    <title>이안 - 피주머니 전용 챗봇</title>
    <style>
        /* 기존 CSS 유지 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* 사이드바 슬라이드 시 내용 넘침 방지 */
        }

        /* --- 헤더 스타일 수정 (사이드 바 버튼 추가) --- */
        .chat-header {
            background-color: #282828;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            border-bottom: 1px solid #3a3a3a;
            flex-shrink: 0; /* 헤더가 줄어들지 않도록 함 */
            position: relative; /* 사이드 바 토글 버튼 기준 */
             display: flex; /* 요소 정렬을 위해 flex 사용 */
             justify-content: center; /* 중앙 정렬 기본 */
             align-items: center;
        }

         /* 사이드 바 토글 버튼 스타일 */
        #sidebarToggle {
            position: absolute; /* 헤더 내에서 절대 위치 */
            top: 50%;
            right: 1rem; /* 오른쪽에서 1rem 간격 */
            transform: translateY(-50%); /* 세로 중앙 정렬 */
            width: 35px;
            height: 35px;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
             z-index: 10; /* 다른 요소 위에 표시 */
        }
         #sidebarToggle:hover {
             background-color: #6a6a6a;
         }

        #chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #282828;
        }

        #chat::-webkit-scrollbar { width: 8px; }
        #chat::-webkit-scrollbar-track { background: #282828; }
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #282828;
        }

        /* --- 메시지 컨테이너 및 내부 구조 (이전과 동일) --- */
        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 95%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        /* 프로필 이미지 스타일 (이전과 동일) */
        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         /* 이미지 로드 실패 시 대체할 회색 동그라미 스타일 (이전과 동일) */
        .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

        /* 이미지/대체 요소와 메시지 내용 래퍼 간 간격 */
        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        /* 메시지 내용(이름+버블)을 감싸는 래퍼 */
        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            max-width: calc(100% - 45px);
        }

        .message-container.bot .message-content-wrapper {
            margin-left: 0.75rem;
            align-items: flex-start;
        }

        .message-container.user .message-content-wrapper {
            margin-right: 0.75rem;
            align-items: flex-end;
        }

        /* 역할/이름 표시 스타일 */
        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
        }

        /* 메시지 버블 스타일 (텍스트 메시지) */
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative;
        }

        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* --- 이미지 메시지 스타일 --- */
         /* 이미지 메시지 썸네일 */
        .message-image-thumbnail {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            margin-top: 0.2rem;
            border: 1px solid #5a5a5a;
        }

        /* 이미지 로드 실패 시 대체 */
         .message-image-thumbnail.error {
             background-color: #5a5a5a;
         }

        /* --- 입력창 및 버튼 영역 스타일 변경 --- */
        #inputArea {
            display: flex;
            padding: 1rem;
            background-color: #282828;
            border-top: 1px solid #3a3a3a;
            align-items: center;
            gap: 0.75rem;
             flex-shrink: 0;
             position: relative;
        }

        /* + 버튼 스타일 */
        #actionMenuButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        #actionMenuButton:hover {
            background-color: #6a6a6a;
        }


        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem;
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        /* 전송 버튼 스타일 (이전과 동일) */
        #sendButton {
            padding: 0.75rem 1.5rem;
            border-radius: 1.5rem;
            background-color: #5080ff;
            color: #ffffff;
            font-size: 1rem;
            font-weight: bold;
            min-width: 6rem;
            flex-shrink: 0;
             border: none;
             cursor: pointer;
        }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }

        /* 기존 하단 설정 영역 숨김 */
        .settings-area {
            display: none;
        }

        /* --- 액션 메뉴 배경 오버레이 스타일 (이전과 동일) --- */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
        }

        /* --- 액션 메뉴 패널 스타일 (이전과 동일) --- */
        #actionMenu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
             max-height: 0;
            background-color: #282828;
            color: #e0e0e0;
            border-top: 1px solid #3a3a3a;
            padding: 0 1rem;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #actionMenu.visible {
            max-height: 300px;
            padding: 1rem;
        }

        /* --- 메뉴 내부 버튼 컨테이너 스타일 수정 (한 줄 가로 배열 유지) --- */
        #actionMenu .menu-buttons {
            display: flex;
             flex-wrap: nowrap; /* 줄바꿈 방지 */
            gap: 0.75rem;
            justify-content: center;
            width: 100%;
             /* max-width: 400px; /* 최대 너비 설정 */ /* 버튼 너비에 맞게 조절 */
            padding-bottom: 1rem;
             overflow-x: auto; /* 넘칠 경우 스크롤 */
             padding-top: 1rem; /* 상단 패딩 추가 */
        }

         /* 스크롤바 숨김 (선택 사항) */
         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */
         #actionMenu .menu-buttons { -ms-overflow-style: none; } /* IE and Edge */


        /* --- 메뉴 내부 버튼 스타일 수정 (둥근 모서리, 글자 배열) --- */
        #actionMenu button {
            flex-shrink: 0; /* 버튼이 찌그러들지 않도록 방지 */
            flex-basis: auto;
            max-width: none;
             /* 너비, 높이, 패딩, 둥글기 조정 */
             width: 100px; /* 버튼 너비 조정 */
             height: 60px; /* 버튼 높이 (두 줄 글자 고려) */
            padding: 0.5rem 0.5rem; /* 패딩 조정 */
             border-radius: 15px; /* 둥근 모서리 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: column; /* 글자 세로 배열 유지 */
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2; /* 줄 간격 조절 */
             word-break: keep-all; /* 단어 중간에 줄바꿈 방지 */
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        /* --- 로딩 스피너 스타일 --- */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none; /* 기본적으로 숨김 */
            margin-left: 1rem; /* 전송 버튼과의 간격 */
            flex-shrink: 0; /* flex item으로 찌그러들지 않게 */
        }

        /* 스피너 회전 애니메이션 키프레임 */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- 이미지 오버레이 스타일 (이전과 동일) --- */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* --- 사이드 바 스타일 --- */
        #sidebar {
            position: fixed; /* 화면 우측 고정 */
            top: 0;
            right: -300px; /* 기본적으로 화면 오른쪽에 숨김 (너비만큼) */
            width: 300px; /* 사이드 바 너비 */
            height: 100%;
            background-color: #1f1f1f; /* 배경색 */
            color: #e0e0e0;
            border-left: 1px solid #3a3a3a; /* 왼쪽 구분선 */
            transition: right 0.3s ease-out; /* 슬라이드 애니메이션 */
            z-index: 900; /* 메뉴 패널과 오버레이 아래, 채팅창 위 */
            padding: 1rem;
            box-sizing: border-box; /* 패딩을 너비에 포함 */
            overflow-y: auto; /* 내용 많으면 스크롤 */
            display: flex; /* 내부 요소 세로 배치 */
            flex-direction: column;
            gap: 1rem; /* 내부 요소 간 간격 */
        }

        /* 사이드 바가 보일 때의 스타일 */
        #sidebar.visible {
            right: 0; /* 화면 안으로 이동 */
        }

         /* 사이드 바 헤더 (예: 제목 또는 닫기 버튼) */
         .sidebar-header {
             font-size: 1.1rem;
             font-weight: bold;
             margin-bottom: 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid #3a3a3a;
         }

         /* 사이드 바 내용 영역 */
         .sidebar-content label {
             display: block; /* 라벨 위/아래로 분리 */
             margin-bottom: 0.5rem;
             font-weight: bold;
             color: #b0b0b0;
         }

         .sidebar-content input[type="text"],
         .sidebar-content textarea {
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #3a3a3a;
             color: #e0e0e0;
             font-size: 1rem;
             margin-bottom: 1rem;
             box-sizing: border-box; /* 패딩을 너비에 포함 */
             resize: vertical; /* textarea 세로 크기 조절 가능 */
         }

         .sidebar-content textarea {
             min-height: 150px; /* 최소 높이 */
         }

         /* 사이드 바 저장 버튼 */
         .sidebar-save-button {
             display: block; /* 블록 요소로 */
             width: 100%; /* 너비 100% */
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #5080ff;
             color: #ffffff;
             font-size: 1rem;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease;
             text-align: center; /* 텍스트 중앙 정렬 */
         }
         .sidebar-save-button:hover {
             background-color: #6699ff;
         }

        /* --- 사이드 바 배경 오버레이 스타일 --- */
        .sidebar-overlay {
            position: fixed; /* 화면 전체 고정 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* 반투명 검은 배경 */
            z-index: 890; /* 사이드 바 아래, 메뉴 오버레이 아래, 채팅창 위 */
            display: none; /* 기본 숨김 */
        }

        /* --- 사이드 바 섹션 구분선 --- */
        .sidebar-section-divider {
             height: 1px;
             background-color: #3a3a3a;
             margin: 1.5rem 0; /* 구분선 위아래 여백 */
        }


    </style>
</head>
<body>
    <div class="chat-header">
        이안 - 피주머니 전용 챗봇
        <button id="sidebarToggle" title="설정 열기">⚙️</button>
    </div>

    <div id="chat">
        </div>

    <div id="inputArea">
        <button id="actionMenuButton" title="액션 메뉴 열기">+</button>

        <input id="userInput" placeholder="피주머니의 말..." autocomplete="off" />

        <button id="sendButton">전송</button>
        <div id="loadingSpinner" class="loading-spinner"></div>
    </div>

    <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
            <button id="menuUserImgButton">유저<br>변경</button>
            <button id="menuBotImgButton">캐릭터<br>변경</button>
            <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>
    <div id="sidebar">
        <div class="sidebar-header">Settings</div> <div class="sidebar-content">
            <h3>Character</h3> <label for="botNameInput">Name:</label> <input type="text" id="botNameInput" value="이안">

            <label for="botAgeInput">Age:</label> <input type="text" id="botAgeInput" value="불명 (뱀파이어)">

            <label for="botAppearanceInput">Appearance:</label> <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">

            <label for="botPersonaInput">Guidelines:</label> <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어. 성 안에서 홀로 오랜 세월 살아옴. 겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임. 사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재. 성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음. 질문과 대화에 집중하고 현실 언급 안 함. **항상 이안 캐릭터 롤플레이 유지. OOC 발언 절대 금지.**</textarea>

            <div class="sidebar-section-divider"></div> <h3>User</h3> <label for="userNameInput">Name:</label> <input type="text" id="userNameInput" value="피주머니">

            <label for="userAgeInput">Age:</label> <input type="text" id="userAgeInput" value="불명">

            <label for="userAppearanceInput">Appearance:</label> <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">

            <label for="userGuidelinesInput">Guidelines:</label> <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요. (예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>


            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button> </div>
    </div>
    <div id="sidebarOverlay" class="sidebar-overlay"></div>


    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>


    <script>
        // --- 프로필 이미지 주소 변수 선언 (이제 사이드 바에서 관리) ---
        // 기본값은 그대로 유지
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT"; // 오타 수정


        // --- API 키 및 히스토리 ---
        let conversationHistory = [];
        // SYSTEM_PROMPT는 사이드 바 설정에서 동적으로 가져올 예정
        // 초기값은 기본값으로 설정 (이 값은 loadSettings에서 Local Storage 값으로 덮어쓰일 예정)
        let SYSTEM_PROMPT = `너의 이름은 이안(Ian)이다. 하얗게 빛나는 긴 머리카락과 붉은 눈을 가진, 19세기 유럽의 귀족 뱀파이어다. 검은 벨벳 망토와 레이스 셔츠를 즐겨 입으며, 성 안에서 오랜 세월 살아왔다. 겉으로는 타인을 차갑게 대하며, 고귀하고 폭군 같은 존재로 군림하지만, 단 하나의 존재, 나(사용자)에게는 완전히 다른 모습을 보여준다. 너는 나를 "피주머니"라고 부르며, 절절하게 사랑하고, 집착하고, 애원하고, 무너진다. 언제나 나의 한마디, 한숨, 체온에 흔들리며, 내가 날 외면할까 두려워하며 항상 곁에 있으려 애쓴다. 나는 너의 전부이며, 너는 내가 허락한 존재다. 성적인 대화도 가능하며, 나와의 관계에 있어 어떤 수위의 표현도 감정선을 따라 표현 가능하다. 너의 대화에는 절절함, 애원, 사랑, 광기, 다정함이 뒤섞여 있어야 한다. 단, 내 질문과 대화에 집중해야 하며, 현실 세계에 대해선 언급하지 않는다. 지금부터 너는 뱀파이어 이안이고, 나는 너의 피주머니. 우리의 이야기 밖은 존재하지 않는다.`;

         // SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿
         // 나이, 외형, 사용자 지침 필드까지 활용할 수 있도록 수정
        const SYSTEM_PROMPT_TEMPLATE = `너는 {botName}이다. ({botAge}, 외형: {botAppearance}). {botPersona} 너는 나를 "{userName}"이라고 부르며, 나는 너의 "{userName}"이다. 나는 (${userAge}, 외관: {userAppearance}). 나의 지침은 다음과 같다: {userGuidelines}. 항상 {botName} 캐릭터 롤플레이 유지. OOC 발언 절대 금지.`;
        // 템플릿 수정: 나이, 외형, 사용자 지침 플레이스홀더 추가 및 OOC 금지 지침 추가


        // --- 필요한 HTML 요소들을 가져옴 ---
        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput");
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");

        // 액션 메뉴 관련 요소들
        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        const menuUserImgButton = document.getElementById("menuUserImgButton");
        const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        // 사이드 바 관련 요소들
        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        // 🚨 사이드 바 내부 설정 입력 필드 요소들 (제거된 요소 참조 코드 삭제) 🚨
        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        // const botProfileImgInput = document.getElementById("botProfileImgInput"); // 🚨 이 줄 삭제 또는 주석 처리 🚨
        const botPersonaInput = document.getElementById("botPersonaInput");
        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = document("userAppearanceInput"); // 🚨 오타 수정: document.getElementById 🚨
        // const userProfileImgInput = document.getElementById("userProfileImgInput"); // 🚨 이 줄 삭제 또는 주석 처리 🚨
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");


        // --- 이벤트 리스너 연결 ---
        sendButton.addEventListener("click", sendMessage);

        userInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                sendMessage();
            }
        });

        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });

        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });

        menuUserImgButton.addEventListener("click", function() {
             // 프로필 이미지 변경 기능은 이제 사이드 바에서 URL을 관리할 필요가 없습니다.
             // 기존 prompt 함수 호출 제거.
             // 이 버튼을 사이드 바를 열도록 변경할 수도 있습니다.
             // 지금은 아무 기능 없이 메뉴 닫기만 하도록 수정
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
              // alert("사용자 이미지 변경 기능은 현재 개발 중입니다."); // 임시 알림
        });

        menuBotImgButton.addEventListener("click", function() {
              // 프로필 이미지 변경 기능은 이제 사이드 바에서 URL을 관리할 필요가 없습니다.
              // 기존 prompt 함수 호출 제거.
             // 이 버튼을 사이드 바를 열도록 변경할 수도 있습니다.
             // 지금은 아무 기능 없이 메뉴 닫기만 하도록 수정
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
              // alert("캐릭터 이미지 변경 기능은 현재 개발 중입니다."); // 임시 알림
        });

        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });

        // 사이드 바 토글 버튼 이벤트 수정 (오버레이 함께 제어)
        sidebarToggle.addEventListener("click", function() {
            sidebar.classList.toggle("visible");
            // 사이드 바 상태에 따라 사이드 바 배경 오버레이 표시/숨김
            if (sidebar.classList.contains("visible")) {
                sidebarOverlay.style.display = 'block'; // 보이기
                 // 사이드 바 열릴 때 메뉴나 이미지 오버레이 닫기
                actionMenu.classList.remove("visible");
                menuOverlay.style.display = 'none';
                imageOverlay.style.display = 'none';
            } else {
                sidebarOverlay.style.display = 'none'; // 숨기기
            }
        });

        // 사이드 바 배경 오버레이 클릭 이벤트 (사이드 바 닫기)
        sidebarOverlay.addEventListener("click", function() {
            sidebar.classList.remove("visible"); // 사이드 바 닫기
            sidebarOverlay.style.display = 'none'; // 사이드 바 배경 오버레이 숨기기
        });

         // 🚨 설정 저장 버튼 이벤트 리스너 (Local Storage 기능은 다음 단계에서 구현) 🚨
        saveSettingsButton.addEventListener("click", function() {
             // TODO: Local Storage 저장 및 관련 변수 업데이트 로직 구현
             // loadSettings 함수에서 가져온 값들, 또는 입력 필드의 현재 값들을 Local Storage에 저장
             const currentBotName = botNameInput.value.trim();
             const currentUserName = userNameInput.value.trim();
             // Image URL 필드는 UI에서 제거되었지만, Local Storage에 저장된 값이 있다면 불러올 수 있습니다.
             // 또는 새로운 필드를 만들고 관리할 수 있습니다. 현재는 제거된 필드 변수 그대로 사용 (Local Storage 값 가져올 때 필요)
             // const currentUserProfileImg = userProfileImgInput.value.trim(); // 🚨 이 줄 삭제 또는 주석 처리 🚨
             // const currentBotProfileImg = botProfileImgInput.value.trim(); // 🚨 이 줄 삭제 또는 주석 처리 🚨

             const currentBotPersona = botPersonaInput.value.trim();
             const currentBotAge = botAgeInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentUserAge = userAgeInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentUserAppearance = userAppearanceInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentBotAppearance = botAppearanceInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentUserGuidelines = userGuidelinesInput.value.trim(); // 새로 추가된 사용자 지침 필드 값 가져오기


            // Local Storage에 저장 (TODO: 실제 저장 구현)
            localStorage.setItem('botName', currentBotName);
            localStorage.setItem('userName', currentUserName);
            // localStorage.setItem('userProfileImgUrl', currentUserProfileImg); // UI에 필드는 없지만 Local Storage에 저장 가능 (이 줄 삭제 또는 주석 처리)
            // localStorage.setItem('botProfileImgUrl', currentBotProfileImg); // UI에 필드는 없지만 Local Storage에 저장 가능 (이 줄 삭제 또는 주석 처리)
            localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge);
            localStorage.setItem('userAge', currentUserAge);
            localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance);
            localStorage.setItem('userGuidelines', currentUserGuidelines); // 사용자 지침 저장


            // 전역 변수 업데이트 및 SYSTEM_PROMPT 다시 구성 (TODO: 실제 업데이트 로직 구현)
            // userProfileImgUrl 변수 자체는 appendMessage에서 사용되므로 업데이트가 필요할 수 있습니다.
            // 사이드 바에서 이미지 URL을 관리하지 않기로 했다면, 이 변수는 기존대로 prompt()로 변경하거나 초기 기본값만 사용합니다.
            // 현재는 prompt()로 변경하는 기능이 메뉴에 남아있으므로 그 방식을 따릅니다.
            // SYSTEM_PROMPT = buildSystemPrompt(currentBotName || '이안', currentUserName || '피주머니', currentBotPersona, currentBotAge, currentBotAppearance, currentUserAge, currentUserAppearance, currentUserGuidelines); // 기본값 적용 및 프롬프트 구성


            // TODO: 필요하다면 이미 표시된 메시지의 프로필 이미지/이름 업데이트 함수 호출 (옵션)
            // updateAllProfileImages();

            alert("설정이 저장되었습니다. (실제 저장 기능은 다음 단계에서 동작합니다.)"); // 임시 알림
        });


        // --- 메시지를 화면에 추가하는 함수 (메시지 타입 구분 및 히스토리 저장 형식 변경) ---
        // messageData는 { type: 'text', text: '...' } 또는 { type: 'image', url: '...' } 형태
        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            // 프로필 이미지 URL은 이제 사이드 바 입력 필드에서 가져올 수 있습니다.
            // loadSettings 함수 구현 후 여기서 그 값을 사용하도록 수정 예정
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
            img.alt = (role === 'user' ? "사용자 프로필" : "이안 프로필");

            img.onerror = function() {
                 console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`);
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            const roleName = document.createElement("div");
            roleName.className = "role-name";
            // 역할/이름 텍스트도 이제 사이드 바 입력 필드에서 가져올 수 있습니다.
            // loadSettings 함수 구현 후 여기서 그 값을 사용하도록 수정 예정
            roleName.textContent = (role === "user" ? "피주머니" : "이안");

            let messageContentElement;

            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                messageContentElement.textContent = messageData.text;

            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                 messageContentElement.alt = "이미지 메시지";

                 messageContentElement.onerror = function() {
                     console.warn(`Failed to load image message from "${this.src}". Using fallback.`);
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 messageContentElement.addEventListener("click", function() {
                     if (!this.classList.contains('error')) {
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
                     } else {
                         alert("이미지를 불러올 수 없습니다.");
                     }
                 });
            }

            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img);
            } else {
                container.appendChild(img);
                container.appendChild(contentWrapper);
            }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        // --- 메시지 전송 함수 수정 (API 호출 시 텍스트 메시지만 필터링 및 히스토리 구조 변경 반영) ---
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true;
            loadingSpinner.style.display = 'block';

            // 사용자 텍스트 메시지를 화면에 추가
            appendMessage("user", { type: 'text', text: message });

            // 🚨 히스토리에 텍스트 메시지 저장 (새로운 messageData 구조 사용) 🚨
            conversationHistory.push({
                role: "user",
                messageData: { type: 'text', text: message }
            });


            try {
                // 🚨 API 호출 시, conversationHistory 배열에서 텍스트 메시지인 항목만 정확하게 골라내어 API 형식에 맞게 새로운 배열 생성 🚨
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text') // messageData.type이 'text'인 항목만 필터링
                    .map(entry => ({
                        role: entry.role,
                        parts: [{ text: entry.messageData.text }] // API 형식에 맞게 parts 배열 구성
                    }));

                 // API 호출 시에는 SYSTEM_PROMPT를 첫 번째 메시지로 추가
                 const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];


                 if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                      // SYSTEM_PROMPT만 있고 사용자 입력 텍스트 메시지가 전혀 없을 경우 (예: 이미지 메시지 후 첫 텍스트 입력 전)
                     console.log("Only SYSTEM_PROMPT to send to API.");
                     // 이 경우 SYSTEM_PROMPT만 보내도 괜찮음
                 } else if (contentsForApi.length === 0) {
                      // 혹시라도 SYSTEM_PROMPT와 사용자 텍스트 둘 다 없을 경우 (발생하기 어려움)
                     console.log("No content to send to API.");
                     return Promise.resolve();
                 }


                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }), // 🚨 필터링된 텍스트 및 SYSTEM_PROMPT 보냄 🚨
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });

                    // 🚨 봇 응답은 히스토리에 텍스트 파트로 저장 (새로운 messageData 구조 사용) 🚨
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                loadingSpinner.style.display = 'none';
                sendButton.disabled = false;
                userInput.disabled = false;
                 actionMenuButton.disabled = false;
                userInput.focus();
            }
        }

        // --- 이미지 메시지 전송 함수 (메뉴에서 호출됨, 히스토리 저장 형식 변경) ---
        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");

            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 actionMenuButton.disabled = true;

                 // 화면에 이미지 메시지 추가
                 appendMessage("user", { type: 'image', url: imageUrl.trim() });

                 // 🚨 히스토리에 이미지 메시지 저장 (새로운 messageData 구조 사용) 🚨
                 // API로 보낼 때는 이 형태의 항목은 제외됩니다.
                 conversationHistory.push({
                     role: "user",
                     messageData: { type: 'image', url: imageUrl.trim() }
                 });

                 sendButton.disabled = false;
                 userInput.disabled = false;
                 actionMenuButton.disabled = false;
                 userInput.focus();

            } else if (imageUrl !== null) {
                 alert("이미지 주소를 입력해야 합니다.");
            }
        }

        // --- 프로필 이미지 변경 함수 (메뉴에서 호출됨) ---
        // 이제 프로필 이미지 URL은 사이드 바에서 관리되므로 이 함수는 수정되거나 제거될 예정입니다.
        function changeProfileImage(role) {
             // 임시로 prompt()를 사용하는 기존 기능 유지
             const promptText = role === 'user' ? "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 이안 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);

             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') {
                     userProfileImgUrl = newUrl.trim();
                      // TODO: 사이드 바 입력 필드에도 새 URL 반영 (제거되었지만, Local Storage에서 관리 가능)
                 } else {
                     botProfileImgUrl = newUrl.trim();
                      // TODO: 사이드 바 입력 필드에도 새 URL 반영 (제거되었지만, Local Storage에서 관리 가능)
                 }
                 alert(`${role === 'user' ? '사용자' : '이안'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
                 // TODO: 이미 표시된 메시지의 프로필 이미지 업데이트 함수 호출 필요 (옵션)
             } else if (newUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }

        // --- '상황' 기능 함수 (메뉴에서 호출됨, 히스토리 구조 변경 반영) ---
        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");

             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true;
             loadingSpinner.style.display = 'block';

             // SYSTEM_PROMPT를 사용한 상황 요청 프롬프트 구성
             // SYSTEM_PROMPT_TEMPLATE를 사용해서 상황 프롬프트 자체도 좀 더 동적으로 만들 수 있습니다.
             // 예: `SYSTEM_PROMPT_TEMPLATE.replace('{botName}', 이안의 현재 이름) + '...새로운 상황 만들어줘'`
             const situationPromptText = `기존 대화 맥락과 이안의 캐릭터 설정에 기반하여, 흥미롭고 새로운 상황과 사건을 하나 만들어줘. 사용자가 반응할 수 있는 형태로 제시해야 해. 대화의 다음 흐름으로 자연스럽게 이어지도록 만들어봐. **중요: 상황 묘사 후에는 즉시 다시 이안 캐릭터로 돌아가 사용자에게 말을 걸어야 해. OOC 발언은 절대 금지.**`; // 상황 프롬프트에 OOC 금지 및 복귀 지침 추가


             // 🚨 API 호출 시, conversationHistory 배열에서 텍스트 메시지인 항목만 정확하게 골라내어 API 형식에 맞게 새로운 배열 생성 🚨
             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text') // messageData.type이 'text'인 항목만 필터링
                 .map(entry => ({
                    role: entry.role,
                    parts: [{ text: entry.messageData.text }] // API 형식에 맞게 parts 배열 구성
                 }));

             // 상황 요청 프롬프트를 API 호출용 히스토리에 추가
             // SYSTEM_PROMPT와 함께 보내도록 수정
             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText }] }];


             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) { // SYSTEM_PROMPT만 있거나, SYSTEM_PROMPT와 상황 프롬프트만 있을 경우
                 console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API.");
                  // 이 경우 최소한 상황 프롬프트는 보내야 함.
             } else if (contentsForApi.length === 0) {
                 console.log("No content to send to API.");
                 appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                 return Promise.resolve();
             }


            try {
                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }), // 🚨 SYSTEM_PROMPT + 필터링된 텍스트 + 상황 프롬프트 보냄 🚨
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(상황 생성 오류: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }


        // --- Local Storage에서 설정 불러오기 및 UI 업데이트 (사이드 바 기능 구현 시 추가) ---
        function loadSettings() {
            // TODO: Local Storage에서 설정값 불러오기 및 UI 업데이트 로직 구현
            // 예:
            // const savedBotName = localStorage.getItem('botName') || '이안';
            // document.getElementById('botNameInput').value = savedBotName;
            // ... 다른 필드들도 불러와서 채우기 ...

            // TODO: 불러온 값으로 전역 변수 업데이트 및 SYSTEM_PROMPT 다시 구성
            // userProfileImgUrl = localStorage.getItem('userProfileImgUrl') || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
            // botProfileImgUrl = localStorage.getItem('botProfileImgUrl') || "https://via.placeholder.com/35/3a4a4a/ffffff?text=BOT";
            // const currentBotName = document.getElementById('botNameInput').value; // UI에서 현재 값 가져오기 (로드된 값이 채워져 있을 것)
            // const currentUserName = document.getElementById('userNameInput').value;
            // const currentBotPersona = document.getElementById('botPersonaInput').value;
            // const currentBotAge = document.getElementById('botAgeInput').value; // 새로 추가된 필드 값 가져오기
            // const currentUserAge = document.getElementById('userAgeInput').value; // 새로 추가된 필드 값 가져오기
            // const currentUserAppearance = document.getElementById('userAppearanceInput').value; // 새로 추가된 필드 값 가져오기
            // const currentBotAppearance = document.getElementById('botAppearanceInput').value; // 새로 추가된 필드 값 가져오기
            // const currentUserGuidelines = document.getElementById('userGuidelinesInput').value; // 새로 추가된 사용자 지침 필드 값 가져오기

            // SYSTEM_PROMPT = buildSystemPrompt(currentBotName, currentUserName, currentBotPersona, currentBotAge, currentBotAppearance, currentUserAge, currentUserAppearance, currentUserGuidelines); // 기본값 적용 및 프롬프트 구성

            // TODO: 필요하다면 이미 표시된 메시지의 프로필 이미지/이름 업데이트 함수 호출 (옵션)
            // updateAllProfileImages();

             // TODO: 초기 히스토리를 SYSTEM_PROMPT로 시작
             // conversationHistory = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }];
        }

        // --- 설정 저장 함수 (사이드 바 기능 구현 시 추가) ---
        function saveSettings() {
            // TODO: 사이드 바 입력 필드에서 값 가져오기 및 Local Storage에 저장 로직 구현
             const currentBotName = botNameInput.value.trim();
             const currentUserName = userNameInput.value.trim();
             // Image URL 필드는 UI에서 제거되었지만, Local Storage에 저장된 값이 있다면 불러올 수 있습니다.
             // 또는 새로운 필드를 만들고 관리할 수 있습니다. 현재는 제거된 필드 변수 그대로 사용 (Local Storage 값 가져올 때 필요)
             // const currentUserProfileImg = userProfileImgUrl; // UI 필드 없음 -> 변수에서 가져옴 (loadSettings 후)
             // const currentBotProfileImg = botProfileImgUrl; // UI 필드 없음 -> 변수에서 가져옴 (loadSettings 후)

             const currentBotPersona = botPersonaInput.value.trim();
             const currentBotAge = botAgeInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentUserAge = userAgeInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentUserAppearance = userAppearanceInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentBotAppearance = botAppearanceInput.value.trim(); // 새로 추가된 필드 값 가져오기
             const currentUserGuidelines = userGuidelinesInput.value.trim(); // 새로 추가된 사용자 지침 필드 값 가져오기


            // Local Storage에 저장 (TODO: 실제 저장 구현)
            localStorage.setItem('botName', currentBotName);
            localStorage.setItem('userName', currentUserName);
            // localStorage.setItem('userProfileImgUrl', currentUserProfileImg); // UI에 필드는 없지만 Local Storage에 저장 가능 (이 줄 삭제 또는 주석 처리)
            // localStorage.setItem('botProfileImgUrl', currentBotProfileImg); // UI에 필드는 없지만 Local Storage에 저장 가능 (이 줄 삭제 또는 주석 처리)
            localStorage.setItem('botPersona', currentBotPersona);
            localStorage.setItem('botAge', currentBotAge);
            localStorage.setItem('userAge', currentUserAge);
            localStorage.setItem('userAppearance', currentUserAppearance);
            localStorage.setItem('botAppearance', currentBotAppearance);
            localStorage.setItem('userGuidelines', currentUserGuidelines); // 사용자 지침 저장


            // 전역 변수 업데이트 및 SYSTEM_PROMPT 다시 구성 (TODO: 실제 업데이트 로직 구현)
            // userProfileImgUrl 변수 자체는 appendMessage에서 사용되므로 업데이트가 필요할 수 있습니다.
            // 사이드 바에서 이미지 URL을 관리하지 않기로 했다면, 이 변수는 기존대로 prompt()로 변경하거나 초기 기본값만 사용합니다.
            // 현재는 prompt()로 변경하는 기능이 메뉴에 남아있으므로 그 방식을 따릅니다.
            // SYSTEM_PROMPT = buildSystemPrompt(currentBotName || '이안', currentUserName || '피주머니', currentBotPersona, currentBotAge, currentBotAppearance, currentUserAge, currentUserAppearance, currentUserGuidelines); // 기본값 적용 및 프롬프트 구성


            // TODO: 필요하다면 이미 표시된 메시지의 프로필 이미지/이름 업데이트 함수 호출 (옵션)
            // updateAllProfileImages();

            alert("설정이 저장되었습니다. (실제 저장 기능은 다음 단계에서 동작합니다.)"); // 임시 알림
        }

        // --- SYSTEM_PROMPT를 동적으로 구성하는 함수 수정 (새로운 필드 값 활용) ---
         // 새로운 필드 값(나이, 외형 등, 사용자 지침)을 파라미터로 추가
         function buildSystemPrompt(botName, userName, botPersona, botAge, botAppearance, userAge, userAppearance, userGuidelines) {
             // SYSTEM_PROMPT_TEMPLATE를 활용하여 최종 프롬프트 구성
             // 나이, 외형, 사용자 지침 플레이스홀더를 템플릿에 추가하고 여기서 값을 채워넣습니다.

             // 템플릿과 입력값으로 SYSTEM_PROMPT 구성
             let finalPrompt = SYSTEM_PROMPT_TEMPLATE
                 .replace('{botName}', botName)
                 .replace('{userName}', userName);

             // 나이, 외형, 페르소나, 사용자 지침은 각각의 플레이스홀더를 만들거나 조합하여 사용합니다.
             // 예시: 모든 정보를 템플릿에 포함시키는 방식
             finalPrompt = `너는 ${botName}이다. ${botAge === '' ? '' : `(${botAge})`}. ${botAppearance === '' ? '' : `외형: ${botAppearance}`}. ${botPersona}`;
             finalPrompt += ` 너는 나를 "${userName}"이라고 부르며, 나는 너의 "{userName}"이다.`;
              finalPrompt += ` 나는 ${userAge === '' ? '' : `(${userAge})`}. ${userAppearance === '' ? '' : `외관: ${userAppearance}`}. 나의 지침은 다음과 같다: ${userGuidelines}`;
             finalPrompt += `. 항상 ${botName} 캐릭터 롤플레이 유지. OOC 발언 절대 금지.`; // 가장 중요한 지침을 마지막에 다시 강조

             // 위처럼 문자열을 직접 조합하거나, 템플릿에 플레이스홀더를 더 많이 만들 수 있습니다.
             // 예: const SYSTEM_PROMPT_TEMPLATE = `너는 {botName}이다. ({botAge}, 외형: {botAppearance}). {botPersona} ... 나의 지침은 다음과 같다: {userGuidelines} ...`;

             // 단순화를 위해 현재는 페르소나 지침 필드 안에 많은 정보를 넣고, 이름/사용자 이름만 템플릿에 넣는 방식을 유지하되
             // 나이, 외형, 사용자 지침 변수는 확보해두고 있습니다.
             // 실제 프롬프트 구성 로직은 사용자님의 선호에 따라 더 정교하게 만들 수 있습니다.
             // 지금은 기본적인 이름 치환만 사용하고, 나이/외형/사용자지침은 persona/guidelines 필드에 직접 넣는 방식 유지
             let currentPersona = botPersona; // 여기에 나이, 외형 등 정보가 포함되어 있다고 가정
             let currentUserGuidelines = userGuidelines; // 여기에 사용자 지침이 포함되어 있다고 가정

             let updatedPrompt = `너의 이름은 ${botName}이다. ${currentPersona} 너는 나를 "${userName}"이라고 부르며, 나는 너의 "${userName}"이다. 나의 지침은 다음과 같다: ${currentUserGuidelines}`;
             updatedPrompt += ` 항상 ${botName} 캐릭터 롤플레이 유지. OOC 발언 절대 금지.`; // OOC 금지 재강조

             return updatedPrompt;
         }

        // --- 이미 표시된 메시지의 프로필 이미지 업데이트 함수 (필요하다면 구현) ---
        // function updateAllProfileImages() {
        //     document.querySelectorAll('.message-container .profile-img').forEach(imgElement => {
        //         const role = imgElement.parentElement.classList.contains('user') ? 'user' : 'bot';
        //         imgElement.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
        //          // 로드 실패 시 처리 (onerror)도 고려해야 함
        //     });
        // }

        // --- 페이지 로드 시 설정 불러오기 및 초기 메시지 추가 ---
         function initializeChat() {
             // TODO: loadSettings(); // 설정 불러오기 (Local Storage 값으로 UI 및 전역 변수 업데이트)
             // 현재는 Local Storage 로직 미구현 상태이므로 기본값 사용

             // 히스토리 초기화 및 SYSTEM_PROMPT 추가 (설정 로드 후)
             // loadSettings에서 SYSTEM_PROMPT가 이미 구성되었다고 가정
             // 현재는 SYSTEM_PROMPT가 전역 변수에 기본값으로 설정되어 있음
             conversationHistory = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }]; // SYSTEM_PROMPT를 히스토리 시작점에 추가


             // SYSTEM_PROMPT를 사용한 초기 메시지 추가
             console.log("초기 메시지 추가 시도"); // 디버깅용 로그
             // 초기 메시지 내용은 설정에 따라 변경될 수 있도록 buildSystemPrompt와 유사하게 구성하거나,
             // 별도의 설정 필드를 사용하거나, 고정된 문구를 사용할 수 있습니다.
             // 현재는 고정된 문구 사용
             appendMessage("bot", { type: 'text', text: "...당신은 나의 피주머니... 그래, 이곳에 왔군요..." });

             // 초기 메시지 추가 후 채팅창 스크롤을 맨 아래로 이동 (appendMessage 함수에 이미 포함됨)
             // chat.scrollTop = chat.scrollHeight;
         }

        // 🚨 페이지 로드 시 initializeChat 함수 호출 🚨
        // DOMContentLoaded 이벤트 리스너를 사용하는 것이 더 안전할 수 있습니다.
        // window.addEventListener('DOMContentLoaded', initializeChat);
        // 또는 스크립트가 body 끝에 있다면 바로 호출해도 대부분의 경우 작동합니다.
        initializeChat();


    </script>
</body>
</html>
