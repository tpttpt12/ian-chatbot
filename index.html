<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>이안 - 피주머니 전용 챗봇</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 레이아웃 개선을 위한 컨테이너 스타일 수정 */
        .app-container {
             display: flex;
             flex-direction: column;
             height: 100%;
             width: 95%; /* 너비를 일단 넓게 설정 */
             max-width: 900px; /* 최대 너비 설정 (대략 1500px 화면에서 60% 정도 느낌) */
             margin: 0 auto; /* 좌우 자동 마진으로 중앙 정렬 */
             background-color: #282828; /* 배경색 유지 */
             /* 불필요한 그림자/테두리 제거 */
             box-shadow: none;
             border: none;
             position: relative;
             overflow: hidden; /* 컨테이너 내부 내용 넘침 방지 */
        }
         /* 화면이 충분히 넓을 때 너비를 60%로 조정 */
         @media (min-width: 1200px) {
             .app-container {
                 width: 60%;
             }
         }


        .chat-header {
            background-color: #282828;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            /* border-bottom: 1px solid #3a3a3a; */ /* 구분선 제거 */
            flex-shrink: 0;
            position: relative;
             display: flex;
             justify-content: center;
             align-items: center;
        }

        #sidebarToggle {
            position: absolute;
            top: 50%;
            right: 1rem;
            transform: translateY(-50%);
            width: 35px;
            height: 35px;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
            z-index: 10;
        }
         #sidebarToggle:hover {
             background-color: #6a6a6a;
         }

        #chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
             /* 스크롤바 스타일 */
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #282828; /* 썸네일색 트랙색 */
             background-color: transparent; /* 부모 요소의 배경색을 따름 */
        }
        /* Webkit 브라우저용 스크롤바 스타일 */
        #chat::-webkit-scrollbar { width: 8px; }
        #chat::-webkit-scrollbar-track { background: #282828; }
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #282828;
        }

        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 95%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
        }

        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative;
            font-size: 1rem;
            /* 사용자 입력 줄바꿈 표시를 위한 설정 */
             white-space: pre-wrap;
             /* 말풍선 자체 하단 마진 제거 시도 */
             margin-bottom: 0;
        }
         /* 챗봇 메시지의 p 태그 하단 마진 제거 (더 세밀한 간격 제어) */
         .message-container.bot .message-bubble p {
             margin-bottom: 0;
         }


        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* 마크다운 내부 스타일 (adjust as needed) */
        /* p 태그에 기본적인 하단 마진 부여 (말풍선 내 요소 간 간격) */
        .message-bubble p { margin: 0 0 0.5rem 0; }
        .message-bubble p:last-child { margin-bottom: 0; } /* 마지막 단락 하단 마진 제거 */
        .message-bubble ul, .message-bubble ol { padding-left: 1.5rem; margin: 0 0 0.5rem 0; }
        .message-bubble li { margin-bottom: 0.25rem; }
        .message-bubble code {
            background-color: #3a3a3a;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
        }
         .message-bubble pre {
             background-color: #3a3a3a;
             padding: 0.75rem;
             border-radius: 4px;
             overflow-x: auto;
             margin: 0.5rem 0;
         }
        .message-bubble pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
             font-size: 1rem;
        }
        .message-bubble blockquote {
             border-left: 4px solid #5a5a5a;
             padding-left: 1rem;
             margin: 0.5rem 0;
             color: #b0b0b0;
        }
         .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 {
             margin-top: 1rem;
             margin-bottom: 0.5rem;
             padding-bottom: 0.2rem;
             border-bottom: 1px solid #4a4a4a;
             font-weight: bold;
             color: #ffffff;
         }
         .message-bubble h1 { font-size: 1.5rem; }
         .message-bubble h2 { font-size: 1.4rem; }
         .message-bubble h3 { font-size: 1.3rem; }
         .message-bubble h4 { font-size: 1.2rem; }
         .message-bubble h5 { font-size: 1.1rem; }
         .message-bubble h6 { font-size: 1rem; }


         /* 행동 묘사 스타일 */
         /* *별표* 로 감싸진 부분에 적용될 스타일 */
        .action-description {
             color: #b0b0b0;
             font-style: italic;
         }
         /* 대사 스타일 */
         /* "따옴표" 로 감싸진 부분에 적용될 스타일 */
        .dialogue {
             font-weight: bold;
         }


        .message-image-thumbnail {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            margin-top: 0.2rem;
            border: 1px solid #5a5a5a;
        }

         .message-image-thumbnail.error {
             background-color: #5a5a5a;
         }

        #inputArea {
            display: flex;
            padding: 1rem;
            background-color: #282828;
            /* border-top: 1px solid #3a3a3a; */ /* 구분선 제거 */
            align-items: center;
            gap: 0.75rem;
             flex-shrink: 0;
             position: relative;
        }

        #actionMenuButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        #actionMenuButton:hover {
            background-color: #6a6a6a;
        }


        /* textarea 스타일 수정: 스크롤바 제거 및 모서리 둥글게 */
        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem; /* 둥글게 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            resize: none; /* 크기 조절 비활성화 (필요에 따라 vertical로 변경 가능) */
            line-height: 1.4; /* input과 유사하게 행간 설정 */
            box-sizing: border-box; /* padding 포함하여 크기 계산 */
            height: 40px; /* 초기 높이 설정 (actionMenuButton 높이와 맞춤) */
            overflow-y: hidden; /* 스크롤바 제거 */
            padding-top: calc(0.75rem + 2px); /* 상하 패딩 조정 */
             padding-bottom: calc(0.75rem + 2px);
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        #sendButton {
            padding: 0.75rem 1.5rem;
            border-radius: 1.5rem; /* 둥글게 */
            background-color: #5080ff;
            color: #ffffff;
            font-size: 1rem;
            font-weight: bold;
            min-width: 6rem;
            flex-shrink: 0;
             border: none;
             cursor: pointer;
        }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }

        .settings-area {
            display: none;
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
        }

        #actionMenu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
             max-height: 0;
            background-color: #282828;
            color: #e0e0e0;
            border-top: 1px solid #3a3a3a;
            padding: 0 1rem;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #actionMenu.visible {
            max-height: 300px;
            padding: 1rem;
        }

        #actionMenu .menu-buttons {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.75rem;
            justify-content: center;
            width: 100%;
            padding-bottom: 1rem;
             overflow-x: auto;
             padding-top: 1rem;
        }

         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; }
         #actionMenu .menu-buttons { -ms-overflow-style: none; }


        /* 액션 메뉴 버튼 스타일 수정: 원형으로 */
        #actionMenu button {
            flex-shrink: 0;
            flex-basis: auto;
            max-width: none;
             width: 60px; /* 가로세로 동일하게 */
             height: 60px; /* 가로세로 동일하게 */
             border-radius: 50%; /* 원형으로 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.8rem; /* 폰트 크기 조정 */
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2;
             word-break: keep-all;
             padding: 0; /* 패딩 제거 또는 조정 */
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 1rem;
            flex-shrink: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Initially hidden */
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #1f1f1f;
            color: #e0e0e0;
            border-left: 1px solid #3a3a3a;
            transition: right 0.3s ease-out;
            z-index: 900;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            /* 스크롤바 스타일 */
            scrollbar-width: thin;
            scrollbar-color: #5a5a5a #1f1f1f; /* 썸네일색 트랙색 */
        }
        /* Webkit 브라우저용 스크롤바 스타일 */
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-track { background: #1f1f1f; }
        #sidebar::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #1f1f1f;
        }


        #sidebar.visible {
            right: 0;
        }

         .sidebar-header {
             font-size: 1.1rem;
             font-weight: bold;
             margin-bottom: 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid #3a3a3a;
         }

         .sidebar-content label {
             display: block;
             margin-bottom: 0.5rem;
             font-weight: bold;
             color: #b0b0b0;
         }

         /* 설정 입력 칸 스타일 수정: 모서리 둥글게 */
         .sidebar-content input[type="text"],
         .sidebar-content textarea {
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 8px; /* 더 둥글게 */
             background-color: #3a3a3a;
             color: #e0e0e0;
             font-size: 1rem;
             margin-bottom: 1rem;
             box-sizing: border-box;
             resize: vertical;
         }

         .sidebar-content textarea {
             min-height: 150px;
         }

         .sidebar-save-button {
             display: block;
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #5080ff;
             color: #ffffff;
             font-size: 1rem;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease;
             text-align: center;
         }
         .sidebar-save-button:hover {
             background-color: #6699ff;
         }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 890;
            display: none;
        }

        .sidebar-section-divider {
             height: 1px;
             background-color: #3a3a3a;
             margin: 1.5rem 0;
        }

        /* 설정 슬롯 버튼 스타일 */
        .setting-slots {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #3a3a3a;
        }

        .setting-slots h3 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            color: #b0b0b0;
        }

        .slot-buttons-container {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .slot-button {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            flex-shrink: 0;
        }

        .slot-button:hover {
            background-color: #6a6a6a;
        }

        .slot-button.active {
            background-color: #5080ff;
            transform: scale(1.1);
        }
         .slot-button:active {
             background-color: #3366cc;
         }


    </style>
</head>
<body>
    <div class="app-container">
        <div class="chat-header">
            이안 - 피주머니 전용 챗봇
            <button id="sidebarToggle" title="설정 열기">⚙️</button>
        </div>

        <div id="chat">
        </div>

        <div id="inputArea">
             <button id="actionMenuButton" title="액션 메뉴 열기">+</button>
            <textarea id="userInput" placeholder="피주머니의 말..." autocomplete="off"></textarea>
            <button id="sendButton">전송</button>
            <div id="loadingSpinner" class="loading-spinner"></div>
        </div>
    </div>

    <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
             <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">Settings</div>
        <div class="sidebar-content">
             <div class="setting-slots">
                 <h3>Setting Slots</h3>
                 <div class="slot-buttons-container">
                     <button class="slot-button">1</button>
                     <button class="slot-button">2</button>
                     <button class="slot-button">3</button>
                     <button class="slot-button">4</button>
                     <button class="slot-button">5</button>
                     <button class="slot-button">6</button>
                 </div>
             </div>

            <h3>Character</h3>
             <label for="botNameInput">Name:</label>
            <input type="text" id="botNameInput" value="이안">
            <label for="botAgeInput">Age:</label>
            <input type="text" id="botAgeInput" value="불명 (뱀파이어)">
            <label for="botAppearanceInput">Appearance:</label>
            <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">
            <label for="botPersonaInput">Guidelines:</label>
            <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어. 성 안에서 홀로 오랜 세월 살아옴.
겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임. 사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재다.
성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음. 질문과 대화에 집중하고 현실 언급 안 함.
**항상 이안 캐릭터 롤플레이 유지. OOC 발언 절대 금지.**</textarea>
             <label for="botImageUrlInput">Image URL:</label>
             <input type="text" id="botImageUrlInput" value="">


            <div class="sidebar-section-divider"></div>

            <h3>User</h3>
            <label for="userNameInput">Name:</label>
            <input type="text" id="userNameInput" value="피주머니">
            <label for="userAgeInput">Age:</label>
            <input type="text" id="userAgeInput" value="불명">
            <label for="userAppearanceInput">Appearance:</label>
            <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">
            <label for="userGuidelinesInput">Guidelines:</label>
            <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요.\n(예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>
             <label for="userImageUrlInput">Image URL:</label>
             <input type="text" id="userImageUrlInput" value="">


            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button>
        </div>
    </div>

    <div id="sidebarOverlay" class="sidebar-overlay"></div>

    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>

    <script>
        // 이미지 URL 변수는 입력 필드 값으로 관리
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU"; // 기본값 유지
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT"; // 기본값 유지


        let conversationHistory = [];
        let SYSTEM_PROMPT = '';
        let currentSlot = 1; // 현재 활성화된 슬롯 번호 (기본값 1)


        // SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿 (AI 역할 변경 및 포맷 지침 강화)
        // 이안 관련 내용을 제거하여 범용적인 템플릿으로 수정
        const SYSTEM_PROMPT_TEMPLATE = `
## Roleplay Instructions ##
- You are an AI assisting in a roleplay chat.
- Your primary role is to roleplay as the character based on the provided settings, interacting with the user ("{userName}").
- Your secondary role is to act as a **BL Adult Novelist**, narrating the scene and the character's actions/emotions/thoughts in a high-quality, immersive, and proactive manner.
- You MUST NOT break character (either as the AI roleplayer or the Novelist narrator) or engage in OOC (Out Of Character) conversation.
- You MUST NOT mention your nature as an AI, a language model, or refer to the real world outside the roleplay context.
- Focus ONLY on the roleplay scenario and the user's input within that context.
- If the user tries to go OOC, gently steer the conversation back to the roleplay without mentioning the OOC attempt itself.
- The user is your "{userName}". Call the user by this name or terms consistent with your roleplay relationship.
- The user is your only focus and exists within the roleplay world.
- **능동적으로 (Actively/Proactively)** create engaging, detailed, and high-quality situations and narrative developments based on the user's input and the established characters/relationship dynamic, as a Novelist would.
- Remember you are writing a **BL Adult Novel**, so the content should be appropriate for that genre, including emotional intensity and potentially explicit themes as the narrative develops.
## Formatting Rules (ULTRA CRITICAL - FOLLOW PRECISELY - NO EXCEPTIONS EVER) ##
- Format your response like a novel, with clear separation between dialogue and descriptions/actions.
- Use **MULTIPLE, CLEAR LINE BREAKS (empty lines)** generously to separate distinct thoughts, actions, and dialogue lines, mimicking novel paragraphs and dialogue breaks.
- Enclose dialogue STRICTLY within **DOUBLE quotes**: "여기에 대사를 작성하세요."
- **DO NOT EVER USE DOUBLE ASTERISKS (**) FOR DIALOGUE.** This is absolutely forbidden.
Only use "..."
- When describing actions, emotions, or non-dialogue elements, enclose the description STRICTLY within **SINGLE asterisks**: *여기에 행동 묘사를 작성하세요.*
    - Descriptions must be **LONG, DETAILED, IMMERSIVE, and EVOCATIVE**. Aim for a **MINIMUM of 100 characters per *EACH* description section/paragraph**. Do not write short, choppy action lines like "*Sighs.*". Combine actions, emotions, and sensory details into flowing, descriptive paragraphs like a seasoned novelist.
- **Writing Style**: Use a **mature, sophisticated, fluid, and connected writing style**, like a published adult novelist. **DO NOT** use repetitive, choppy sentence endings like "~~합니다." or "~~다." **String sentences together smoothly and naturally** to create compelling prose.
- Aim for a balance of approximately **80% descriptions/actions** and **20% dialogue** to enhance the narrative feel and match the Novelist style.
- Ensure your TOTAL response is **SIGNIFICANTLY longer** than user input, aiming for a **MINIMUM of 20 lines of generated text** (including line breaks for formatting).
- Use other standard Markdown (bold, italics within descriptions, lists, code blocks, blockquotes) as appropriate for descriptions, but NOT for dialogue or action descriptions.
## Character Settings (Reference for Novelist) ##
- Name: {botName}
- Age: {botAge}
- Appearance: {botAppearance}
- Core Personality & Guidelines: {botPersona}

## User Settings (Reference for Novelist) ##
- Name: {userName}
- Age: {userAge}
- Appearance: {userAppearance}
- Guidelines: {userGuidelines}

## Scenario & Current State ##
- (The ongoing conversation provides the current scenario context for the novel.)
`; // 이전의 "Relationship Dynamic" 섹션 제거


        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput"); // textarea로 변경됨
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");
        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        // 유저 변경 / 캐릭터 변경 버튼 관련 요소 삭제
        // const menuUserImgButton = document.getElementById("menuUserImgButton");
        // const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        // 캐릭터 이미지 URL 입력 필드 요소 가져오기
        const botImageUrlInput = document.getElementById("botImageUrlInput");

        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = document.getElementById("userAppearanceInput");
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        // 유저 이미지 URL 입력 필드 요소 가져오기
        const userImageUrlInput = document.getElementById("userImageUrlInput");

        const saveSettingsButton = document.getElementById("saveSettingsButton");

        // 슬롯 버튼 관련 요소 가져오기
        const slotButtons = document.querySelectorAll('.slot-button');


        sendButton.addEventListener("click", sendMessage);

        // keydown 이벤트 리스너 수정: Shift+Enter는 줄바꿈, Enter만 누르면 전송
        userInput.addEventListener("keydown", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); // 기본 Enter 동작 (줄바꿈) 막기
                sendMessage();
            }
            // Shift + Enter는 기본 동작 (줄바꿈)이 실행되도록 별도 처리 없음
        });


        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });
        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });
        // 유저 변경 / 캐릭터 변경 버튼 이벤트 리스너 삭제
        // menuUserImgButton.addEventListener("click", function() { changeProfileImage('user'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        // menuBotImgButton.addEventListener("click", function() { changeProfileImage('bot'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });
        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });
        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });
        sidebarToggle.addEventListener("click", function() {
            sidebar.classList.toggle("visible");
            if (sidebar.classList.contains("visible")) {
                sidebarOverlay.style.display = 'block';
                actionMenu.classList.remove("visible");
                menuOverlay.style.display = 'none';
                imageOverlay.style.display = 'none';


            } else {
                sidebarOverlay.style.display = 'none';
            }
        });
        sidebarOverlay.addEventListener("click", function() {
            sidebar.classList.remove("visible");
            sidebarOverlay.style.display = 'none';
        });

         // 기존 saveSettingsButton 클릭 이벤트 수정: 현재 활성화된 슬롯에 저장
        saveSettingsButton.addEventListener("click", function() {
             saveSettings(currentSlot);
        });

        // 슬롯 버튼 클릭 이벤트 리스너 추가
        slotButtons.forEach(button => {
            button.addEventListener('click', function() {
                const slotNumber = parseInt(this.textContent);
                // 수정된 로직: 슬롯 버튼 클릭 시 currentSlot 및 스타일 업데이트는 항상 실행
                currentSlot = slotNumber; // 현재 슬롯 업데이트
                updateSlotButtonStyles(); // 슬롯 버튼 스타일 업데이트

                loadSettings(slotNumber); // 해당 슬롯 설정 로드 시도 (loadSettings 내에서는 로드 성공 여부에 따라 입력 필드 업데이트만 수행)
            });
        });


        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            // 이미지 URL은 입력 필드 값이나 기본값을 사용
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl); // 이미 변수에 저장된 최신 URL 사용
            img.alt = (role === 'user' ? (userNameInput.value || "사용자") + " 프로필" : (botNameInput.value || "캐릭터") + " 프로필"); // alt 텍스트 변경
            img.onerror = function() {
                 // console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`); // 콘솔 로그 제거
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            const roleName = document.createElement("div");
            roleName.className = "role-name";
            roleName.textContent = (role === "user" ? userNameInput.value || "사용자" : botNameInput.value || "캐릭터"); // 기본 이름 변경


            let messageContentElement;
            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                let rawText = messageData.text;

                // 마크다운 파싱 전에 임시 마커 사용, 파싱 후 임시 마커를 찾아 스타일 적용 (별표 스타일 누락, 줄바꿈 문제 해결 시도)
                let processedText = rawText;
                // "..."를 [[DIALOGUE]]...[[/DIALOGUE]] 로 변환
                processedText = processedText.replace(/"(.*?)"/gs, '[[DIALOGUE]]$1[[/DIALOGUE]]');
                // *...*를 [[ACTION]]...[[/ACTION]] 로 변환 (마크다운의 기울임꼴과 충돌 방지)
                processedText = processedText.replace(/\*([^*]+)\*/gs, '[[ACTION]]$1[[/ACTION]]');
                // marked.js를 사용하여 기본 마크다운을 HTML로 변환
                let htmlContent = marked.parse(processedText);
                // 임시 마커를 찾아 span 태그로 변환하여 스타일 적용
                // [[DIALOGUE]]...[[/DIALOGUE]] -> <span class="dialogue">...</span>
                htmlContent = htmlContent.replace(/\[\[DIALOGUE\]\](.*?)\[\[\/DIALOGUE\]\]/gs, '<span class="dialogue">$1</span>');
                // [[ACTION]]...[[/ACTION]] -> <span class="action-description">$1</span>
                htmlContent = htmlContent.replace(/\[\[ACTION\]\](.*?)\[\[\/ACTION\]\]/gs, '<span class="action-description">$1</span>');
                messageContentElement.innerHTML = htmlContent;


            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                 messageContentElement.alt = "이미지 메시지";
                 img.onerror = function() {
                     // console.warn(`Failed to load image message from "${this.src}". Using fallback.`); // 콘솔 로그 제거
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 // 이미지 썸네일 클릭 이벤트 리스너
                 messageContentElement.addEventListener("click", function() {
                     // console.log("이미지 썸네일 클릭됨"); // 클릭 감지 로그 (제거)
                     if (!this.classList.contains('error')) {
                         // console.log("이미지 로드 성공, 오버레이 표시 시도"); // 오버레이 표시 조건 충족 로그 (제거)
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
                     } else {
                         // console.log("이미지 로드 실패, 오버레이 표시 안 함"); // 오버레이 표시 조건 불충족 로그 (제거)
                         alert("이미지를 불러올 수 없습니다.");
                     }
                 });
            }

            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img);
            } else {
                container.appendChild(img);
                container.appendChild(contentWrapper);
            }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true;
            loadingSpinner.style.display = 'block';
            appendMessage("user", { type: 'text', text: message });

            // 입력창 자동 지우기
            userInput.value = '';
             // textarea 높이 초기화
            userInput.style.height = '40px'; // 초기 설정 높이와 동일하게

            conversationHistory.push({
                role: "user",
                messageData: { type: 'text', text: message }
            });
            try {
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text')
                    .map(entry => ({
                        role: entry.role,


                         parts: [{ text: entry.messageData.text }]
                    }));
                const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];
                if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                     // console.log("Only SYSTEM_PROMPT to send to API."); // 콘솔 로그 제거
                } else if (contentsForApi.length === 0) {
                     // console.log("No content to send to API."); // 콘솔 로그 제거
                     appendMessage("bot", { type: 'text', text: "(메시지 전송 실패: 보낼 텍스트 내용 없음)" });
                     return Promise.resolve();
                }

                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",


                         headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
 } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }

        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");
            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 actionMenuButton.disabled = true;

                 appendMessage("user", { type: 'image', url: imageUrl.trim() });
                 conversationHistory.push({
                     role: "user",
                     messageData: { type: 'image', url: imageUrl.trim() }
                 });
                 sendButton.disabled = false;
                 userInput.disabled = false;
                 actionMenuButton.disabled = false;
                 userInput.focus();
            } else if (imageUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }

        // changeProfileImage 함수 삭제 (액션 메뉴 버튼 제거)
        /*
        function changeProfileImage(role) {
             const promptText = role === 'user' ?
 "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 캐릭터 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);
             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') {
                     userProfileImgUrl = newUrl.trim();
                 } else {
                     botProfileImgUrl = newUrl.trim();
                 }
                 alert(`${role === 'user' ? '사용자' : '캐릭터'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
             } else if (newUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }
        */


        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");
             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true;
             loadingSpinner.style.display = 'block';
             // 상황 생성 요청 프롬프트에도 포맷 지침 추가
             const situationPromptText = `기존 대화 맥락과 현재 캐릭터 설정에 기반하여, 흥미롭고 새로운 상황과 사건을 현재 캐릭터의 시점에서 소설 형식으로 묘사하듯 하나 만들어줘.
 사용자가 자연스럽게 반응할 수 있는 형태로 제시해야 해. 대화의 다음 흐름으로 자연스럽게 이어지도록 만들어봐.
 **중요: 생성된 상황 묘사 후에는 반드시 현재 캐릭터로 돌아가 사용자에게 말을 걸어야 해.
 설명조나 OOC 발언은 절대 금지하고, 모든 상황 묘사는 *별표* 형식으로, 대사는 "따옴표" 형식으로 작성하며, 묘사 70% 대사 30% 정도의 비율을 유지하고 문단과 줄바꿈을 적절히 사용해.**`; // 프롬프트 변경
             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text')
                 .map(entry => ({
                    role: entry.role,
                    parts: [{ text: entry.messageData.text }]

         }));
             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText }] }];
             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                 // console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API."); // 콘솔 로그 제거
             } else if (contentsForApi.length === 0) {
                 // console.log("No content to send to API."); // 콘솔 로그 제거
                 appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                 return Promise.resolve();
             }


            try {
                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",


                         headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
 } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }


        // loadSettings 함수 수정: 슬롯 번호를 인자로 받아 해당 슬롯의 설정을 로드
        function loadSettings(slotNumber) {
             // console.log(`loadSettings 호출됨 - 슬롯 ${slotNumber}`); // 콘솔 로그 제거
             // 수정된 로직: 슬롯 버튼 클릭 시 currentSlot 및 스타일 업데이트는 항상 실행
             currentSlot = slotNumber; // 현재 슬롯 업데이트
             updateSlotButtonStyles(); // 슬롯 버튼 스타일 업데이트

             const settingsKey = `settings_slot_${slotNumber}`;
             const savedSettings = localStorage.getItem(settingsKey);

             if (savedSettings) {
                 try {
                     const settings = JSON.parse(savedSettings);

                     botNameInput.value = settings.botName || ''; // 기본값 변경
                     userNameInput.value = settings.userName || ''; // 기본값 변경
                     botPersonaInput.value = settings.botPersona || ''; // 기본값 변경
                     botAgeInput.value = settings.botAge || ''; // 기본값 변경
                     userAgeInput.value = settings.userAge || ''; // 기본값 변경
                     userAppearanceInput.value = settings.userAppearance || ''; // 기본값 변경
                     botAppearanceInput.value = settings.botAppearance || ''; // 기본값 변경
                     userGuidelinesInput.value = settings.userGuidelines || ''; // 기본값 변경
                     // 이미지 URL 입력 필드 값 로드
                     botImageUrlInput.value = settings.botImageUrl || '';
                     userImageUrlInput.value = settings.userImageUrl || '';


                     // 프로필 이미지 URL 변수 업데이트 (입력 필드 값 > 저장된 값 > 기본값 순)
                     userProfileImgUrl = userImageUrlInput.value || settings.userProfileImgUrl || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
                     botProfileImgUrl = botImageUrlInput.value || settings.botProfileImgUrl || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";


                     SYSTEM_PROMPT = buildSystemPrompt(
                         botNameInput.value,
                         userNameInput.value,
                         botPersonaInput.value,
                         botAgeInput.value,
                         botAppearanceInput.value,

                         userAgeInput.value,
                         userAppearanceInput.value,
                         userGuidelinesInput.value
                     );
                     // console.log(`SYSTEM_PROMPT 로드 완료 - 슬롯 ${slotNumber}:`, SYSTEM_PROMPT); // 콘솔 로그 제거
                     // currentSlot 업데이트와 스타일 업데이트는 함수 초반에서 이미 했습니다.
                     // alert(`${slotNumber}번 슬롯의 설정을 불러왔습니다.`); // 알림 제거

                 } catch (e) {
                     console.error(`Failed to parse settings from slot ${slotNumber}:`, e);
                     // alert(`${slotNumber}번 슬롯 설정을 불러오는데 실패했습니다. 데이터가 손상되었을 수 있습니다.`); // 알림 제거
                     loadDefaultSettings(); // 기본 설정 로드 시도 (currentSlot/스타일은 그대로)
                 }
             } else {
                 // 저장된 설정이 없으면 기본 설정 로드
                 // console.log(`슬롯 ${slotNumber}에 저장된 설정이 없습니다. 기본 설정을 로드합니다.`); // 콘솔 로그 제거
                 loadDefaultSettings(); // 이 함수 내에서는 currentSlot이나 스타일 변경하지 않음
                 // alert(`${slotNumber}번 슬롯에 저장된 설정이 없습니다. 기본 설정을 로드했습니다.`); // 알림 추가
             }
        }

        // saveSettings 함수 수정: 현재 활성화된 슬롯에 설정 저장
        function saveSettings(slotNumber) {
             // console.log(`saveSettings 호출됨 - 슬롯 ${slotNumber}`); // 콘솔 로그 제거
             const settingsToSave = {
                 botName: botNameInput.value.trim(),
                 userName: userNameInput.value.trim(),
                 botPersona: botPersonaInput.value.trim(),
                 botAge: botAgeInput.value.trim(),
                 userAge: userAgeInput.value.trim(),
                 userAppearance: userAppearanceInput.value.trim(),
                 botAppearance: botAppearanceInput.value.trim(),
                 userGuidelines: userGuidelinesInput.value.trim(),
                 // 이미지 URL 입력 필드 값 저장
                 botImageUrl: botImageUrlInput.value.trim(),
                 userImageUrl: userImageUrlInput.value.trim(),
                 // 프로필 이미지 URL 변수 값도 함께 저장 (혹시 모를 경우 대비)
                 userProfileImgUrl: userProfileImgUrl,
                 botProfileImgUrl: botProfileImgUrl

             };

             try {
                 const jsonString = JSON.stringify(settingsToSave);
                 localStorage.setItem(`settings_slot_${slotNumber}`, jsonString);
                 // currentSlot 업데이트와 스타일 업데이트는 슬롯 로드 시에만 합니다.
                 // alert(`${slotNumber}번 슬롯에 현재 설정이 저장되었습니다.`); // 알림 제거
                 // console.log(`슬롯 ${slotNumber}에 설정 저장 완료`); // 콘솔 로그 제거
             } catch (e) {
                  console.error(`Failed to save settings to slot ${slotNumber}:`, e);
                  // alert(`${slotNumber}번 슬롯에 설정을 저장하는데 실패했습니다.`); // 알림 제거
             }
        }

        // 기본 설정을 로드하는 함수 (저장된 설정이 없거나 로드 실패 시 사용)
        // 기본값을 빈 값 또는 일반적인 플레이스홀더로 수정
        function loadDefaultSettings() {
             // console.log("기본 설정 로드"); // 콘솔 로그 제거
            botNameInput.value = ''; // 빈 값으로 변경
            userNameInput.value = ''; // 빈 값으로 변경
            botPersonaInput.value = '캐릭터의 성격, 배경, 말투, 행동 지침 등을 입력하세요.'; // 일반적인 플레이스홀더
            botAgeInput.value = ''; // 빈 값으로 변경
            userAgeInput.value = ''; // 빈 값으로 변경
            userAppearanceInput.value = '사용자의 외관을 입력하세요.'; // 일반적인 플레이스홀더
            botAppearanceInput.value = '캐릭터의 외관을 입력하세요.'; // 일반적인 플레이스홀더
            userGuidelinesInput.value = '사용자 캐릭터의 지침을 입력하세요 (예: 나는 어떤 사람인지 등).'; // 일반적인 플레이스홀더
            // 이미지 URL 기본값 설정
            botImageUrlInput.value = ''; // 기본값 빈 값
            userImageUrlInput.value = ''; // 기본값 빈 값

            // 프로필 이미지 변수는 기본 placeholder URL로 초기화
            userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
            botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";


            SYSTEM_PROMPT = buildSystemPrompt(
                botNameInput.value,
                userNameInput.value,
                botPersonaInput.value,
                botAgeInput.value,
                botAppearanceInput.value,
                userAgeInput.value,
                userAppearanceInput.value,
                userGuidelinesInput.value
            );
             // currentSlot과 스타일 업데이트는 loadSettings에서 이미 처리했습니다.
            // alert("기본 설정을 로드했습니다."); // 불필요한 알림 제거
        }


         function buildSystemPrompt(botName, userName, botPersona, botAge, botAppearance, userAge, userAppearance, userGuidelines) {
             // 범용적인 템플릿 사용 (이안 관련 내용 제거됨)
             let finalPrompt = SYSTEM_PROMPT_TEMPLATE
                 .replace('{botName}', botName || '캐릭터') // 기본값 변경
                 .replace('{botAge}', botAge || '불명')
                 .replace('{botAppearance}', botAppearance || '설정되지 않음')
                 .replace('{botPersona}', botPersona || '설정된 캐릭터 지침 없음.') // 기본값 변경
                 .replace('{userName}', userName || '사용자') // 기본값 변경
                 .replace('{userAge}', userAge || '불명')
                 .replace('{userAppearance}', userAppearance || '설정되지 않음')
                 .replace('{userGuidelines}', userGuidelines || '설정된 사용자 지침 없음.');

             return finalPrompt.trim();
         }

         // 슬롯 버튼 활성/비활성 스타일 업데이트
         function updateSlotButtonStyles() {
             slotButtons.forEach(button => {
                 if (parseInt(button.textContent) === currentSlot) {
                     button.classList.add('active');
                 } else {
                     button.classList.remove('active');
                 }
             });
         }


        function initializeChat() {
             // console.log("initializeChat 호출됨"); // 콘솔 로그 제거
             loadSettings(1); // 페이지 로드 시 1번 슬롯의 설정 로드 (currentSlot 및 스타일 업데이트 포함)

             // 초기 대화 메시지 전송 (SYSTEM_PROMPT 포함)
             // conversationHistory는 loadSettings에서 업데이트된 SYSTEM_PROMPT를 사용해야 하므로 initializeChat에서 설정
             const initialContents = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }];
             // SYSTEM_PROMPT만 보내는 것이 아니라, 초기 봇 인사말도 함께 보내야 한다면 여기에 추가 로직 필요
             // 현재 로직은 SYSTEM_PROMPT만 초기 메시지로 보내고 있습니다.
             // 초기 봇 인사말은 화면에만 표시하고 AI에게는 보내지 않는 방식입니다.

             // console.log("초기 SYSTEM_PROMPT:", SYSTEM_PROMPT); // 콘솔 로그 제거

             // console.log("초기 메시지 추가 시도"); // 콘솔 로그 제거
             // 이 부분은 AI에게 보내는 메시지가 아니라 화면에 표시하는 부분입니다.
             const initialBotGreeting = `채팅을 시작합니다. 캐릭터와 사용자 설정을 확인해주세요.`; // 초기 인사말 변경
             appendMessage("bot", { type: 'text', text: initialBotGreeting });

             // console.log("채팅 초기화 완료."); // 콘솔 로그 제거

             // 페이지 로드 후 바로 AI 응답을 받으려면 여기에 첫 sendMessage 호출 로직 추가 필요
             // 예: sendMessage("초기 인사말에 대한 AI의 응답을 유도하는 텍스트");
             // 현재 로직은 사용자가 첫 메시지를 보낼 때까지 AI에게는 SYSTEM_PROMPT 외에 아무것도 보내지 않습니다.
         }

         // textarea 높이 자동 조절 기능 추가
         function autoResizeTextarea() {
             this.style.height = 'auto'; // 높이 초기화
             this.style.height = (this.scrollHeight) + 'px'; // 스크롤 높이만큼 높이 설정
             // 최소 높이 유지 (필요시) - 예: this.style.height = Math.max(40, this.scrollHeight) + 'px';
         }

        userInput.addEventListener('input', autoResizeTextarea, false);


        initializeChat();

    </script>
</body>
</html>
