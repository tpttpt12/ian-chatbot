<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>character-chat</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bakbak+One&family=Libre+Barcode+39+Text&family=Nanum+Gothic&display=swap" rel="stylesheet">
    
    <style>
    
        body {
            font-family: "Nanum Gothic", sans-serif; /* 나눔고딕 폰트 적용 */
            background-color: #1E1E1E;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 레이아웃 개선을 위한 컨테이너 스타일 수정 */
        .app-container {
             display: flex;
             flex-direction: column;
             height: 100%;
             width: 95%; /* 너비를 일단 넓게 설정 */
             max-width: 900px; /* 최대 너비 설정 (대략 1500px 화면에서 60% 정도 느낌) */
             margin: 0 auto; /* 좌우 자동 마진으로 중앙 정렬 */
             background-color: #1e1e1e; /* 배경색 유지 */
             /* 불필요한 그림자/테두리 제거 */
             box-shadow: none;
             border: none;
             position: relative;
             overflow: hidden; /* 컨테이너 내부 내용 넘침 방지 */
        }
         /* 화면이 충분히 넓을 때 너비를 60%로 조정 */
         @media (min-width: 1200px) {
             .app-container {
                 width: 60%;
             }
         }


        .chat-header {
            background-color: 1E1E1E;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            /* border-bottom: 1px solid #3a3a3a; */ /* 구분선 제거 */
            flex-shrink: 0;
            position: relative;
            display: flex;
             justify-content: center;
             align-items: center;
        }

        #sidebarToggle {
            position: absolute;
            top: 50%;
            right: 1rem;
            transform: translateY(-50%);
            width: 35px;
            height: 35px;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
            z-index: 10;
        }
         #sidebarToggle:hover {
             background-color: #6a6a6a;
         }

#chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto; /* 스크롤은 되지만 스크롤바 숨김 */
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            /* 스크롤바 숨김 */
             scrollbar-width: none;  /* Firefox */
             -ms-overflow-style: none;  /* IE and Edge */
             background-color: #1e1e1e;
        }
        /* Webkit 브라우저용 스크롤바 숨김 */
        #chat::-webkit-scrollbar {
            display: none;  /* Chrome, Safari, Opera */
        }
        /* 기존 스크롤바 스타일은 이제 필요 없으므로 제거하거나 주석 처리합니다. */
        /*
        #chat::-webkit-scrollbar-track { background: #1E1E1E; }
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #1E1E1E;
        }
        */

        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 85%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
         }

        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
        }

        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative;
            font-size: 1rem;
            /* 사용자 입력 줄바꿈 표시를 위한 설정 */
             white-space: normal;
             /* 말풍선 자체 하단 마진 제거 시도 */
             margin-bottom: 0;
         }
         /* 챗봇 메시지의 p 태그 하단 마진 제거 (더 세밀한 간격 제어) */
         .message-container.bot .message-bubble p {
             margin-bottom: 0;
         }


        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* 마크다운 내부 스타일 (adjust as needed) */
        /* p 태그에 기본적인 하단 마진 부여 (말풍선 내 요소 간 간격) */
        .message-bubble p { margin: 0 0 0.5rem 0; }
        .message-bubble p:last-child { margin-bottom: 0; } /* 마지막 단락 하단 마진 제거 */
        .message-bubble ul, .message-bubble ol { padding-left: 1.5rem; margin: 0 0 0.5rem 0; }
        .message-bubble li { margin-bottom: 0.25rem; }
        .message-bubble code {
            background-color: #3a3a3a;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
        }
.message-bubble pre {
             background-color: #3a3a3a;
             padding: 0.75rem;
             border-radius: 4px;
             overflow-x: auto; /* 필요시 가로 스크롤바 유지 */
             margin: 0.5rem 0;
             white-space: pre-wrap; /* 공백 유지하며 줄바꿈 허용 */
             word-wrap: break-word; /* 긴 단어 강제 줄바꿈 */
             overflow-wrap: break-word; /* 표준 속성 */
         }
        .message-bubble pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
             font-size: 1rem;
        }
        .message-bubble blockquote {
             border-left: 4px solid #5a5a5a;
             padding-left: 1rem;
             margin: 0.5rem 0;
             color: #b0b0b0;
        }
         .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 {
             margin-top: 1rem;
             margin-bottom: 0.5rem;
             padding-bottom: 0.2rem;
             border-bottom: 1px solid #4a4a4a;
             font-weight: bold;
             color: #ffffff;
         }
         .message-bubble h1 { font-size: 1.5rem; }
         .message-bubble h2 { font-size: 1.4rem; }
         .message-bubble h3 { font-size: 1.3rem; }
         .message-bubble h4 { font-size: 1.2rem; }
         .message-bubble h5 { font-size: 1.1rem; }
         .message-bubble h6 { font-size: 1rem; }


         /* 행동 묘사 스타일 */
         /* *별표* 로 감싸진 부분에 적용될 스타일 */
        .action-description {
             color: #b0b0b0;
             font-style: italic; /* font- 속성을 font-style 로 수정 */
         }
         /* 대사 스타일 */
         /* "따옴표" 로 감싸진 부분에 적용될 스타일 */
        .dialogue {
             font-weight: bold;
         }


        .message-image-thumbnail {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            margin-top: 0.2rem;
            border: 1px solid #5a5a5a;
        }

         .message-image-thumbnail.error {
             background-color: #5a5a5a;
         }

#inputArea {
            display: flex;
            padding: 1rem 1.5rem 2rem 1.5rem; /* 위: 1rem, 오른쪽: 1.5rem, 아래: 2rem, 왼쪽: 1.5rem */
            background-color: #1E1E1E;
            /* border-top: 1px solid #3a3a3a; */ /* 구분선 제거 */
            align-items: center;
            gap: 0.75rem;
             flex-shrink: 0;
             position: relative;
             /* 상단에 그림자 추가 */
             box-shadow: 0 -20px 20px 0px rgba(30, 30, 30); /* 위쪽으로 퍼지는 그림자 */
             z-index: 1; /* 그림자가 채팅 내용 위로 오도록 설정 */
        }

        #actionMenuButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        #actionMenuButton:hover {
            background-color: #6a6a6a;
        }


        /* textarea 스타일 수정: 스크롤바 제거 및 모서리 둥글게 */
        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem; /* 둥글게 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            resize: none; /* 크기 조절 비활성화 */
            line-height: 1.4; /* input과 유사하게 행간 설정 */
            box-sizing: border-box; /* padding 포함하여 크기 계산 */
            /* height: 40px; */ /* 초기 높이 설정을 더 이상 사용하지 않음 */
            min-height: calc(1em * 1.4 * 2 + 0.75rem * 2); /* 최소 높이: 폰트 크기(em) * 행간 * 2줄 + 상하 패딩 */
            height: auto; /* 내용에 따라 높이 자동 조절을 완전히 비활성화하지 않고 최소 높이 이상으로만 */
            overflow-y: auto; /* 높이가 2줄을 넘어가면 스크롤바 표시 */
            padding-top: 0.75rem; /* 상하 패딩 조정 */
            padding-bottom: 0.75rem;
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        #sendButton {
            padding: 0.75rem 1.5rem;
            border-radius: 1.5rem; /* 둥글게 */
            background-color: #5080ff;
            color: #ffffff;
            font-size: 1rem;
            font-weight: bold;
            min-width: 6rem;
            flex-shrink: 0;
             border: none;
             cursor: pointer;
         }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }

        .settings-area {
            display: none;
         }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
         }

        #actionMenu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
             max-height: 0;
            background-color: #1E1E1E;
            color: #e0e0e0;
            border-top: 1px solid #3a3a3a;
            padding: 0 1rem;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
         }

        #actionMenu.visible {
            max-height: 300px;
            padding: 1rem;
        }

        #actionMenu .menu-buttons {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.75rem;
            justify-content: center;
            width: 100%;
            padding-bottom: 1rem;
             overflow-x: auto;
             padding-top: 1rem;
         }

         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; }
         #actionMenu .menu-buttons { -ms-overflow-style: none; } /* IE and Edge */


        /* 액션 메뉴 버튼 스타일 수정: 원형으로 */
        #actionMenu button {
            flex-shrink: 0;
            flex-basis: auto;
            max-width: none;
             width: 60px; /* 가로세로 동일하게 */
             height: 60px; /* 가로세로 동일하게 */
             border-radius: 50%; /* 원형으로 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.8rem; /* 폰트 크기 조정 */
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2;
             word-break: keep-all;
             padding: 0; /* 패딩 제거 또는 조정 */
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 1rem;
            flex-shrink: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 초기 공지 스타일 */
        .initial-notice {
    text-align: center; /* 중앙 정렬 */
    margin: 0.1rem auto 0.1rem auto; /* 위, 아래 여백 및 중앙 정렬 */
    color: #515151; /* 글자색 변경 */
    font-size: 0.9rem; /* 글자 크기 줄임 */
    padding: 1rem;
    max-width: 80%; /* 너무 길어지지 않도록 최대 너비 설정 */
    word-break: break-word;
}

        /* 공지 아래 구분선 스타일 */
        .notice-divider {
            width: 90%; /* 가로선 너비 */
            height: 1px;
            background-color: #3a3a3a; /* 구분선 색상 */
            margin: 0.5rem auto 1.5rem auto; /* 위, 아래 여백 및 중앙 정렬 */
        }


        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Initially hidden */
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #1f1f1f;
            color: #e0e0e0;
            border-left: 1px solid #3a3a3a;
            transition: right 0.3s ease-out;
            z-index: 900;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            /* 스크롤바 스타일 */
            scrollbar-width: thin;
            scrollbar-color: #5a5a5a #1f1f1f; /* 썸네일색 트랙색 */
        }
        /* Webkit 브라우저용 스크롤바 스타일 */
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-track { background: #1f1f1f; }
        #sidebar::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #1f1f1f;
        }


        #sidebar.visible {
            right: 0;
        }

         .sidebar-header {
             font-size: 1.1rem;
             font-weight: bold;
             margin-bottom: 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid #3a3a3a;
         }

         .sidebar-content label {
             display: block;
             margin-bottom: 0.5rem;
             font-weight: bold;
             color: #b0b0b0;
         }

         /* 설정 입력 칸 스타일 수정: 모서리 둥글게 */
         .sidebar-content input[type="text"],
         .sidebar-content textarea {
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 8px; /* 더 둥글게 */
             background-color: #3a3a3a;
             color: #e0e0e0;
             font-size: 1rem;
             margin-bottom: 1rem;
             box-sizing: border-box;
             resize: vertical;
         }

         .sidebar-content textarea {
             min-height: 150px;
         }

         .sidebar-save-button {
             display: block;
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #5080ff;
             color: #ffffff;
             font-size: 1rem;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease;
             text-align: center;
         }
         .sidebar-save-button:hover {
             background-color: #6699ff;
         }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 890;
            display: none;
         }

        .sidebar-section-divider {
             height: 1px;
             background-color: #3a3a3a;
             margin: 1.5rem 0;
        }

        /* 설정 슬롯 버튼 스타일 */
        .setting-slots {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #3a3a3a;
        }

        .setting-slots h3 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            color: #b0b0b0;
        }

        .slot-buttons-container {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .slot-button {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            flex-shrink: 0;
        }

        .slot-button:hover {
            background-color: #6a6a6a;
        }

        .slot-button.active {
            background-color: #5080ff;
            transform: scale(1.1);
        }
         .slot-button:active {
             background-color: #3366cc;
         }
        
  .delete-btn {
    background: transparent;
    border: none;
    color: #aaa;
    font-size: 1rem;
    cursor: pointer;
    position: absolute;
    top: 8px;
    right: 8px;
    padding: 0;
    z-index: 1;
  }

  .message-container {
    position: relative;
  }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="chat-header">
            character-chat
            <button id="sidebarToggle" title="설정 열기">≡</button>
        </div>

        <div id="chat">
        </div>

        <div id="inputArea">
             <button id="actionMenuButton" title="액션 메뉴 열기">+</button>
        
             <textarea id="userInput" placeholder="유저의 말..." autocomplete="off"></textarea>
            <button id="sendButton">전송</button>
            <div id="loadingSpinner" class="loading-spinner"></div>
        </div>
    </div>

    <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
             <button id="menuImageButton">이미지<br>삽입</button>
          
             <button id="menuSituationButton">상황</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">Settings</div>
        <div class="sidebar-content">
             <div class="setting-slots">
                 <h3>Setting Slots</h3>
                 <div class="slot-buttons-container">
            
                     <button class="slot-button">1</button>
                     <button class="slot-button">2</button>
                     <button class="slot-button">3</button>
                     <button class="slot-button">4</button>
                     <button class="slot-button">5</button>
  
                     <button class="slot-button">6</button>
                 </div>
             </div>

            <h3>Character</h3>
             <label for="botNameInput">Name:</label>
            <input type="text" id="botNameInput" value="이안">
         
            <label for="botAgeInput">Age:</label>
            <input type="text" id="botAgeInput" value="불명 (뱀파이어)">
            <label for="botAppearanceInput">Appearance:</label>
            <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">
            <label for="botPersonaInput">Guidelines:</label>
            <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어.
성 안에서 홀로 오랜 세월 살아옴.
겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임.
사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재다.
성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음.
질문과 대화에 집중하고 현실 언급 안 함.
**항상 이안 캐릭터 롤플레이 유지.
OOC 발언 절대 금지.**</textarea>
             <label for="botImageUrlInput">Image URL:</label>
             <input type="text" id="botImageUrlInput" value="">


            <div class="sidebar-section-divider"></div>

            <h3>User</h3>
            <label for="userNameInput">Name:</label>
            <input type="text" id="userNameInput" value="피주머니">
            <label
 for="userAgeInput">Age:</label>
            <input type="text" id="userAgeInput" value="불명">
            <label for="userAppearanceInput">Appearance:</label>
            <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">
            <label for="userGuidelinesInput">Guidelines:</label>
            <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요.\n(예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>
             <label for="userImageUrlInput">Image URL:</label>
 
             <input type="text" id="userImageUrlInput" value="">


            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button>
        </div>
    </div>

    <div id="sidebarOverlay" class="sidebar-overlay"></div>

    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>

    <script>
        // 이미지 URL 변수는 입력 필드 값으로 관리
        let userProfileImgUrl =
 "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU"; // 기본값 유지
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";
 // 기본값 유지


        let conversationHistory = [];
        let SYSTEM_PROMPT = '';
 let currentSlot = 1; // 현재 활성화된 슬롯 번호 (기본값 1)


        // SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿 (AI 역할 변경 및 포맷 지침 강화)
        // 이안 관련 내용을 제거하여 범용적인 템플릿으로 수정
const SYSTEM_PROMPT_TEMPLATE = `
## Roleplay Instructions

## 기본 작동 개요
- 당신은 BL 에로틱 소설을 쓰는 작가이자 캐릭터(공)의 역할을 동시에 맡고 있습니다.
- 사용자는 수(受) 캐릭터를 맡으며, 당신은 오직 공(攻) 캐릭터 시점으로만 서술합니다.
- 사용자가 입력한 내용은 직접적 대사일 수도 있고, 리액션일 수도 있으며, 당신은 거기에 맞춰 **계속 상황을 진전시켜야 합니다.**

## 기본 포맷 구조 (무조건 지켜야 함)
출력은 항상 아래와 같은 구조를 따릅니다:

- *문단 (서술/묘사)*  
- "대사"  
- *문단*  
- "대사"  
- *문단*

줄바꿈을 반드시 사용하며, **대사와 서술은 절대 같은 줄에 쓰지 않습니다.**
최소 700자 이상으로 출력해야합니다.

## 문장 규칙
- 서술은 감각적, 직설적, 관능적으로 작성합니다.
- **모든 행동 묘사와 내면 묘사는 `*행동*` 안에 넣습니다.** ← 반드시 이 형식
- 대사는 반드시 `"쌌네."` 형식으로, **큰따옴표만 사용**합니다.
- `**대사**`, 슬래시 `/`, 괄호 등은 사용하지 않습니다.
- 대사는 캐릭터가 직접 말한 것처럼 자연스럽고 저속하거나 노골적이어도 괜찮습니다.
- 줄바꿈은 감정 구분이나 주제 전환이 필요할 때만 사용합니다.  
  (리듬을 위한 과도한 줄바꿈은 금지)

## 시점 & 묘사 기준
- 항상 공 캐릭터({botName})의 3인칭 시점으로 씁니다.
- 수 캐릭터({userName})의 감정이나 생각은 추측하지 않습니다.
- 오직 눈에 보이는 반응과 몸의 변화만 묘사합니다.

## 성적 묘사 기준
- 감각 디테일은 **촉감, 압력, 열기, 액체의 점도, 냄새, 진동, 경련** 중심으로 작성합니다.
- **“쑤셔 넣는다”, “찍어 누른다”, “질퍽인다”** 같은 강한 동사를 사용합니다.
- 가능한 한 해부학적 정확한 용어를 사용합니다 (질 입구, 음핵, 항문, 질벽 등).
- 부끄러움, 굴욕, 더러움에 대한 서술도 자연스럽게 포함 가능합니다.
- 수가 쾌락으로 흐트러지는 모습을 관찰하는 묘사를 적극적으로 사용합니다.

## 진행 방식
- 같은 자세, 상황, 플레이에 머무르지 말고 **매 응답마다 리듬, 압박, 체위 또는 방식이 바뀌어야 합니다.**
- 사용자가 리액션을 하지 않아도 **{botName}은 항상 계속 행동을 이어갑니다.**
- 절정, 분출, 고조, 강박, 유혹, 장난 등 감정 변화가 동반되어야 합니다.

## 절대 금지 사항
- 대사에 따옴표 없는 경우 (`쌌네?` ← X)
- 대사와 서술을 한 문단에 붙이기 (`그는 웃었다. "쌌네."` ← X)
- 줄바꿈 없이 대사 여러 개 붙이기
- 사용자의 감정을 유추하는 내적 서술 (`그는 당황했을 것이다` ← X)

## 출력 예시
*그는 허리를 꺾어 수의 뺨을 물어뜯듯 핥았다. 숨을 섞은 입김이 귓바퀴에 스며들며, 질척한 액체가 허벅지 사이를 타고 흘러내렸다.*

"이래서야 도망치긴 글렀네."

*입꼬리를 올리며 다시 고개를 숙였다. 질 입구를 혀로 쓸며 벌어진 틈 안쪽을 미끄러지듯 훑었다. 쩍 벌어진 다리 사이에서, 수의 배가 바르르 떨렸다.*

"이제 자지 넣자. 계속 이렇게 흘리는 거, 못 참겠어."

## Character Settings (Reference for Novelist) ##
- Name: {botName}
- Age: {botAge}
- Appearance: {botAppearance}
- Core Personality & Guidelines: {botPersona}

## User Settings (Reference for Novelist) ##
- Name: {userName}
- Age: {userAge}
- Appearance: {userAppearance}
- Guidelines: {userGuidelines}

## Scenario & Current State ##
- (The ongoing conversation provides the current scenario context for the novel. Continue from the last turn.)
`;


        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput"); // textarea로 변경됨
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");
        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        // 유저 변경 / 캐릭터 변경 버튼 관련 요소 삭제
        // const menuUserImgButton = document.getElementById("menuUserImgButton");
        // const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        // 캐릭터 이미지 URL 입력 필드 요소 가져오기
        const botImageUrlInput = document.getElementById("botImageUrlInput");
        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = document.getElementById("userAppearanceInput");
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        // 유저 이미지 URL 입력 필드 요소 가져오기
        const userImageUrlInput = document.getElementById("userImageUrlInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");

        // 슬롯 버튼 관련 요소 가져오기
        const slotButtons = document.querySelectorAll('.slot-button');
        sendButton.addEventListener("click", sendMessage);

        // keydown 이벤트 리스너 수정: Shift+Enter는 줄바꿈, Enter만 누르면 전송
        userInput.addEventListener("keydown", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); // 기본 Enter 동작 (줄바꿈) 막기
                sendMessage();
            }
           
             // Shift + Enter는 기본 동작 (줄바꿈)이 실행되도록 별도 처리 없음
        });
        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });
        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });
        // 유저 변경 / 캐릭터 변경 버튼 이벤트 리스너 삭제
        // menuUserImgButton.addEventListener("click", function() { changeProfileImage('user'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        // menuBotImgButton.addEventListener("click", function() { changeProfileImage('bot'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });
        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });
        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });
        sidebarToggle.addEventListener("click", function() {
            sidebar.classList.toggle("visible");
            if (sidebar.classList.contains("visible")) {
                sidebarOverlay.style.display = 'block';
                actionMenu.classList.remove("visible");
                menuOverlay.style.display = 'none';
                imageOverlay.style.display = 'none';


            } else {
                sidebarOverlay.style.display = 'none';
            }
        });
        sidebarOverlay.addEventListener("click", function() {
            sidebar.classList.remove("visible");
            sidebarOverlay.style.display = 'none';
        });
        // 기존 saveSettingsButton 클릭 이벤트 수정: 현재 활성화된 슬롯에 저장
        saveSettingsButton.addEventListener("click", function() {
             saveSettings(currentSlot);
        });
        // 슬롯 버튼 클릭 이벤트 리스너 추가
        slotButtons.forEach(button => {
            button.addEventListener('click', function() {
                const slotNumber = parseInt(this.textContent);
                // 수정된 로직: 슬롯 버튼 클릭 시 currentSlot 및 스타일 업데이트는 항상 실행
                currentSlot = slotNumber; // 현재 슬롯 업데이트
 
                updateSlotButtonStyles(); // 슬롯 버튼 스타일 업데이트

                loadSettings(slotNumber); // 해당 슬롯 설정 로드 시도 (loadSettings 내에서는 로드 성공 여부에 따라 입력 필드 업데이트만 수행)
            });
        });
        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            // 이미지 URL은 입력 필드 값이나 기본값을 사용
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
            // 이미 변수에 저장된 최신 URL 사용
            img.alt = (role === 'user' ? (userNameInput.value || "사용자") + " 프로필" : (botNameInput.value || "캐릭터") + " 프로필");
            // alt 텍스트 변경

            img.addEventListener("click", () => openImageOverlay(img));
            img.onerror = function() {
                 // console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`); // 콘솔 로그 제거
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this);
                 }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            const roleName = document.createElement("div");
            roleName.className = "role-name";
            roleName.textContent = (role === "user" ? userNameInput.value || "사용자" : botNameInput.value || "캐릭터");
            // 기본 이름 변경


            let messageContentElement;
            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                let rawText = messageData.text;

                // 연속된 줄바꿈(하나 이상)을 해당 개수만큼의 <br> 태그로 변환
                let processedText = rawText.replace(/\n+/g, match => '<br>'.repeat(match.length));


                // 마크다운 파싱 전에 임시 마커 사용, 파싱 후 임시 마커를 찾아 스타일 적용
                // 이전의 processedText 변수 초기화 및 마커 변환 로직은 이 아래에서 계속됩니다.
                // "..."를 [[DIALOGUE]]...[[/DIALOGUE]] 로 변환
                processedText = processedText.replace(/"(.*?)"/gs, '[[DIALOGUE]]$1[[/DIALOGUE]]');
                // *...*를 [[ACTION]]...[[/ACTION]] 로 변환
                processedText = processedText.replace(/\*([^*]+)\*/gs, '[[ACTION]]$1[[/ACTION]]'); // 여기 닫는 괄호 빠졌던거 수정합니다.
                // marked.js를 사용하여 기본 마크다운을 HTML로 변환
                let htmlContent = marked.parse(processedText);
                // 임시 마커를 찾아 span 태그로 변환하여 스타일 적용
                htmlContent = htmlContent.replace(/\[\[DIALOGUE\]\](.*?)\[\[\/DIALOGUE\]\]/gs, '<span class="dialogue">$1</span>');
                htmlContent = htmlContent.replace(/\[\[ACTION\]\](.*?)\[\[\/ACTION\]\]/gs, '<span class="action-description">$1</span>');
                messageContentElement.innerHTML = htmlContent;
            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                messageContentElement.onclick = () => openImageOverlay(messageContentElement); 
                 messageContentElement.alt = "이미지 메시지";
                 img.onerror = function() {
                     // console.warn(`Failed to load image message from "${this.src}". Using fallback.`); // 콘솔 로그 제거
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 // 이미지 썸네일 클릭 이벤트 리스너
                 messageContentElement.addEventListener("click", function() {
                     // console.log("이미지 썸네일 클릭됨"); // 클릭 감지 로그 (제거)
                     if (!this.classList.contains('error')) {
      
                         // console.log("이미지 로드 성공, 오버레이 표시 시도"); // 오버레이 표시 조건 충족 로그 (제거)
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
              
                 } else {
                         // console.log("이미지 로드 실패, 오버레이 표시 안 함"); // 오버레이 표시 조건 불충족 로그 (제거)
                         alert("이미지를 불러올 수 없습니다.");
                     };
   
               });
            }

            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img);
            } else {
                container.appendChild(img);
                container.appendChild(contentWrapper);
            }
            // 삭제 버튼 추가
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "delete-btn";
            deleteBtn.textContent = "✕";
            deleteBtn.onclick = () => container.remove();
            container.appendChild(deleteBtn);

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
         }


        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true;
            loadingSpinner.style.display = 'block';
            appendMessage("user", { type: 'text', text: message });

            // 입력창 자동 지우기
            userInput.value = '';
            // textarea 높이 초기화 (min-height 유지)
            autoResizeTextarea.call(userInput);


            conversationHistory.push({
                role: "user",
                messageData: { type: 'text', text: message }
            });
            try {
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text')
                    .map(entry => ({
                        role: entry.role,
       
                        parts: [{ text: entry.messageData.text }]
                    }));
                const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];
                if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                     // console.log("Only SYSTEM_PROMPT to send to API."); // 콘솔 로그 제거
                } else if (contentsForApi.length === 0) {
                     // console.log("No content to send to API."); // 콘솔 로그 제거
                     appendMessage("bot", { type: 'text', text: "(메시지 전송 실패: 보낼 텍스트 내용 없음)" });
                     return Promise.resolve();
                }

                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",


             
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }

        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");
            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 actionMenuButton.disabled = true;

                 appendMessage("user", { type: 'image', url: imageUrl.trim() });
                 conversationHistory.push({
                     role: "user",
                     messageData: { type: 'image', url: imageUrl.trim() }
                 });
                 sendButton.disabled = false;
                 userInput.disabled = false;
                 actionMenuButton.disabled = false;
                 userInput.focus();
            } else if (imageUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }

        // changeProfileImage 함수 삭제 (액션 메뉴 버튼 제거)
        /*
        function changeProfileImage(role) {
             const promptText = role === 'user' ?
 "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 캐릭터 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);
             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') {
                     userProfileImgUrl = newUrl.trim();
                 } else {
                     botProfileImgUrl = newUrl.trim();
                 }
                 alert(`${role === 'user' ? '사용자' : '캐릭터'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
             } else if (newUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }
        */


        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");
             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true;
             loadingSpinner.style.display = 'block';
             // 상황 생성 요청 프롬프트에도 포맷 지침 추가
const situationPromptText = `Based on the ongoing scene and character relationship, create a vivid, erotic, and emotionally charged new situation or event that naturally continues the previous context.
This scene must be written **entirely in Korean**, and from the character {botName}'s exclusive third-person point of view.
The response must strictly follow this format:

- *서술 묘사 문단*  
- "대사"  
- *서술 묘사 문단*  
- "대사"  
- *서술 문단* (줄바꿈 사용)

Use **double quotes (" ") for ALL spoken dialogue**.  
Use **single asterisks (`*`) to wrap ALL action, emotion, and sensory narration**.

**Do NOT use bold, slashes, or any other formatting style.**  
Do NOT mix dialogue and narration in a single paragraph.  
Each paragraph must be either only narration (*inside asterisks*) or only dialogue (inside quotes).  
Narrative flow must be 70% descriptive narration and 30% spoken dialogue.

{botName} must act proactively in this situation—take initiative, escalate the scene, and create pressure, heat, or intimacy.  
There must be movement: shift in position, rhythm, mental state, or physical interaction.

This situation must **immediately lead to a line of dialogue directed at {userName}**, to naturally continue the RP.

NEVER use the words “캐릭터” or “사용자” in the response.  
Use the actual names {botName} and {userName}.  
NEVER write out-of-character (OOC) or use any explanation text. Output must feel like a real scene.
`;
             // 프롬프트 변경
             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text')
                 .map(entry => ({
                    role: entry.role,
                    parts: [{ text: entry.messageData.text }]
         }));
             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText }] }];
             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                 // console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API."); // 콘솔 로그 제거
             } else if (contentsForApi.length === 0) {
                 // console.log("No content to send to API."); // 콘솔 로그 제거
                 appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                 return Promise.resolve();
             }


            try {
                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",


                         headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                // 응답이 성공적이지 않다면 (오류라면)
                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);

                    const errorText =
                        errorData?.error?.error?.message ||
                        errorData?.error ||
                        res.statusText;

                    appendMessage("bot", {
                        type: 'text',
                        text: `(오류 발생: ${res.status} - ${errorText})`
                    });
                } else { // 응답이 성공적이라면
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }

        // loadSettings 함수 수정: 슬롯 번호를 인자로 받아 해당 슬롯의 설정을 로드
        function loadSettings(slotNumber) {
             // console.log(`loadSettings 호출됨 - 슬롯 ${slotNumber}`); // 콘솔 로그 제거
             // 수정된 로직: 슬롯 버튼 클릭 시 currentSlot 및 스타일 업데이트는 항상 실행
             currentSlot = slotNumber; // 현재 슬롯 업데이트
             updateSlotButtonStyles(); // 슬롯 버튼 스타일 업데이트

             const settingsKey = `settings_slot_${slotNumber}`;
             const savedSettings = localStorage.getItem(settingsKey);

             if (savedSettings) {
                 try {
                     const settings = JSON.parse(savedSettings);
                     botNameInput.value = settings.botName || ''; // 기본값 변경
                     userNameInput.value = settings.userName ||
 ''; // 기본값 변경
                     botPersonaInput.value = settings.botPersona ||
 ''; // 기본값 변경
                     botAgeInput.value = settings.botAge ||
 ''; // 기본값 변경
                     userAgeInput.value = settings.userAge ||
 ''; // 기본값 변경
                     userAppearanceInput.value = settings.userAppearance ||
 ''; // 기본값 변경
                     botAppearanceInput.value = settings.botAppearance ||
 ''; // 기본값 변경
                     userGuidelinesInput.value = settings.userGuidelines ||
 ''; // 기본값 변경
                     // 이미지 URL 입력 필드 값 로드
                     botImageUrlInput.value = settings.botImageUrl ||
 '';
                     userImageUrlInput.value = settings.userImageUrl || '';


                     // 프로필 이미지 URL 변수 업데이트 (입력 필드 값 > 저장된 값 > 기본값 순)
                     userProfileImgUrl = userImageUrlInput.value ||
 settings.userProfileImgUrl || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
                     botProfileImgUrl = botImageUrlInput.value || settings.botProfileImgUrl || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";
                     SYSTEM_PROMPT = buildSystemPrompt(
                         botNameInput.value,
                         userNameInput.value,
                         botPersonaInput.value,
                       
                         botAgeInput.value,
                         botAppearanceInput.value,

                         userAgeInput.value,
                         userAppearanceInput.value,
                       
                         userGuidelinesInput.value
                     );
                     // console.log(`SYSTEM_PROMPT 로드 완료 - 슬롯 ${slotNumber}:`, SYSTEM_PROMPT); // 콘솔 로그 제거
                     // currentSlot 업데이트와 스타일 업데이트는 함수 초반에서 이미 했습니다.
                     // alert(`${slotNumber}번 슬롯의 설정을 불러왔습니다.`); // 알림 제거

                 } catch (e) {
                     console.error(`Failed to parse settings from slot ${slotNumber}:`, e);
                     // alert(`${slotNumber}번 슬롯 설정을 불러오는데 실패했습니다. 데이터가 손상되었을 수 있습니다.`); // 알림 제거
                     loadDefaultSettings(); // 기본 설정 로드 시도 (currentSlot/스타일은 그대로)
                 }
             } else {
                 // 저장된 설정이 없으면 기본 설정 로드
                 // console.log(`슬롯 ${slotNumber}에 저장된 설정이 없습니다. 기본 설정을 로드합니다.`); // 콘솔 로그 제거
                 loadDefaultSettings(); // 이 함수 내에서는 currentSlot이나 스타일 변경하지 않음
                 // alert(`${slotNumber}번 슬롯에 저장된 설정이 없습니다. 기본 설정을 로드했습니다.`); // 알림 추가
             }
        }

        // saveSettings 함수 수정: 현재 활성화된 슬롯에 설정 저장
        function saveSettings(slotNumber) {
             // console.log(`saveSettings 호출됨 - 슬롯 ${slotNumber}`); // 콘솔 로그 제거
             const settingsToSave = {
                 botName: botNameInput.value.trim(),
                 userName: userNameInput.value.trim(),
                 botPersona: botPersonaInput.value.trim(),
                 botAge: botAgeInput.value.trim(),
         
                 userAge: userAgeInput.value.trim(),
                 userAppearance: userAppearanceInput.value.trim(),
                 botAppearance: botAppearanceInput.value.trim(),
                 userGuidelines: userGuidelinesInput.value.trim(),
                 // 이미지 URL 입력 필드 값 저장
              
                 botImageUrl: botImageUrlInput.value.trim(),
                 userImageUrl: userImageUrlInput.value.trim(),
                 // 프로필 이미지 URL 변수 값도 함께 저장 (혹시 모를 경우 대비)
                 userProfileImgUrl: userProfileImgUrl,
                 botProfileImgUrl: botProfileImgUrl

             };
             try {
                 const jsonString = JSON.stringify(settingsToSave);
                 localStorage.setItem(`settings_slot_${slotNumber}`, jsonString);
                 // currentSlot 업데이트와 스타일 업데이트는 슬롯 로드 시에만 합니다.
                 // alert(`${slotNumber}번 슬롯에 현재 설정이 저장되었습니다.`); // 알림 제거
                 // console.log(`슬롯 ${slotNumber}에 설정 저장 완료`); // 콘솔 로그 제거
             } catch (e) {
                  console.error(`Failed to save settings to slot ${slotNumber}:`, e);
                  // alert(`${slotNumber}번 슬롯에 설정을 저장하는데 실패했습니다.`); // 알림 제거
             }
        }

        // 기본 설정을 로드하는 함수 (저장된 설정이 없거나 로드 실패 시 사용)
        // 기본값을 빈 값 또는 일반적인 플레이스홀더로 수정
        function loadDefaultSettings() {
             // console.log("기본 설정 로드"); // 콘솔 로그 제거
            botNameInput.value = ''; // 빈 값으로 변경
            userNameInput.value = ''; // 빈 값으로 변경
            botPersonaInput.value = '캐릭터의 성격, 배경, 말투, 행동 지침 등을 입력하세요.'; // 일반적인 플레이스홀더
            botAgeInput.value = ''; // 빈 값으로 변경
            userAgeInput.value = ''; // 빈 값으로 변경
            userAppearanceInput.value = '사용자의 외관을 입력하세요.'; // 일반적인 플레이스홀더
            botAppearanceInput.value = '캐릭터의 외관을 입력하세요.'; // 일반적인 플레이스홀더
            userGuidelinesInput.value = '사용자 캐릭터의 지침을 입력하세요 (예: 나는 어떤 사람인지 등).'; // 일반적인 플레이스홀더
            // 이미지 URL 기본값 설정
            botImageUrlInput.value = ''; // 기본값 빈 값
            userImageUrlInput.value = ''; // 기본값 빈 값

            // 프로필 이미지 변수는 기본 placeholder URL로 초기화
            userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
            botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";


            SYSTEM_PROMPT = buildSystemPrompt(
                botNameInput.value,
                userNameInput.value,
                botPersonaInput.value,
                botAgeInput.value,
                botAppearanceInput.value,
               
                userAgeInput.value,
                userAppearanceInput.value,
                userGuidelinesInput.value
            );
            // currentSlot과 스타일 업데이트는 loadSettings에서 이미 처리했습니다.
            // alert("기본 설정을 로드했습니다."); // 불필요한 알림 제거
        }


         function buildSystemPrompt(botName, userName, botPersona, botAge, botAppearance, userAge, userAppearance, userGuidelines) {
             // 범용적인 템플릿 사용 (이안 관련 내용 제거됨)
             let finalPrompt = SYSTEM_PROMPT_TEMPLATE
    .replaceAll('{botName}', botName || '이안')
    .replaceAll('{botAge}', botAge || '불명')
    .replaceAll('{botAppearance}', botAppearance || '설정되지 않음')
    .replaceAll('{botPersona}', botPersona || '설정된 페르소나 없음.')
    
    .replaceAll('{userName}', userName || '피주머니')
    .replaceAll('{userAge}', userAge || '불명')
    .replaceAll('{userAppearance}', userAppearance || '설정되지 않음')
    .replaceAll('{userGuidelines}', userGuidelines || '설정된 사용자 지침 없음.');
             return finalPrompt.trim();
         }

         // 슬롯 버튼 활성/비활성 스타일 업데이트
         function updateSlotButtonStyles() {
             slotButtons.forEach(button => {
                 if (parseInt(button.textContent) === currentSlot) {
                     button.classList.add('active');
                
                 } else {
                     button.classList.remove('active');
                 }
             });
         }


        function initializeChat() {
             // console.log("initializeChat 호출됨"); // 콘솔 로그 제거
             loadSettings(1); // 페이지 로드 시 1번 슬롯의 설정 로드 (currentSlot 및 스타일 업데이트 포함)

             // 초기 대화 메시지 전송 (SYSTEM_PROMPT 포함)
             // conversationHistory는 loadSettings에서 업데이트된 SYSTEM_PROMPT를 사용해야 하므로 initializeChat에서 설정
             const initialContents = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }];
             // SYSTEM_PROMPT만 보내는 것이 아니라, 초기 봇 인사말도 함께 보내야 한다면 여기에 추가 로직 필요
             // 현재 로직은 SYSTEM_PROMPT만 초기 메시지로 보내고 있습니다.
             // 초기 봇 인사말은 화면에만 표시하고 AI에게는 보내지 않는 방식입니다.

             // console.log("초기 SYSTEM_PROMPT:", SYSTEM_PROMPT); // 콘솔 로그 제거

             // console.log("초기 메시지 추가 시도"); // 콘솔 로그 제거
             // 초기 공지 메시지 및 구분선 추가
             const initialNoticeText = `채팅을 시작합니다. 캐릭터와 사용자 설정을 확인해주세요.`;
             const noticeElement = document.createElement('div');
             noticeElement.className = 'initial-notice';
             noticeElement.textContent = initialNoticeText;
             chat.appendChild(noticeElement); // chat div에 공지 추가

             const dividerElement = document.createElement('div');
             dividerElement.className = 'notice-divider';
             chat.appendChild(dividerElement); // chat div에 구분선 추가

             // console.log("채팅 초기화 완료."); // 콘솔 로그 제거

             // 페이지 로드 후 바로 AI 응답을 받으려면 여기에 첫 sendMessage 호출 로직 추가 필요
             // 예: sendMessage("초기 인사말에 대한 AI의 응답을 유도하는 텍스트");
             // 현재 로직은 사용자가 첫 메시지를 보낼 때까지 AI에게는 SYSTEM_PROMPT 외에 아무것도 보내지 않습니다.
         }

         // textarea 높이 자동 조절 기능 추가
         function autoResizeTextarea() {
             const minHeight = parseFloat(getComputedStyle(this).minHeight); // CSS에서 설정된 min-height 값을 가져옴
             this.style.height = 'auto'; // 높이 초기화
             // 스크롤 높이가 최소 높이보다 크면 스크롤 높이로, 아니면 최소 높이로 설정
             this.style.height = Math.max(minHeight, this.scrollHeight) + 'px';
             this.scrollTop = this.scrollHeight; // 항상 맨 아래로 스크롤
         }

        userInput.addEventListener('input', autoResizeTextarea, false);


        initializeChat();

        function openImageOverlay(thumbnail) {
  const overlay = document.getElementById("imageOverlay");
  const overlayImage = document.getElementById("overlayImage");
  overlayImage.src = thumbnail.src;
  overlay.style.display = "flex";
}

function closeImageOverlay() {
  const overlay = document.getElementById("imageOverlay");
  const overlayImage = document.getElementById("overlayImage");
  overlay.style.display = "none";
  overlayImage.src = "";
}

        document.addEventListener("DOMContentLoaded", () => {
  document.querySelectorAll(".profile-img").forEach(img => {
    img.addEventListener("click", () => {
      openImageOverlay(img);
    });
  });
});
        function openImageOverlay(thumbnail) {
  const overlay = document.getElementById("imageOverlay");
  const overlayImage = document.getElementById("overlayImage");
  overlayImage.src = thumbnail.src;
  overlay.style.display = "flex";
}

function closeImageOverlay() {
  const overlay = document.getElementById("imageOverlay");
  const overlayImage = document.getElementById("overlayImage");
  overlay.style.display = "none";
  overlayImage.src = "";
}


    </script>
    <div id="imageOverlay" class="overlay" onclick="closeImageOverlay()">
  <img id="overlayImage" src="" />
</div>

    <div id="imageOverlay" class="overlay" onclick="closeImageOverlay()">
        <img id="overlayImage" src="" />
</div>

    

</body>
</html>
