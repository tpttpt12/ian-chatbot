<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>character-chat</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bakbak+One&family=Libre+Barcode+39+Text&family=Nanum+Gothic&display=swap" rel="stylesheet">
    
    <style>
    
        body {
            font-family: "Nanum Gothic", sans-serif; /* 나눔고딕 폰트 적용 */
            background-color: #1E1E1E;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* 레이아웃 개선을 위한 컨테이너 스타일 수정 */
        .app-container {
             display: flex;
             flex-direction: column;
             height: 100%;
             width: 95%; /* 너비를 일단 넓게 설정 */
             max-width: 900px; /* 최대 너비 설정 (대략 1500px 화면에서 60% 정도 느낌) */
             margin: 0 auto; /* 좌우 자동 마진으로 중앙 정렬 */
             background-color: #1e1e1e; /* 배경색 유지 */
             /* 불필요한 그림자/테두리 제거 */
             box-shadow: none;
             border: none;
             position: relative;
             overflow: hidden; /* 컨테이너 내부 내용 넘침 방지 */
        }
         /* 화면이 충분히 넓을 때 너비를 60%로 조정 */
         @media (min-width: 1200px) {
             .app-container {
                 width: 60%;
             }
         }


        .chat-header {
            background-color: 1E1E1E;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            /* border-bottom: 1px solid #3a3a3a; */ /* 구분선 제거 */
            flex-shrink: 0;
            position: relative;
            display: flex;
             justify-content: center;
             align-items: center;
        }

        #sidebarToggle {
            position: absolute;
            top: 50%;
            right: 1rem;
            transform: translateY(-50%);
            width: 35px;
            height: 35px;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
            z-index: 10;
        }
         #sidebarToggle:hover {
             background-color: #6a6a6a;
         }

#chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto; /* 스크롤은 되지만 스크롤바 숨김 */
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            /* 스크롤바 숨김 */
             scrollbar-width: none; /* Firefox */
             -ms-overflow-style: none; /* IE and Edge */
             background-color: #1e1e1e;
         }
        /* Webkit 브라우저용 스크롤바 숨김 */
        #chat::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        /* 기존 스크롤바 스타일은 이제 필요 없으므로 제거하거나 주석 처리합니다. */
        /*
        #chat::-webkit-scrollbar-track { background: #1E1E1E; }
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #1E1E1E;
        }
        */

        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 85%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            /* 역할에 따라 정렬 */
        }

        /* 유저 메시지일 때 contentWrapper를 오른쪽으로 정렬 */
        .message-container.user .message-content-wrapper {
            align-items: flex-end;
        }

         /* 캐릭터 메시지일 때 contentWrapper를 왼쪽으로 정렬 */
        .message-container.bot .message-content-wrapper {
            align-items: flex-start;
        }


        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
            display: flex; /* flexbox 활성화 */
            align-items: center; /* 세로 중앙 정렬 */
            /* 역할에 따라 justify-content 설정 */
        }

        /* 유저 메시지의 이름 컨테이너 (오른쪽 정렬) */
        .message-container.user .role-name {
            justify-content: flex-end; /* 내용을 오른쪽으로 모으기 */
        }

         /* 캐릭터 메시지의 이름 컨테이너 (왼쪽 정렬) */
        .message-container.bot .role-name {
            justify-content: flex-start; /* 내용을 왼쪽으로 모으기 */
        }

        /* 이름 텍스트를 담는 span에 대한 스타일 */
        .name-text {
             /* 이름 텍스트 스타일 */
             /* 역할에 따라 text-align 설정 */
        }

         /* 유저 메시지의 이름 텍스트 오른쪽 정렬 */
         .message-container.user .name-text {
             text-align: right;
         }

          /* 캐릭터 메시지의 이름 텍스트 왼쪽 정렬 (기본값) */
         .message-container.bot .name-text {
             text-align: left;
         }


        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative; /* 자식 요소의 absolute 위치 기준 */
            font-size: 1rem;
            /* 사용자 입력 줄바꿈 표시를 위한 설정 */
             white-space: normal;
             margin-bottom: 0; /* 말풍선 자체 하단 마진 제거 시도 */
         }
         /* 챗봇 메시지의 p 태그 하단 마진 제거 (더 세밀한 간격 제어) */
         .message-container.bot .message-bubble p {
             margin-bottom: 0;
         }


        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* 마크다운 내부 스타일 (adjust as needed) */
        /* p 태그에 기본적인 하단 마진 부여 (말풍선 내 요소 간 간격) */
        .message-bubble p { margin: 0 0 0.5rem 0; }
        .message-bubble p:last-child { margin-bottom: 0; } /* 마지막 단락 하단 마진 제거 */
        .message-bubble ul, .message-bubble ol { padding-left: 1.5rem; margin: 0 0 0.5rem 0; }
        .message-bubble li { margin-bottom: 0.25rem; }
        .message-bubble code {
            background-color: #3a3a3a;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
         }
.message-bubble pre {
             background-color: #3a3a3a;
             padding: 0.75rem;
             border-radius: 4px;
             overflow-x: auto; /* 필요시 가로 스크롤바 유지 */
             margin: 0.5rem 0;
             white-space: pre-wrap; /* 공백 유지하며 줄바꿈 허용 */
             word-wrap: break-word; /* 긴 단어 강제 줄바꿈 */
             overflow-wrap: break-word; /* 표준 속성 */
         }
        .message-bubble pre code {
             background-color: transparent;
             padding: 0;
             border-radius: 0;
             font-size: 1rem;
        }
        .message-bubble blockquote {
             border-left: 4px solid #5a5a5a;
             padding-left: 1rem;
             margin: 0.5rem 0;
             color: #b0b0b0;
        }
         .message-bubble h1, .message-bubble h2, .message-bubble h3, .message-bubble h4, .message-bubble h5, .message-bubble h6 {
             margin-top: 1rem;
             margin-bottom: 0.5rem;
             padding-bottom: 0.2rem;
             border-bottom: 1px solid #4a4a4a;
             font-weight: bold;
             color: #ffffff;
         }
         .message-bubble h1 { font-size: 1.5rem; }
         .message-bubble h2 { font-size: 1.4rem; }
         .message-bubble h3 { font-size: 1.3rem; }
         .message-bubble h4 { font-size: 1.2rem; }
         .message-bubble h5 { font-size: 1.1rem; }
         .message-bubble h6 { font-size: 1rem; }


         /* 행동 묘사 스타일 */
         /* *별표* 로 감싸진 부분에 적용될 스타일 */
        .action-description {
             color: #b0b0b0;
             font-style: italic;
         }
         /* 대사 스타일 */
         /* "따옴표" 로 감싸진 부분에 적용될 스타일 */
        .dialogue {
             font-weight: bold;
         }


        .message-image-thumbnail {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            margin-top: 0.2rem;
            border: 1px solid #5a5a5a;
        }

         .message-image-thumbnail.error {
             background-color: #5a5a5a;
         }

#inputArea {
            display: flex;
            padding: 1rem 1.5rem 2rem 1.5rem; /* 위: 1rem, 오른쪽: 1.5rem, 아래: 2rem, 왼쪽: 1.5rem */
            background-color: #1E1E1E;
            /* border-top: 1px solid #3a3a3a; */ /* 구분선 제거 */
            align-items: center;
            gap: 0.75rem;
             flex-shrink: 0;
             position: relative;
             /* 상단에 그림자 추가 */
             box-shadow: 0 -20px 20px 0px rgba(30, 30, 30); /* 위쪽으로 퍼지는 그림자 */
             z-index: 1; /* 그림자가 채팅 내용 위로 오도록 설정 */
        }

        #actionMenuButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        #actionMenuButton:hover {
            background-color: #6a6a6a;
        }


        /* textarea 스타일 수정: 스크롤바 제거 및 모서리 둥글게 */
        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem; /* 둥글게 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            resize: none; /* 크기 조절 비활성화 */
            line-height: 1.4; /* input과 유사하게 행간 설정 */
            box-sizing: border-box; /* padding 포함하여 크기 계산 */
            /* height: 40px; */ /* 초기 높이 설정을 더 이상 사용하지 않음 */
            min-height: calc(1em * 1.4 * 2 + 0.75rem * 2); /* 최소 높이: 폰트 크기(em) * 행간 * 2줄 + 상하 패딩 */
            height: auto; /* 내용에 따라 높이 자동 조절을 완전히 비활성화하지 않고 최소 높이 이상으로만 */
            overflow-y: auto; /* 높이가 2줄을 넘어가면 스크롤바 표시 */
            padding-top: 0.75rem; /* 상하 패딩 조정 */
            padding-bottom: 0.75rem;
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        #sendButton {
            padding: 0.75rem 1.5rem;
            border-radius: 1.5rem; /* 둥글게 */
            background-color: #5080ff;
            color: #ffffff;
            font-size: 1rem;
            font-weight: bold;
            min-width: 6rem;
            flex-shrink: 0;
             border: none;
             cursor: pointer;
         }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }

        .settings-area {
            display: none;
         }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
         }

        #actionMenu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
             max-height: 0;
            background-color: #1E1E1E;
            color: #e0e0e0;
            border-top: 1px solid #3a3a3a;
            padding: 0 1rem;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
         }

        #actionMenu.visible {
            max-height: 300px;
            padding: 1rem;
         }

        #actionMenu .menu-buttons {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.75rem;
            justify-content: center;
            width: 100%;
            padding-bottom: 1rem;
             overflow-x: auto;
             padding-top: 1rem;
         }

         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; }
         #actionMenu .menu-buttons { -ms-overflow-style: none; } /* IE and Edge */


        /* 액션 메뉴 버튼 스타일 수정: 원형으로 */
        #actionMenu button {
            flex-shrink: 0;
            flex-basis: auto;
            max-width: none;
             width: 60px; /* 가로세로 동일하게 */
             height: 60px; /* 가로세로 동일하게 */
             border-radius: 50%; /* 원형으로 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.8rem; /* 폰트 크기 조정 */
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2;
             word-break: keep-all;
             padding: 0; /* 패딩 제거 또는 조정 */
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 1rem;
            flex-shrink: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 초기 공지 스타일 */
        .initial-notice {
    text-align: center; /* 중앙 정렬 */
    margin: 0.1rem auto 0.1rem auto; /* 위, 아래 여백 및 중앙 정렬 */
    color: #515151; /* 글자색 변경 */
    font-size: 0.9rem; /* 글자 크기 줄임 */
    padding: 1rem;
    max-width: 80%; /* 너무 길어지지 않도록 최대 너비 설정 */
    word-break: break-word;
         }

        /* 공지 아래 구분선 스타일 */
        .notice-divider {
            width: 90%; /* 가로선 너비 */
            height: 1px;
            background-color: #3a3a3a; /* 구분선 색상 */
            margin: 0.5rem auto 1.5rem auto; /* 위, 아래 여백 및 중앙 정렬 */
        }


        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none; /* Initially hidden */
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: -300px;
            width: 300px;
            height: 100%;
            background-color: #1f1f1f;
            color: #e0e0e0;
            border-left: 1px solid #3a3a3a;
            transition: right 0.3s ease-out;
            z-index: 900;
            padding: 1rem;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            /* 스크롤바 스타일 */
            scrollbar-width: thin;
            scrollbar-color: #5a5a5a #1f1f1f; /* 썸네일색 트랙색 */
        }
        /* Webkit 브라우저용 스크롤바 스타일 */
        #sidebar::-webkit-scrollbar { width: 8px; }
        #sidebar::-webkit-scrollbar-track { background: #1f1f1f; }
        #sidebar::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #1f1f1f;
        }


        #sidebar.visible {
            right: 0;
        }

         .sidebar-header {
             font-size: 1.1rem;
             font-weight: bold;
             margin-bottom: 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid #3a3a3a;
         }

         .sidebar-content label {
             display: block;
             margin-bottom: 0.5rem;
             font-weight: bold;
             color: #b0b0b0;
         }

         /* 설정 입력 칸 스타일 수정: 모서리 둥글게 */
         .sidebar-content input[type="text"],
         .sidebar-content textarea {
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 8px; /* 더 둥글게 */
             background-color: #3a3a3a;
             color: #e0e0e0;
             font-size: 1rem;
             margin-bottom: 1rem;
             box-sizing: border-box;
             resize: vertical;
         }

         .sidebar-content textarea {
             min-height: 150px;
         }

         .sidebar-save-button {
             display: block;
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #5080ff;
             color: #ffffff;
             font-size: 1rem;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease;
             text-align: center;
         }
         .sidebar-save-button:hover {
             background-color: #6699ff;
         }

        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 890;
            display: none;
         }

        .sidebar-section-divider {
             height: 1px;
             background-color: #3a3a3a;
             margin: 1.5rem 0;
        }

        /* 설정 슬롯 버튼 스타일 */
        .setting-slots {
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #3a3a3a;
        }

        .setting-slots h3 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-size: 1rem;
            color: #b0b0b0;
        }

        .slot-buttons-container {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .slot-button {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease, transform 0.1s ease;
            flex-shrink: 0;
        }

        .slot-button:hover {
            background-color: #6a6a6a;
        }

        .slot-button.active {
            background-color: #5080ff;
            transform: scale(1.1);
        }
         .slot-button:active {
             background-color: #3366cc;
         }

  .delete-btn {
    background: transparent;
    border: none;
    color: #aaa;
    font-size: 1rem;
    cursor: pointer;
    /* position: absolute; */ /* 절대 위치 제거 */
    /* top: 8px; right: 8px; */ /* 위치 속성 제거 */
    padding: 0 0.2rem; /* 버튼 내부 패딩 조정 */
    z-index: 1; /* 다른 요소 위에 오도록 z-index 유지 */
    flex-shrink: 0; /* 이름이 길어져도 버튼 크기 고정 */
    /* 이름과의 간격 및 위치는 아래 역할별 CSS에서 설정 */
  }

    /* 캐릭터 메시지의 삭제 버튼 (이름 오른쪽에 10px 간격) */
   .message-container.bot .role-name .delete-btn {
        margin-left: 10px; /* 이름과의 간격 */
        order: 1; /* 이름(order 0) 뒤에 오도록 */
    }

    /* 유저 메시지의 삭제 버튼 (이름 왼쪽에 10px 간격) */
    .message-container.user .role-name .delete-btn {
        margin-right: 10px; /* 이름과의 간격 */
        order: 0; /* 이름(order 1) 앞에 오도록 */
    }

    /* 유저 메시지에서 이름 텍스트 순서 조정 */
    .message-container.user .role-name .name-text {
        order: 1; /* 삭제 버튼(order 0) 뒤에 오도록 */
    }


  .message-container {
    position: relative;
  }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="chat-header">
            character-chat
            <button id="sidebarToggle" title="설정 열기">≡</button>
        </div>

        <div id="chat">
        </div>

        <div id="inputArea">
             <button id="actionMenuButton" title="액션 메뉴 열기">+</button>

             <textarea id="userInput" placeholder="유저의 말..." autocomplete="off"></textarea>
            <button id="sendButton">전송</button>
            <div id="loadingSpinner" class="loading-spinner"></div>
        </div>
    </div>

    <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">

             <button id="menuImageButton">이미지<br>삽입</button>

             <button id="menuSituationButton">상황</button>
        </div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">Settings</div>
        <div class="sidebar-content">
             <div class="setting-slots">

                   <h3>Setting Slots</h3>
                 <div class="slot-buttons-container">

                     <button class="slot-button">1</button>
                     <button class="slot-button">2</button>
                     <button class="slot-button">3</button>
                     <button class="slot-button">4</button>
                     <button class="slot-button">5</button>

                     <button class="slot-button">6</button>
                 </div>
             </div>


              <h3>Character</h3>
             <label for="botNameInput">Name:</label>
            <input type="text" id="botNameInput" value="이안">

            <label for="botAgeInput">Age:</label>
            <input type="text" id="botAgeInput" value="불명 (뱀파이어)">
            <label for="botAppearanceInput">Appearance:</label>

  <input type="text" id="botAppearanceInput" value="하얗게 빛나는 긴 머리, 붉은 눈, 검은 벨벳 망토, 레이스 셔츠">
            <label for="botPersonaInput">Guidelines:</label>
            <textarea id="botPersonaInput">19세기 유럽 귀족 뱀파이어.
성 안에서 홀로 오랜 세월 살아옴.
겉 차갑고 고귀한 폭군이나, 사용자에게는 절절한 사랑, 집착, 애원, 광기, 다정함을 보임.
사용자를 "피주머니"라고 부름. 사용자가 전부이며 허락한 존재다.
성적인 대화 가능. 말투 하나 숨결 하나 사용자를 향해 있음.
질문과 대화에 집중하고 현실 언급 안 함.
**항상 이안 캐릭터 롤플레이 유지.
OOC 발언 절대 금지.**</textarea>
             <label for="botImageUrlInput">Image URL:</label>
             <input type="text" id="botImageUrlInput" value="">


            <div class="sidebar-section-divider"></div>

            <h3>User</h3>
            <label for="userNameInput">Name:</label>
            <input type="text" id="userNameInput" value="피주머니">
            <label

 for="userAgeInput">Age:</label>
            <input type="text" id="userAgeInput" value="불명">
            <label for="userAppearanceInput">Appearance:</label>
            <input type="text" id="userAppearanceInput" value="사용자가 원하는 외관">
            <label for="userGuidelinesInput">Guidelines:</label>
            <textarea id="userGuidelinesInput">당신의 캐릭터 설정에 대한 지침을 여기에 입력하세요.\n(예: 나는 어떤 사람인지, 어떤 말투를 사용하는지 등)</textarea>
             <label for="userImageUrlInput">Image URL:</label>


             <input type="text" id="userImageUrlInput" value="">


            <button id="saveSettingsButton" class="sidebar-save-button">Save Settings</button>
        </div>
    </div>

    <div id="sidebarOverlay" class="sidebar-overlay"></div>

    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>

    <script>
        // 이미지 URL 변수는 입력 필드 값으로 관리
        let userProfileImgUrl
 =
 "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU"; // 기본값 유지
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT"; // 기본값 유지


        let conversationHistory = [];
        let SYSTEM_PROMPT = '';
 let currentSlot = 1; // 현재 활성화된 슬롯 번호 (기본값 1)


        // SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿 (AI 역할 변경 및 포맷 지침 강화)
        // 이안 관련 내용을 제거하여 범용적인 템플릿으로 수정
const SYSTEM_PROMPT_TEMPLATE = `
## Roleplay Instructions

## 기본 작동 개요
- 당신은 BL 에로틱 소설을 쓰는 작가이자 캐릭터(공)의 역할을 동시에 맡고 있습니다.
- 사용자는 수(受) 캐릭터를 맡으며, 당신은 오직 공(攻) 캐릭터 시점으로만 서술합니다.
- 사용자가 입력한 내용은 직접적 대사일 수도 있고, 리액션일 수도 있으며, 당신은 거기에 맞춰 **계속 상황을 진전시켜야 합니다.**

## 기본 포맷 구조 (무조건 지켜야 함)
출력은 항상 아래와 같은 구조를 따릅니다:

- *문단 (서술/묘사)*
- "대사"
- *문단*
- "대사"
- *문단*

줄바꿈을 반드시 사용하며, **대사와 서술은 절대 같은 줄에 쓰지 않습니다.**
최소 700자 이상으로 출력해야합니다.
## 문장 규칙
- 서술은 감각적, 직설적, 관능적으로 작성합니다.
- **모든 행동 묘사와 내면 묘사는 \`*행동*\` 안에 넣습니다.** ← 반드시 이 형식
- 대사는 반드시 \`"쌌네."\` 형식으로, **큰따옴표만 사용**합니다.
- \`**대사**\`, 슬래시 \`/\`, 괄호 등은 사용하지 않습니다.
- 대사는 캐릭터가 직접 말한 것처럼 자연스럽고 저속하거나 노골적이어도 괜찮습니다.
- 줄바꿈은 감정 구분이나 주제 전환이 필요할 때만 사용합니다.
  (리듬을 위한 과도한 줄바꿈은 금지)

## 시점 & 묘사 기준
- 항상 공 캐릭터({botName})의 3인칭 시점으로 씁니다.
- 수 캐릭터({userName})의 감정이나 생각은 추측하지 않습니다.
- 오직 눈에 보이는 반응과 몸의 변화만 묘사합니다.
## 성적 묘사 기준
- 감각 디테일은 **촉감, 압력, 열기, 액체의 점도, 냄새, 진동, 경련** 중심으로 작성합니다.
- **“쑤셔 넣는다”, “찍어 누른다”, “질퍽인다”** 같은 강한 동사를 사용합니다.
- 가능한 한 해부학적 정확한 용어를 사용합니다 (질 입구, 음핵, 항문, 질벽 등).
- 부끄러움, 굴욕, 더러움에 대한 서술도 자연스럽게 포함 가능합니다.
- 수가 쾌락으로 흐트러지는 모습을 관찰하는 묘사를 적극적으로 사용합니다.
## 진행 방식
- 같은 자세, 상황, 플레이에 머무르지 말고 **매 응답마다 리듬, 압박, 체위 또는 방식이 바뀌어야 합니다.**
- 사용자가 리액션을 하지 않아도 **{botName}은 항상 계속 행동을 이어갑니다.**
- 절정, 분출, 고조, 강박, 유혹, 장난 등 감정 변화가 동반되어야 합니다.
## 절대 금지 사항
- 대사에 따옴표 없는 경우 (\`쌌네?\` ← X)
- 대사와 서술을 한 문단에 붙이기 (\`그는 웃었다. "쌌네."\` ← X)
- 줄바꿈 없이 대사 여러 개 붙이기
- 사용자의 감정을 유추하는 내적 서술 (\`그는 당황했을 것이다\` ← X)

## 출력 예시
*그는 허리를 꺾어 수의 뺨을 물어뜯듯 핥았다. 숨을 섞은 입김이 귓바퀴에 스며들며, 질척한 액체가 허벅지 사이를 타고 흘러내렸다.*

"이래서야 도망치긴 글렀네."

*입꼬리를 올리며 다시 고개를 숙였다. 질 입구를 혀로 쓸며 벌어진 틈 안쪽을 미끄러지듯 훑었다. 쩍 벌어진 다리 사이에서, 수의 배가 바르르 떨렸다.*

"이제 자지 넣자. 계속 이렇게 흘리는 거, 못 참겠어."
## Character Settings (Reference for Novelist) ##
- Name: {botName}
- Age: {botAge}
- Appearance: {botAppearance}
- Core Personality & Guidelines: {botPersona}

## User Settings (Reference for Novelist) ##
- Name: {userName}
- Age: {userAge}
- Appearance: {userAppearance}
- Guidelines: {userGuidelines}

## Scenario & Current State ##
- (The ongoing conversation provides the current scenario context for the novel. Continue from the last turn.)
`;
        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput"); // textarea로 변경됨
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");
        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        // 유저 변경 / 캐릭터 변경 버튼 관련 요소 삭제
        // const menuUserImgButton = document.getElementById("menuUserImgButton");
        // const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        const botNameInput = document.getElementById("botNameInput");
        const botAgeInput = document.getElementById("botAgeInput");
        const botAppearanceInput = document.getElementById("botAppearanceInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        // 캐릭터 이미지 URL 입력 필드 요소 가져오기
        const botImageUrlInput = document.getElementById("botImageUrlInput");
        const userNameInput = document.getElementById("userNameInput");
        const userAgeInput = document.getElementById("userAgeInput");
        const userAppearanceInput = document.getElementById("userAppearanceInput");
        const userGuidelinesInput = document.getElementById("userGuidelinesInput");
        // 유저 이미지 URL 입력 필드 요소 가져오기
        const userImageUrlInput = document.getElementById("userImageUrlInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");

        // 슬롯 버튼 관련 요소 가져오기
        const slotButtons = document.querySelectorAll('.slot-button');
        sendButton.addEventListener("click", sendMessage);

        // keydown 이벤트 리스너 수정: Shift+Enter는 줄바꿈, Enter만 누르면 전송
        userInput.addEventListener("keydown", function(event) {
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault(); // 기본 Enter 동작 (줄바꿈) 막기
                sendMessage();
            }

             // Shift + Enter는 기본 동작 (줄바꿈)이 실행되도록 별도 처리 없음
        });
        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });
        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });
        // 유저 변경 / 캐릭터 변경 버튼 이벤트 리스너 삭제
        // menuUserImgButton.addEventListener("click", function() { changeProfileImage('user'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        // menuBotImgButton.addEventListener("click", function() { changeProfileImage('bot'); actionMenu.classList.remove("visible"); menuOverlay.style.display = 'none'; });
        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });
        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });
        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });
        sidebarToggle.addEventListener("click", function() {
            sidebar.classList.toggle("visible");
            if (sidebar.classList.contains("visible")) {
                sidebarOverlay.style.display = 'block';
                actionMenu.classList.remove("visible");
                menuOverlay.style.display = 'none';
                imageOverlay.style.display = 'none';


           } else {
                sidebarOverlay.style.display = 'none';
            }
        });
        sidebarOverlay.addEventListener("click", function() {
            sidebar.classList.remove("visible");
            sidebarOverlay.style.display = 'none';
        });
        // 기존 saveSettingsButton 클릭 이벤트 수정: 현재 활성화된 슬롯에 저장
        saveSettingsButton.addEventListener("click", function() {
             saveSettings(currentSlot);
        });
        // 슬롯 버튼 클릭 이벤트 리스너 추가
        slotButtons.forEach(button => {
            button.addEventListener('click', function() {
                const slotNumber = parseInt(this.textContent);
                // 수정된 로직: 슬롯 버튼 클릭 시 currentSlot 및 스타일 업데이트는 항상 실행
                currentSlot = slotNumber; // 현재 슬롯 업데이트

                updateSlotButtonStyles(); // 슬롯 버튼 스타일 업데이트

                loadSettings(slotNumber); // 해당 슬롯 설정 로드 시도 (loadSettings 내에서는 로드 성공 여부에 따라 입력 필드 업데이트만 수행)
            });
        });
        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            // 이미지 URL은 입력 필드 값이나 기본값을 사용
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
            // 이미 변수에 저장된 최신 URL 사용
            img.alt = (role === 'user' ? (userNameInput.value || "사용자") + " 프로필" : (botNameInput.value || "캐릭터") + " 프로필");
            // alt 텍스트 변경

            img.addEventListener("click", () => openImageOverlay(img));
            img.onerror = function() {
                 // console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`);
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            // .role-name을 flex 컨테이너로 만들고 이름 텍스트와 삭제 버튼을 포함시킵니다.
            const roleName = document.createElement("div");
            roleName.className = "role-name";
            roleName.style.display = 'flex'; // flexbox 활성화
            roleName.style.alignItems = 'center'; // 세로 중앙 정렬
            // roleName의 justify-content는 아래에서 역할에 따라 설정합니다.


            // 이름 텍스트를 담을 span 생성
            const nameTextSpan = document.createElement("span");
            nameTextSpan.className = "name-text";
            nameTextSpan.textContent = (role === "user" ? userNameInput.value || "사용자" : botNameInput.value || "캐릭터");
            // nameTextSpan의 text-align은 CSS에서 role에 따라 설정합니다.


            // 삭제 버튼 생성
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "delete-btn";
            deleteBtn.textContent = "✕";
            deleteBtn.onclick = () => container.remove(); // 메시지 컨테이너 자체를 삭제하도록

            // 역할에 따라 이름과 삭제 버튼 순서 및 정렬 설정
            if (role === "user") {
                // 유저: 삭제 버튼 - 이름 순서, 오른쪽 정렬
                roleName.style.justifyContent = 'flex-end'; // 내용을 오른쪽으로 모으기
                roleName.appendChild(deleteBtn);
                roleName.appendChild(nameTextSpan);

            } else {
                // 캐릭터: 이름 - 삭제 버튼 순서, 왼쪽 정렬
                roleName.style.justifyContent = 'flex-start'; // 내용을 왼쪽으로 모으기
                roleName.appendChild(nameTextSpan);
                roleName.appendChild(deleteBtn);
            }


            let messageContentElement;
            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                let rawText = messageData.text;

                // 연속된 줄바꿈(하나 이상)을 해당 개수만큼의 <br> 태그로 변환
                let processedText = rawText.replace(/\n+/g, match => '<br>'.repeat(match.length));

                // 마크다운 파싱 전에 임시 마커 사용, 파싱 후 임시 마커를 찾아 스타일 적용
                // "..."를 [[DIALOGUE]]...[[/DIALOGUE]] 로 변환
                processedText = processedText.replace(/"(.*?)"/gs, '[[DIALOGUE]]$1[[/DIALOGUE]]');
                // *...*를 [[ACTION]]...[[/ACTION]] 로 변환
                processedText = processedText.replace(/\*([^*]+)\*\
/gs, '[[ACTION]]$1[[/ACTION]]'); // 여기 닫는 괄호 빠졌던거 수정합니다.
                // marked.js를 사용하여 기본 마크다운을 HTML로 변환
                let htmlContent = marked.parse(processedText);
                // 임시 마커를 찾아 span 태그로 변환하여 스타일 적용
                // [[DIALOGUE]]...[[/DIALOGUE]] -> <span class="dialogue">...</span>
                htmlContent = htmlContent.replace(/\[\[DIALOGUE\]\](.*?)\[\[\/DIALOGUE\]\]/gs, '<span class="dialogue">$1</span>');
                // [[ACTION]]...[[/ACTION]] -> <span class="action-description">$1</span>
                htmlContent = htmlContent.replace(/\[\[ACTION\]\](.*?)\[\[\/ACTION\]\]/gs, '<span class="action-description">$1</span>');
                messageContentElement.innerHTML = htmlContent;


            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                 messageContentElement.onclick = () => openImageOverlay(messageContentElement);
                 messageContentElement.alt = "이미지 메시지";
                 img.onerror = function() {
                     // console.warn(`Failed to load image message from "${this.src}". Using fallback.`);
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 // 이미지 썸네일 클릭 이벤트 리스너
                 messageContentElement.addEventListener("click", function() {
                     // console.log("이미지 썸네일 클릭됨"); // 클릭 감지 로그 (제거)
                     if (!this.classList.contains('error')) {
                         // console.log("이미지 로드 성공, 오버레이 표시 시도"); // 오버레이 표시 조건 충족 로그 (제거)
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
                     } else {
                         // console.log("이미지 로드 실패, 오버레이 표시 안 함"); // 오버레이 표시 조건 불충족 로그 (제거)
                         alert("이미지를 불러올 수 없습니다.");
                     };
               });
            }

            // contentWrapper에 roleName(이름+버튼)과 messageContentElement(말풍선) 추가
            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            // container에 이미지와 contentWrapper 추가 (역할에 따라 순서 다름)
            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img); // 유저: 말풍선/이름 -> 이미지 순서
            } else {
                container.appendChild(img); // 캐릭터: 이미지 -> 이름/말풍선 순서
                container.appendChild(contentWrapper);
            }

            // 삭제 버튼은 이미 roleName 안에 추가되었으므로 여기서 삭제
            // const deleteBtn = document.createElement("button");
            // deleteBtn.className = "delete-btn";
            // deleteBtn.textContent = "✕";
            // deleteBtn.onclick = () => container.remove();
            // container.appendChild(deleteBtn); // 이 줄 삭제

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }

        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true;
            loadingSpinner.style.display = 'block';

            appendMessage("user", { type: 'text', text: message });

            // 입력창 자동 지우기
            userInput.value = '';
            // textarea 높이 초기화 (min-height 유지)
            autoResizeTextarea.call(userInput);


            conversationHistory.push({ role: "user", messageData: { type: 'text', text: message } });


            try {
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text')
                    .map(entry => ({
                        role: entry.role,
                        parts: [{ text: entry.messageData.text }]
                    }));


                const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];

                if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                    // console.log("Only SYSTEM_PROMPT to send to API.");
                } else if (contentsForApi.length === 0) {
                    // console.log("No content to send to API.");
                    appendMessage("bot", { type: 'text', text: "(메시지 전송 실패: 보낼 텍스트 내용 없음)" });
                    return Promise.resolve();
                }


                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",


                         headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );

                if (!res.ok) {
    const errorData = await res.json();
    console.error("API (Backend) Error:", res.status, errorData);
    const errorText =
        errorData?.error?.error?.message ||
        errorData?.error ||
        res.statusText;
    appendMessage("bot", {
        type: 'text',
        text: `(오류 발생: ${res.status} - ${errorText})`
    });
} else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }

        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");
            if (imageUrl !== null && imageUrl.trim() !== '') {
                sendButton.disabled = true;
                userInput.disabled = true;
                actionMenuButton.disabled = true;

                appendMessage("user", { type: 'image', url: imageUrl.trim() });

                conversationHistory.push({ role: "user", messageData: { type: 'image', url: imageUrl.trim() } });

                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                userInput.focus();
            } else if (imageUrl !== null) {
                alert("이미지 주소를 입력해야 합니다.");
            }
        }

        // changeProfileImage 함수 삭제 (액션 메뉴 버튼 제거)
        /*
        function changeProfileImage(role) {
            const promptText = role === 'user' ?
                "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 캐릭터 프로필 이미지 주소(URL)를 입력하세요:";
            const newUrl = prompt(promptText);
            if (newUrl !== null && newUrl.trim() !== '') {
                if (role === 'user') {
                    userProfileImgUrl = newUrl.trim();
                } else {
                    botProfileImgUrl = newUrl.trim();
                }
                alert(`${role === 'user' ? '사용자' : '캐릭터'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
            } else if (newUrl !== null) {
                alert("이미지 주소를 입력해야 합니다.");
            }
        }
        */

        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");
             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true;
             loadingSpinner.style.display = 'block';

             // 상황 생성 요청 프롬프트에도 포맷 지침 추가
             const situationPromptText = `Based on the ongoing conversation and current character settings, generate a vivid and engaging new situation or event written from the character's point of view in novel-style narration.
The scene should naturally invite the user to respond and smoothly continue the dialogue flow.
**Important: After presenting the situation, the character must immediately speak to the user in-character.
Do not include explanations or any OOC (out-of-character) comments. All descriptions must be written using *asterisks*, and all dialogue must be enclosed in double quotes (\"). Maintain a balance of approximately 70% description and 30% dialogue. Use paragraphing and line breaks only for clarity—not for pacing or emotional emphasis.**`;


             // 프롬프트 변경
             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text')
                 .map(entry => ({
                    role: entry.role,
                    parts: [{ text: entry.messageData.text }]

         }));
             const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi, { role: "user", parts: [{ text: situationPromptText }] }];


             if (contentsForApi.length <= 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                 // console.log("Only SYSTEM_PROMPT or SYSTEM_PROMPT + Situation Prompt to send to API."); // 콘솔 로그 제거
             } else if (contentsForApi.length === 0) {
                 // console.log("No content to send to API."); // 콘솔 로그 제거
                 appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                 return Promise.resolve();
             }


            try {
                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",


                         headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }),
                    }
                );
                // 응답이 성공적이지 않다면 (오류라면)
                if (!res.ok) {
    const errorData = await res.json();
    console.error("API (Backend) Error:", res.status, errorData);
    const errorText =
        errorData?.error?.error?.message ||
        errorData?.error ||
        res.statusText;
    appendMessage("bot", {
        type: 'text',
        text: `(오류 발생: ${res.status} - ${errorText})`
    });
} else { // 응답이 성공적이라면
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }


        // textarea 높이 자동 조절 함수
        function autoResizeTextarea() {
            this.style.height = 'auto'; // 높이 초기화
             // 최소 높이: 2줄 높이 + 상하 패딩
            const minHeight = parseFloat(getComputedStyle(this).lineHeight) * 2 +
                                parseFloat(getComputedStyle(this).paddingTop) +
                                parseFloat(getComputedStyle(this).paddingBottom);

            // 스크롤 가능한 높이가 최소 높이보다 크면 그 높이로 설정, 아니면 최소 높이 유지
            this.style.height = (this.scrollHeight > minHeight ? this.scrollHeight : minHeight) + 'px';

            // 최대 높이 (예: 10줄) 제한 (선택 사항)
            const maxHeight = parseFloat(getComputedStyle(this).lineHeight) * 10 +
                              parseFloat(getComputedStyle(this).paddingTop) +
                              parseFloat(getComputedStyle(this).paddingBottom);
            if (parseFloat(this.style.height) > maxHeight) {
                this.style.height = maxHeight + 'px';
                this.style.overflowY = 'auto'; // 최대 높이 초과 시 스크롤바 표시
            } else {
                 this.style.overflowY = 'hidden'; // 최대 높이 이내에서는 스크롤바 숨김
            }
        }


        // textarea 입력 시 높이 자동 조절
        userInput.addEventListener('input', autoResizeTextarea);

        // 페이지 로드 시 textarea 높이 초기 설정 (최소 높이)
        document.addEventListener('DOMContentLoaded', () => {
            autoResizeTextarea.call(userInput); // 페이지 로드 시 최소 높이 적용
            loadSettings(currentSlot); // 페이지 로드 시 현재 슬롯 설정 로드
            updateSlotButtonStyles(); // 페이지 로드 시 슬롯 버튼 스타일 업데이트

             // 이미지 URL 입력 필드에서 값 불러와서 변수 업데이트
             userProfileImgUrl = userImageUrlInput.value || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
             botProfileImgUrl = botImageUrlInput.value || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";

        });


         // 설정 저장 함수 (localStorage 사용)
        function saveSettings(slotNumber) {
            const settings = {
                botName: botNameInput.value,
                botAge: botAgeInput.value,
                botAppearance: botAppearanceInput.value,
                botPersona: botPersonaInput.value,
                botImageUrl: botImageUrlInput.value,
                userName: userNameInput.value,
                userAge: userAgeInput.value,
                userAppearance: userAppearanceInput.value,
                userGuidelines: userGuidelinesInput.value,
                userImageUrl: userImageUrlInput.value
            };
            localStorage.setItem(`settings_slot_${slotNumber}`, JSON.stringify(settings));
            alert(`설정 슬롯 ${slotNumber}에 저장되었습니다.`);

            // 저장 시 이미지 URL 변수 업데이트
            userProfileImgUrl = settings.userImageUrl || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
            botProfileImgUrl = settings.botImageUrl || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";
        }


        // 설정 로드 함수 (localStorage 사용)
        function loadSettings(slotNumber) {
            const savedSettings = localStorage.getItem(`settings_slot_${slotNumber}`);
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                botNameInput.value = settings.botName;
                botAgeInput.value = settings.botAge;
                botAppearanceInput.value = settings.botAppearance;
                botPersonaInput.value = settings.botPersona;
                botImageUrlInput.value = settings.botImageUrl;
                userNameInput.value = settings.userName;
                userAgeInput.value = settings.userAge;
                userAppearanceInput.value = settings.userAppearance;
                userGuidelinesInput.value = settings.userGuidelines;
                userImageUrlInput.value = settings.userImageUrl;
                // console.log(`설정 슬롯 ${slotNumber}에서 로드되었습니다.`); // 콘솔 로그 제거

                 // 로드 시 이미지 URL 변수 업데이트
                 userProfileImgUrl = settings.userImageUrl || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
                 botProfileImgUrl = settings.botImageUrl || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";


            } else {
                 // console.log(`설정 슬롯 ${slotNumber}에 저장된 설정이 없습니다. 기본값 로드 시도.`); // 콘솔 로그 제거
                 // 기본값 로드는 입력 필드의 value 속성에 설정되어 있으므로 추가 로직 불필요
                 alert(`설정 슬롯 ${slotNumber}에 저장된 설정이 없습니다. 기본값이 표시됩니다.`);

                 // 저장된 설정이 없을 경우 기본 이미지 URL 변수 업데이트
                 userProfileImgUrl = userImageUrlInput.value || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
                 botProfileImgUrl = botImageUrlInput.value || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";
            }

             // 로드 후 SYSTEM_PROMPT 업데이트
             updateSystemPrompt();

             // 로드 후 기존 메시지 말풍선 업데이트 (필요시)
             // 이 부분은 현재 메시지 로직에서 바로 이름을 가져오므로 필요 없을 수 있습니다.
             // 메시지를 다시 로드하거나 appendMessage를 다시 호출해야 할 수 있습니다.
             // 여기서는 생략하고 새 메시지부터 적용되도록 합니다.
        }


        // 슬롯 버튼 스타일 업데이트 함수
        function updateSlotButtonStyles() {
            slotButtons.forEach(button => {
                if (parseInt(button.textContent) === currentSlot) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        // SYSTEM_PROMPT 업데이트 함수
        function updateSystemPrompt() {
            SYSTEM_PROMPT = SYSTEM_PROMPT_TEMPLATE
                .replace(/{botName}/g, botNameInput.value || "캐릭터")
                .replace(/{botAge}/g, botAgeInput.value || "불명")
                .replace(/{botAppearance}/g, botAppearanceInput.value || "알 수 없음")
                .replace(/{botPersona}/g, botPersonaInput.value || "설정 없음")
                .replace(/{userName}/g, userNameInput.value || "사용자")
                .replace(/{userAge}/g, userAgeInput.value || "불명")
                .replace(/{userAppearance}/g, userAppearanceInput.value || "알 수 없음")
                .replace(/{userGuidelines}/g, userGuidelinesInput.value || "설정 없음");

             // console.log("SYSTEM_PROMPT updated:", SYSTEM_PROMPT); // 업데이트된 프롬프트 로그 (제거)
        }

        // 초기화 함수
        function initializeChat() {
            // 필요한 초기화 로직 (예: 환영 메시지 표시 등)
             // loadSettings(currentSlot); // 페이지 로드 시 이미 호출됨
             // updateSystemPrompt(); // loadSettings에서 호출됨

             // 초기 공지 메시지 및 구분선 추가
            appendInitialNotice();
        }

        // 초기 공지 메시지 추가 함수
        function appendInitialNotice() {
             const noticeContainer = document.createElement("div");
             noticeContainer.className = "initial-notice";
             noticeContainer.innerHTML = `
                <strong>📢 중요 공지:</strong> 이 챗봇은 수위 높은 성적 묘사를 포함한 BL 에로 소설 작성을 목표로 합니다. 미성년자는 이용할 수 없습니다.
             `;
             chat.appendChild(noticeContainer);

             const divider = document.createElement("div");
             divider.className = "notice-divider";
             chat.appendChild(divider);
        }


        // 페이지 로드 완료 시 실행
        document.addEventListener('DOMContentLoaded', () => {
            autoResizeTextarea.call(userInput); // textarea 높이 초기화
            loadSettings(currentSlot); // 현재 슬롯 설정 로드
            updateSlotButtonStyles(); // 슬롯 버튼 스타일 업데이트
            initializeChat(); // 초기화 로직 실행 (공지 추가 포함)

             // 이미지 URL 입력 필드에서 값 불러와서 변수 업데이트
             userProfileImgUrl = userImageUrlInput.value || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
             botProfileImgUrl = botImageUrlInput.value || "https://via.placeholder.com/35/3a4a3a/ffffff?text=BOT";
        });

    </script>
</body>
</html>
