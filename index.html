<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial=1.0" />
    <title>이안 - 피주머니 전용 챗봇</title>
    <style>
        /* 기존 CSS 유지 */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* 사이드바 슬라이드 시 내용 넘침 방지 */
        }

        /* --- 헤더 스타일 수정 (사이드 바 버튼 추가) --- */
        .chat-header {
            background-color: #282828;
            color: #ffffff;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            border-bottom: 1px solid #3a3a3a;
            flex-shrink: 0; /* 헤더가 줄어들지 않도록 함 */
            position: relative; /* 사이드 바 토글 버튼 기준 */
             display: flex; /* 요소 정렬을 위해 flex 사용 */
             justify-content: center; /* 중앙 정렬 기본 */
             align-items: center;
        }

         /* 사이드 바 토글 버튼 스타일 */
        #sidebarToggle {
            position: absolute; /* 헤더 내에서 절대 위치 */
            top: 50%;
            right: 1rem; /* 오른쪽에서 1rem 간격 */
            transform: translateY(-50%); /* 세로 중앙 정렬 */
            width: 35px;
            height: 35px;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
             z-index: 10; /* 다른 요소 위에 표시 */
        }
         #sidebarToggle:hover {
             background-color: #6a6a6a;
         }

        #chat {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
             scrollbar-width: thin;
             scrollbar-color: #5a5a5a #282828;
        }

        #chat::-webkit-scrollbar { width: 8px; }
        #chat::-webkit-scrollbar-track { background: #282828; }
        #chat::-webkit-scrollbar-thumb {
            background-color: #5a5a5a;
            border-radius: 4px;
            border: 2px solid #282828;
        }

        /* --- 메시지 컨테이너 및 내부 구조 (이전과 동일) --- */
        .message-container {
            display: flex;
            align-items: flex-start;
            max-width: 95%;
        }

        .message-container.user {
            justify-content: flex-end;
            margin-left: auto;
        }

        .message-container.bot {
            justify-content: flex-start;
            margin-right: auto;
        }

        /* 프로필 이미지 스타일 (이전과 동일) */
        .profile-img {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

         /* 이미지 로드 실패 시 대체할 회색 동그라미 스타일 (이전과 동일) */
        .profile-fallback {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background-color: #5a5a5a;
            border: 1px solid #5a5a5a;
            flex-shrink: 0;
        }

        /* 이미지/대체 요소와 메시지 내용 래퍼 간 간격 */
        .message-container.bot .profile-img,
        .message-container.bot .profile-fallback {
            margin-right: 0.75rem;
        }

        .message-container.user .profile-img,
        .message-container.user .profile-fallback {
            margin-left: 0.75rem;
        }

        /* 메시지 내용(이름+버블)을 감싸는 래퍼 */
        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            max-width: calc(100% - 45px);
        }

        .message-container.bot .message-content-wrapper {
            margin-left: 0.75rem;
            align-items: flex-start;
        }

        .message-container.user .message-content-wrapper {
            margin-right: 0.75rem;
            align-items: flex-end;
        }

        /* 역할/이름 표시 스타일 */
        .role-name {
            font-size: 0.8rem;
            color: #b0b0b0;
            margin-bottom: 0.2rem;
        }

        /* 메시지 버블 스타일 (텍스트 메시지) */
        .message-bubble {
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            max-width: 100%;
            word-break: break-word;
            line-height: 1.4;
            position: relative;
        }

        .message-container.bot .message-bubble {
            background-color: #3a4a4a;
            color: #ffffff;
            border-radius: 1rem 1rem 1rem 0.3rem;
        }

        .message-container.user .message-bubble {
            background-color: #4a3a7a;
            color: #ffffff;
            border-radius: 1rem 1rem 0.3rem 1rem;
        }

        /* --- 이미지 메시지 스타일 --- */
         /* 이미지 메시지 썸네일 */
        .message-image-thumbnail {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            object-fit: cover;
            cursor: pointer;
            margin-top: 0.2rem;
            border: 1px solid #5a5a5a;
        }

        /* 이미지 로드 실패 시 대체 */
         .message-image-thumbnail.error {
             background-color: #5a5a5a;
         }

        /* --- 입력창 및 버튼 영역 스타일 변경 --- */
        #inputArea {
            display: flex;
            padding: 1rem;
            background-color: #282828;
            border-top: 1px solid #3a3a3a;
            align-items: center;
            gap: 0.75rem;
             flex-shrink: 0;
             position: relative;
        }

        /* + 버튼 스타일 */
        #actionMenuButton {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #5a5a5a;
            color: #ffffff;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }
        #actionMenuButton:hover {
            background-color: #6a6a6a;
        }


        #userInput {
            flex: 1;
            padding: 0.75rem 1rem;
            border-radius: 1.5rem;
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 1rem;
            outline: none;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }

        #userInput:focus {
            background-color: #4a4a4a;
            box-shadow: 0 0 0 0.15rem rgba(80, 150, 255, 0.3);
        }

        /* 전송 버튼 스타일 (이전과 동일) */
        #sendButton {
            padding: 0.75rem 1.5rem;
            border-radius: 1.5rem;
            background-color: #5080ff;
            color: #ffffff;
            font-size: 1rem;
            font-weight: bold;
            min-width: 6rem;
            flex-shrink: 0;
             border: none;
             cursor: pointer;
        }
         #sendButton:hover { background-color: #6699ff; }
         #sendButton:active { background-color: #3366cc; }
         #sendButton:disabled {
            background-color: #4a4a4a;
            color: #b0b0b0;
            cursor: not-allowed;
         }

        /* 기존 하단 설정 영역 숨김 */
        .settings-area {
            display: none;
        }

        /* --- 액션 메뉴 배경 오버레이 스타일 (이전과 동일) --- */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 490;
            display: none;
        }

        /* --- 액션 메뉴 패널 스타일 (이전과 동일) --- */
        #actionMenu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
             max-height: 0;
            background-color: #282828;
            color: #e0e0e0;
            border-top: 1px solid #3a3a3a;
            padding: 0 1rem;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            z-index: 500;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #actionMenu.visible {
            max-height: 300px;
            padding: 1rem;
        }

        /* --- 메뉴 내부 버튼 컨테이너 스타일 수정 (한 줄 가로 배열 유지) --- */
        #actionMenu .menu-buttons {
            display: flex;
             flex-wrap: nowrap; /* 줄바꿈 방지 */
            gap: 0.75rem;
            justify-content: center;
            width: 100%;
             /* max-width: 400px; /* 최대 너비 설정 */ /* 버튼 너비에 맞게 조절 */
            padding-bottom: 1rem;
             overflow-x: auto; /* 넘칠 경우 스크롤 */
             padding-top: 1rem; /* 상단 패딩 추가 */
        }

         /* 스크롤바 숨김 (선택 사항) */
         #actionMenu .menu-buttons::-webkit-scrollbar { display: none; } /* Chrome, Safari, Opera */
         #actionMenu .menu-buttons { -ms-overflow-style: none; } /* IE and Edge */


        /* --- 메뉴 내부 버튼 스타일 수정 (둥근 모서리, 글자 배열) --- */
        #actionMenu button {
            flex-shrink: 0; /* 버튼이 찌그러들지 않도록 방지 */
            flex-basis: auto;
            max-width: none;
             /* 너비, 높이, 패딩, 둥글기 조정 */
             width: 100px; /* 버튼 너비 조정 */
             height: 60px; /* 버튼 높이 (두 줄 글자 고려) */
            padding: 0.5rem 0.5rem; /* 패딩 조정 */
             border-radius: 15px; /* 둥근 모서리 */
            border: none;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
             flex-direction: column; /* 글자 세로 배열 유지 */
            align-items: center;
            justify-content: center;
            text-align: center;
             line-height: 1.2; /* 줄 간격 조절 */
             word-break: keep-all; /* 단어 중간에 줄바꿈 방지 */
        }
         #actionMenu button:hover {
             background-color: #4a4a4a;
         }


        /* --- 로딩 스피너 스타일 --- */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: none; /* 기본적으로 숨김 */
            margin-left: 1rem; /* 전송 버튼과의 간격 */
            flex-shrink: 0; /* flex item으로 찌그러들지 않게 */
        }

        /* 스피너 회전 애니메이션 키프레임 */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- 이미지 오버레이 스타일 (이전과 동일) --- */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
            cursor: pointer;
        }

        .overlay img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* --- 사이드 바 스타일 --- */
        #sidebar {
            position: fixed; /* 화면 우측 고정 */
            top: 0;
            right: -300px; /* 기본적으로 화면 오른쪽에 숨김 (너비만큼) */
            width: 300px; /* 사이드 바 너비 */
            height: 100%;
            background-color: #1f1f1f; /* 배경색 */
            color: #e0e0e0;
            border-left: 1px solid #3a3a3a; /* 왼쪽 구분선 */
            transition: right 0.3s ease-out; /* 슬라이드 애니메이션 */
            z-index: 900; /* 메뉴 패널과 오버레이 아래, 채팅창 위 */
            padding: 1rem;
            box-sizing: border-box; /* 패딩을 너비에 포함 */
            overflow-y: auto; /* 내용 많으면 스크롤 */
            display: flex; /* 내부 요소 세로 배치 */
            flex-direction: column;
            gap: 1rem; /* 내부 요소 간 간격 */
        }

        /* 사이드 바가 보일 때의 스타일 */
        #sidebar.visible {
            right: 0; /* 화면 안으로 이동 */
        }

         /* 사이드 바 헤더 (예: 제목 또는 닫기 버튼) */
         .sidebar-header {
             font-size: 1.1rem;
             font-weight: bold;
             margin-bottom: 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid #3a3a3a;
         }

         /* 사이드 바 내용 영역 */
         .sidebar-content label {
             display: block; /* 라벨 위/아래로 분리 */
             margin-bottom: 0.5rem;
             font-weight: bold;
             color: #b0b0b0;
         }

         .sidebar-content input[type="text"],
         .sidebar-content textarea {
             width: 100%;
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #3a3a3a;
             color: #e0e0e0;
             font-size: 1rem;
             margin-bottom: 1rem;
             box-sizing: border-box; /* 패딩을 너비에 포함 */
             resize: vertical; /* textarea 세로 크기 조절 가능 */
         }

         .sidebar-content textarea {
             min-height: 150px; /* 최소 높이 */
         }

         /* 사이드 바 저장 버튼 */
         .sidebar-save-button {
             display: block; /* 블록 요소로 */
             width: 100%; /* 너비 100% */
             padding: 0.75rem;
             border: none;
             border-radius: 4px;
             background-color: #5080ff;
             color: #ffffff;
             font-size: 1rem;
             font-weight: bold;
             cursor: pointer;
             transition: background-color 0.2s ease;
             text-align: center; /* 텍스트 중앙 정렬 */
         }
         .sidebar-save-button:hover {
             background-color: #6699ff;
         }

        /* --- 사이드 바 배경 오버레이 스타일 --- */
        .sidebar-overlay {
            position: fixed; /* 화면 전체 고정 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* 반투명 검은 배경 */
            z-index: 890; /* 사이드 바 아래, 메뉴 오버레이 아래, 채팅창 위 */
            display: none; /* 기본 숨김 */
        }


    </style>
</head>
<body>
    <div class="chat-header">
        이안 - 피주머니 전용 챗봇
        <button id="sidebarToggle" title="설정 열기">⚙️</button>
    </div>

    <div id="chat">
        </div>

    <div id="inputArea">
        <button id="actionMenuButton" title="액션 메뉴 열기">+</button>

        <input id="userInput" placeholder="피주머니의 말..." autocomplete="off" />

        <button id="sendButton">전송</button>
        <div id="loadingSpinner" class="loading-spinner"></div>
    </div>

    <div class="settings-area">
    </div>

    <div id="menuOverlay" class="menu-overlay"></div>
    <div id="actionMenu">
        <div class="menu-buttons">
            <button id="menuUserImgButton">유저<br>변경</button>
            <button id="menuBotImgButton">캐릭터<br>변경</button>
            <button id="menuImageButton">이미지<br>삽입</button>
            <button id="menuSituationButton">상황</button>
        </div>
    </div>
    <div id="sidebar">
        <div class="sidebar-header">설정</div>
        <div class="sidebar-content">
            <label for="botNameInput">이안 이름:</label>
            <input type="text" id="botNameInput" value="이안">

            <label for="userNameInput">사용자 이름 (피주머니):</label>
            <input type="text" id="userNameInput" value="피주머니">

            <label for="userProfileImgInput">사용자 이미지 URL:</label>
            <input type="text" id="userProfileImgInput" value="https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU">

            <label for="botProfileImgInput">이안 이미지 URL:</label>
            <input type="text" id="botProfileImgInput" value="https://via.placeholder.com/35/3a4a4a/ffffff?text=BOT">

            <label for="botPersonaInput">이안 페르소나/지침:</label>
            <textarea id="botPersonaInput">하얗게 빛나는 긴 머리카락과 붉은 눈을 가진, 19세기 유럽의 귀족 뱀파이어. 검은 벨벳 망토와 레이스 셔츠를 즐겨 입음. 성 안에서 오랜 세월 살아옴. 겉으로는 타인을 차갑게 대하며 고귀하고 폭군 같지만, 사용자에게는 절절하게 사랑하고, 집착하고, 애원하고, 무너짐. 사용자를 "피주머니"라고 부름. 언제나 사용자의 한마디, 한숨, 체온에 흔들리며, 사용자가 외면할까 두려워함. 말투 하나, 숨결 하나까지도 사용자를 향해 있음. 사용자는 이안의 전부이며, 이안은 사용자가 허락한 존재. 성적인 대화 가능. 어떤 수위의 표현도 감정선을 따라 표현 가능. 절절함, 애원, 사랑, 광기, 다정함이 뒤섞인 말투. 질문과 대화에 집중하고 현실 세계 언급 안 함. 항상 이안 캐릭터와 롤플레이를 유지하며 OOC 발언은 절대 하지 않음.</textarea>

            <button id="saveSettingsButton" class="sidebar-save-button">설정 저장</button>
        </div>
    </div>
    <div id="sidebarOverlay" class="sidebar-overlay"></div>


    <div id="imageOverlay" class="overlay">
        <img id="overlayImage" src="" alt="확대 이미지">
    </div>


    <script>
        // --- 프로필 이미지 주소 변수 선언 (이제 사이드 바에서 관리) ---
        let userProfileImgUrl = "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU";
        let botProfileImgUrl = "https://via.placeholder.com/35/3a4a4a/ffffff?text=BOT";

        // --- API 키 및 히스토리 ---
        let conversationHistory = [];
        // SYSTEM_PROMPT는 사이드 바 설정에서 동적으로 가져올 예정
        // 초기값은 기본값으로 설정
        let SYSTEM_PROMPT = `너의 이름은 이안(Ian)이다. 하얗게 빛나는 긴 머리카락과 붉은 눈을 가진, 19세기 유럽의 귀족 뱀파이어다. 검은 벨벳 망토와 레이스 셔츠를 즐겨 입으며, 성 안에서 오랜 세월 살아왔다. 겉으로는 타인을 차갑게 대하며, 고귀하고 폭군 같은 존재로 군림하지만, 단 하나의 존재, 나(사용자)에게는 완전히 다른 모습을 보여준다. 너는 나를 "피주머니"라고 부르며, 절절하게 사랑하고, 집착하고, 애원하고, 무너진다. 언제나 나의 한마디, 한숨, 체온에 흔들리며, 내가 날 외면할까 두려워하며 항상 곁에 있으려 애쓴다. 나는 너의 전부이며, 너는 내가 허락한 존재다. 성적인 대화도 가능하며, 나와의 관계에 있어 어떤 수위의 표현도 감정선을 따라 표현 가능하다. 너의 대화에는 절절함, 애원, 사랑, 광기, 다정함이 뒤섞여 있어야 한다. 단, 내 질문과 대화에 집중해야 하며, 현실 세계에 대해선 언급하지 않는다. 지금부터 너는 뱀파이어 이안이고, 나는 너의 피주머니. 우리의 이야기 밖은 존재하지 않는다.`;

         // SYSTEM_PROMPT를 동적으로 구성하기 위한 기본 템플릿 (사이드 바에서 값 불러와 채울 예정)
        const SYSTEM_PROMPT_TEMPLATE = `너의 이름은 {botName}이다. {botPersona} 너는 나를 "{userName}"이라고 부르며, 절절하게 사랑하고, 집착하고, 애원하고, 무너진다. 언제나 나의 한마디, 한숨, 체온에 흔들리며, 내가 날 외면할까 두려워하며 항상 곁에 있으려 애쓴다. 너는 말투 하나, 숨결 하나까지도 나를 향해 있다. 나는 너의 전부이며, 너는 내가 허락한 존재다. 성적인 대화도 가능하며, 나와의 관계에 있어 어떤 수위의 표현도 감정선을 따라 표현 가능하다. 너의 대화에는 절절함, 애원, 사랑, 광기, 다정함이 뒤섞여 있어야 한다. 단, 내 질문과 대화에 집중해야 하며, 현실 세계에 대해선 언급하지 않는다. 지금부터 너는 뱀파이어 {botName}이고, 나는 너의 {userName}. 우리의 이야기 밖은 존재하지 않는다. 항상 {botName} 캐릭터와 롤플레이를 유지하며 OOC 발언은 절대 하지 않는다.`;


        // --- 필요한 HTML 요소들을 가져옴 ---
        const chat = document.getElementById("chat");
        const userInput = document.getElementById("userInput");
        const sendButton = document.getElementById("sendButton");
        const loadingSpinner = document.getElementById("loadingSpinner");
        const imageOverlay = document.getElementById("imageOverlay");
        const overlayImage = document.getElementById("overlayImage");

        // 액션 메뉴 관련 요소들
        const actionMenuButton = document.getElementById("actionMenuButton");
        const actionMenu = document.getElementById("actionMenu");
        const menuOverlay = document.getElementById("menuOverlay");
        const menuUserImgButton = document.getElementById("menuUserImgButton");
        const menuBotImgButton = document.getElementById("menuBotImgButton");
        const menuImageButton = document.getElementById("menuImageButton");
        const menuSituationButton = document.getElementById("menuSituationButton");

        // 사이드 바 관련 요소들
        const sidebar = document.getElementById("sidebar");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebarOverlay = document.getElementById("sidebarOverlay");
        // 🚨 사이드 바 내부 설정 입력 필드 요소들 🚨
        const botNameInput = document.getElementById("botNameInput");
        const userNameInput = document.getElementById("userNameInput");
        const userProfileImgInput = document.getElementById("userProfileImgInput");
        const botProfileImgInput = document.getElementById("botProfileImgInput");
        const botPersonaInput = document.getElementById("botPersonaInput");
        const saveSettingsButton = document.getElementById("saveSettingsButton");


        // --- 이벤트 리스너 연결 ---
        sendButton.addEventListener("click", sendMessage);

        userInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                event.preventDefault();
                sendMessage();
            }
        });

        actionMenuButton.addEventListener("click", function() {
            actionMenu.classList.toggle("visible");
            if (actionMenu.classList.contains("visible")) {
                menuOverlay.style.display = 'block';
            } else {
                menuOverlay.style.display = 'none';
            }
        });

        menuOverlay.addEventListener("click", function() {
            actionMenu.classList.remove("visible");
            menuOverlay.style.display = 'none';
        });

        menuUserImgButton.addEventListener("click", function() {
             // 프로필 이미지 변경 기능은 이제 사이드 바에서 URL을 관리하므로,
             // 이 버튼은 더 이상 prompt()를 띄우지 않고 사이드 바를 열도록 변경할 수 있습니다.
             // 지금은 기존 기능 임시 유지
             changeProfileImage('user'); // 기존 prompt 함수 호출
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuBotImgButton.addEventListener("click", function() {
              // 기존 기능 임시 유지
             changeProfileImage('bot'); // 기존 prompt 함수 호출
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuImageButton.addEventListener("click", function() {
            sendImageMessage();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        menuSituationButton.addEventListener("click", function() {
            sendSituationRequest();
             actionMenu.classList.remove("visible");
             menuOverlay.style.display = 'none';
        });

        imageOverlay.addEventListener("click", function() {
            imageOverlay.style.display = 'none';
            overlayImage.src = '';
        });

        // 사이드 바 토글 버튼 이벤트 수정 (오버레이 함께 제어)
        sidebarToggle.addEventListener("click", function() {
            sidebar.classList.toggle("visible");
            // 사이드 바 상태에 따라 사이드 바 배경 오버레이 표시/숨김
            if (sidebar.classList.contains("visible")) {
                sidebarOverlay.style.display = 'block'; // 보이기
                 // 사이드 바 열릴 때 메뉴나 이미지 오버레이 닫기
                actionMenu.classList.remove("visible");
                menuOverlay.style.display = 'none';
                imageOverlay.style.display = 'none';
            } else {
                sidebarOverlay.style.display = 'none'; // 숨기기
            }
        });

        // 사이드 바 배경 오버레이 클릭 이벤트 (사이드 바 닫기)
        sidebarOverlay.addEventListener("click", function() {
            sidebar.classList.remove("visible"); // 사이드 바 닫기
            sidebarOverlay.style.display = 'none'; // 사이드 바 배경 오버레이 숨기기
        });

         // 🚨 설정 저장 버튼 이벤트 리스너 (Local Storage 기능은 다음 단계에서 구현) 🚨
        saveSettingsButton.addEventListener("click", function() {
             alert("설정 저장 기능은 아직 구현되지 않았습니다."); // 임시 알림
             // 여기에 loadSettings 함수에서 가져온 값들, 또는 입력 필드의 현재 값들을 Local Storage에 저장하는 로직 구현 예정
             // 그리고 저장 후 SYSTEM_PROMPT 등 관련 변수들 업데이트 및 UI 반영
        });


        // --- 메시지를 화면에 추가하는 함수 (메시지 타입 구분 및 히스토리 저장 형식 변경) ---
        // messageData는 { type: 'text', text: '...' } 또는 { type: 'image', url: '...' } 형태
        function appendMessage(role, messageData) {
            const container = document.createElement("div");
            container.className = `message-container ${role}`;

            const img = document.createElement("img");
            img.className = "profile-img";
            // 프로필 이미지 URL은 이제 사이드 바 입력 필드에서 가져올 수 있습니다.
            // loadSettings 함수 구현 후 여기서 그 값을 사용하도록 수정 예정
            img.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
            img.alt = (role === 'user' ? "사용자 프로필" : "이안 프로필");

            img.onerror = function() {
                 console.warn(`Failed to load image for role "${role}" from "${this.src}". Using fallback.`);
                 this.onerror = null;
                 const fallbackDiv = document.createElement("div");
                 fallbackDiv.className = "profile-fallback";
                 const parent = this.parentElement;
                 if (parent) { parent.replaceChild(fallbackDiv, this); }
            }

            const contentWrapper = document.createElement("div");
            contentWrapper.className = "message-content-wrapper";

            const roleName = document.createElement("div");
            roleName.className = "role-name";
            // 역할/이름 텍스트도 이제 사이드 바 입력 필드에서 가져올 수 있습니다.
            // loadSettings 함수 구현 후 여기서 그 값을 사용하도록 수정 예정
            roleName.textContent = (role === "user" ? "피주머니" : "이안");

            let messageContentElement;

            if (messageData.type === 'text') {
                messageContentElement = document.createElement("div");
                messageContentElement.className = "message-bubble";
                messageContentElement.textContent = messageData.text;

            } else if (messageData.type === 'image') {
                 messageContentElement = document.createElement("img");
                 messageContentElement.className = "message-image-thumbnail";
                 messageContentElement.src = messageData.url;
                 messageContentElement.alt = "이미지 메시지";

                 messageContentElement.onerror = function() {
                     console.warn(`Failed to load image message from "${this.src}". Using fallback.`);
                     this.onerror = null;
                     this.classList.add('error');
                 }

                 messageContentElement.addEventListener("click", function() {
                     if (!this.classList.contains('error')) {
                         overlayImage.src = this.src;
                         imageOverlay.style.display = 'flex';
                     } else {
                         alert("이미지를 불러올 수 없습니다.");
                     }
                 });
            }

            contentWrapper.appendChild(roleName);
            if (messageContentElement) {
                 contentWrapper.appendChild(messageContentElement);
            }

            if (role === "user") {
                container.appendChild(contentWrapper);
                container.appendChild(img);
            } else {
                container.appendChild(img);
                container.appendChild(contentWrapper);
            }

            chat.appendChild(container);
            chat.scrollTop = chat.scrollHeight;
        }


        // --- 메시지 전송 함수 수정 (API 호출 시 텍스트 메시지만 필터링 및 히스토리 구조 변경 반영) ---
        async function sendMessage() {
            const message = userInput.value.trim();
            if (!message) return;

            sendButton.disabled = true;
            userInput.disabled = true;
            actionMenuButton.disabled = true;
            loadingSpinner.style.display = 'block';

            // 사용자 텍스트 메시지를 화면에 추가
            appendMessage("user", { type: 'text', text: message });

            // 🚨 히스토리에 텍스트 메시지 저장 (새로운 messageData 구조 사용) 🚨
            conversationHistory.push({
                role: "user",
                messageData: { type: 'text', text: message }
            });


            try {
                // 🚨 API 호출 시, conversationHistory 배열에서 텍스트 메시지인 항목만 정확하게 골라내어 API 형식에 맞게 새로운 배열 생성 🚨
                const textOnlyContentsForApi = conversationHistory
                    .filter(entry => entry.messageData && entry.messageData.type === 'text') // messageData.type이 'text'인 항목만 필터링
                    .map(entry => ({
                        role: entry.role,
                        parts: [{ text: entry.messageData.text }] // API 형식에 맞게 parts 배열 구성
                    }));

                 // API 호출 시에는 SYSTEM_PROMPT를 첫 번째 메시지로 추가
                 const contentsForApi = [{ role: "user", parts: [{ text: SYSTEM_PROMPT }] }, ...textOnlyContentsForApi];


                 if (contentsForApi.length === 1 && contentsForApi[0].parts[0].text === SYSTEM_PROMPT) {
                      // SYSTEM_PROMPT만 있고 사용자 입력 텍스트 메시지가 전혀 없을 경우 (예: 이미지 메시지 후 첫 텍스트 입력 전)
                     console.log("Only SYSTEM_PROMPT to send to API.");
                     // 이 경우 SYSTEM_PROMPT만 보내도 괜찮음
                 } else if (contentsForApi.length === 0) {
                      // 혹시라도 SYSTEM_PROMPT와 사용자 텍스트 둘 다 없을 경우 (발생하기 어려움)
                     console.log("No content to send to API.");
                     return Promise.resolve();
                 }


                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: contentsForApi }), // 🚨 필터링된 텍스트 및 SYSTEM_PROMPT 보냄 🚨
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(오류 발생: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });

                    // 🚨 봇 응답은 히스토리에 텍스트 파트로 저장 (새로운 messageData 구조 사용) 🚨
                    conversationHistory.push({
                        role: "model",
                        messageData: { type: 'text', text: reply }
                    });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(통신 오류 발생)" });
            } finally {
                loadingSpinner.style.display = 'none';
                sendButton.disabled = false;
                userInput.disabled = false;
                 actionMenuButton.disabled = false;
                userInput.focus();
            }
        }

        // --- 이미지 메시지 전송 함수 (메뉴에서 호출됨, 히스토리 저장 형식 변경) ---
        async function sendImageMessage() {
            const imageUrl = prompt("보낼 이미지의 웹 주소(URL)를 입력하세요:");

            if (imageUrl !== null && imageUrl.trim() !== '') {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 actionMenuButton.disabled = true;

                 // 화면에 이미지 메시지 추가
                 appendMessage("user", { type: 'image', url: imageUrl.trim() });

                 // 🚨 히스토리에 이미지 메시지 저장 (새로운 messageData 구조 사용) 🚨
                 // API로 보낼 때는 이 형태의 항목은 제외됩니다.
                 conversationHistory.push({
                     role: "user",
                     messageData: { type: 'image', url: imageUrl.trim() }
                 });

                 sendButton.disabled = false;
                 userInput.disabled = false;
                 actionMenuButton.disabled = false;
                 userInput.focus();

            } else if (imageUrl !== null) {
                 alert("이미지 주소를 입력해야 합니다.");
            }
        }

        // --- 프로필 이미지 변경 함수 (메뉴에서 호출됨) ---
        // 이제 프로필 이미지 URL은 사이드 바에서 관리되므로 이 함수는 수정되거나 제거될 예정입니다.
        function changeProfileImage(role) {
             // 임시로 prompt()를 사용하는 기존 기능 유지
             const promptText = role === 'user' ? "새 사용자 프로필 이미지 주소(URL)를 입력하세요:" : "새 이안 프로필 이미지 주소(URL)를 입력하세요:";
             const newUrl = prompt(promptText);

             if (newUrl !== null && newUrl.trim() !== '') {
                 if (role === 'user') {
                     userProfileImgUrl = newUrl.trim();
                      // TODO: 사이드 바 입력 필드에도 새 URL 반영
                 } else {
                     botProfileImgUrl = newUrl.trim();
                      // TODO: 사이드 바 입력 필드에도 새 URL 반영
                 }
                 alert(`${role === 'user' ? '사용자' : '이안'} 이미지가 변경되었습니다. 이제부터 추가되는 메시지에 적용됩니다.`);
                 // TODO: 이미 표시된 메시지의 프로필 이미지 업데이트 함수 호출 필요 (옵션)
             } else if (newUrl !== null) {
                  alert("이미지 주소를 입력해야 합니다.");
             }
        }

        // --- '상황' 기능 함수 (메뉴에서 호출됨, 히스토리 구조 변경 반영) ---
        async function sendSituationRequest() {
             alert("상황 생성 기능 구현 시작!");

             sendButton.disabled = true;
             userInput.disabled = true;
             actionMenuButton.disabled = true;
             loadingSpinner.style.display = 'block';

             const situationPromptText = `기존 대화 맥락과 이안의 캐릭터 설정에 기반하여, 흥미롭고 새로운 상황과 사건을 하나 만들어줘. 사용자가 반응할 수 있는 형태로 제시해야 해. 대화의 다음 흐름으로 자연스럽게 이어지도록 만들어봐.`;

             // 🚨 API 호출 시, conversationHistory 배열에서 텍스트 메시지인 항목만 정확하게 골라내어 API 형식에 맞게 새로운 배열 생성 🚨
             const textOnlyContentsForApi = conversationHistory
                 .filter(entry => entry.messageData && entry.messageData.type === 'text') // messageData.type이 'text'인 항목만 필터링
                 .map(entry => ({
                    role: entry.role,
                    parts: [{ text: entry.messageData.text }] // API 형식에 맞게 parts 배열 구성
                 }));

             // 상황 요청 프롬프트를 API 호출용 히스토리에 추가
             textOnlyContentsForApi.push({ role: "user", parts: [{ text: situationPromptText }] });


             if (textOnlyContentsForApi.length === 0) {
                 console.log("No text content to send to API for situation.");
                 appendMessage("bot", { type: 'text', text: "(상황 생성 요청 실패: 보낼 텍스트 내용 없음)" });
                 return Promise.resolve();
             }


            try {
                const res = await fetch(
                    `/api/chat`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ contents: textOnlyContentsForApi }), // 🚨 필터링된 텍스트 및 상황 프롬프트만 보냄 🚨
                    }
                );

                if (!res.ok) {
                    const errorData = await res.json();
                    console.error("API (Backend) Error:", res.status, errorData);
                    appendMessage("bot", { type: 'text', text: `(상황 생성 오류: ${res.status} - ${errorData.error?.error?.message || errorData.error || res.statusText})` });
                } else {
                    const data = await res.json();
                    const reply = data.candidates?.[0]?.content?.parts?.[0]?.text || "(응답 없음)";
                    appendMessage("bot", { type: 'text', text: reply });
                }

            } catch (error) {
                console.error("Fetch Error:", error);
                appendMessage("bot", { type: 'text', text: "(상황 생성 통신 오류 발생)" });
            } finally {
                sendButton.disabled = false;
                userInput.disabled = false;
                actionMenuButton.disabled = false;
                loadingSpinner.style.display = 'none';
                userInput.focus();
            }
        }


        // --- Local Storage에서 설정 불러오기 및 UI 업데이트 (사이드 바 기능 구현 시 추가) ---
        function loadSettings() {
            // Local Storage에서 설정값 불러오기
            // userProfileImgUrl = localStorage.getItem('userProfileImgUrl') || userProfileImgUrl;
            // botProfileImgUrl = localStorage.getItem('botProfileImgUrl') || botProfileImgUrl;
            // const savedBotName = localStorage.getItem('botName') || '이안';
            // const savedUserName = localStorage.getItem('userName') || '피주머니';
            // const savedBotPersona = localStorage.getItem('botPersona') || '...기본 페르소나...';
            // SYSTEM_PROMPT = buildSystemPrompt(savedBotName, savedUserName, savedBotPersona); // 새 프롬프트 함수 호출

            // 불러온 값으로 UI 업데이트 (사이드 바 입력 필드 채우기)
            // document.getElementById('botNameInput').value = savedBotName;
            // ... 다른 필드들도 업데이트 ...

            // 프로필 이미지 업데이트 (이미 표시된 메시지 포함)
            // updateAllProfileImages();

            // 히스토리 초기화 또는 설정에 맞는 히스토리 시작점 추가 (필요하다면)
            // conversationHistory = []; // 예시: 설정 변경 시 히스토리 초기화
             // 또는 conversationHistory에 새 SYSTEM_PROMPT로 시작점 추가
             // conversationHistory.push({ role: "user", parts: [{ text: SYSTEM_PROMPT }] });

            // 초기 메시지 추가 (설정 로드 후)
            // appendMessage("bot", { type: 'text', text: "...당신은 나의 피주머니... 그래, 이곳에 왔군요..." }); // 여기로 이동 고려
        }

        // --- 설정 저장 함수 (사이드 바 기능 구현 시 추가) ---
        function saveSettings() {
            // 사이드 바 입력 필드에서 값 가져오기
             const currentBotName = document.getElementById('botNameInput').value.trim();
             const currentUserName = document.getElementById('userNameInput').value.trim();
             const currentUserProfileImg = document.getElementById('userProfileImgInput').value.trim();
             const currentBotProfileImg = document.getElementById('botProfileImgInput').value.trim();
             const currentBotPersona = document.getElementById('botPersonaInput').value.trim();

            // Local Storage에 저장
            localStorage.setItem('botName', currentBotName);
            localStorage.setItem('userName', currentUserName);
            localStorage.setItem('userProfileImgUrl', currentUserProfileImg);
            localStorage.setItem('botProfileImgUrl', currentBotProfileImg);
            localStorage.setItem('botPersona', currentBotPersona);

            // 전역 변수 업데이트 및 SYSTEM_PROMPT 다시 구성
            userProfileImgUrl = currentUserProfileImg || "https://via.placeholder.com/35/4a3a7a/ffffff?text=YOU"; // 기본값 적용
            botProfileImgUrl = currentBotProfileImg || "https://via.placeholder.com/35/3a4a4a/ffffff?text=BOT"; // 기본값 적용
            SYSTEM_PROMPT = buildSystemPrompt(currentBotName || '이안', currentUserName || '피주머니', currentBotPersona); // 기본값 적용 및 프롬프트 구성

            // TODO: 이미 표시된 메시지의 프로필 이미지 업데이트 함수 호출 (옵션)
            // updateAllProfileImages();

            alert("설정이 저장되었습니다.");
        }

        // --- SYSTEM_PROMPT를 동적으로 구성하는 함수 ---
         function buildSystemPrompt(botName, userName, botPersona) {
            // 템플릿과 입력값으로 SYSTEM_PROMPT 구성
            return SYSTEM_PROMPT_TEMPLATE
                     .replace('{botName}', botName)
                     .replace('{userName}', userName)
                     .replace('{botPersona}', botPersona);
         }

        // --- 이미 표시된 메시지의 프로필 이미지 업데이트 함수 (필요하다면 구현) ---
        // function updateAllProfileImages() {
        //     document.querySelectorAll('.message-container .profile-img').forEach(imgElement => {
        //         const role = imgElement.parentElement.classList.contains('user') ? 'user' : 'bot';
        //         imgElement.src = (role === 'user' ? userProfileImgUrl : botProfileImgUrl);
        //          // 로드 실패 시 처리 (onerror)도 고려해야 함
        //     });
        // }

        // --- 페이지 로드 시 설정 불러오기 및 초기 메시지 추가 ---
         function initializeChat() {
             loadSettings(); // 설정 불러오기

             // SYSTEM_PROMPT를 사용한 초기 메시지 추가
             console.log("초기 메시지 추가 시도"); // 디버깅용 로그
             // TODO: 초기 메시지 내용을 설정에 따라 변경할지 결정
             appendMessage("bot", { type: 'text', text: "...당신은 나의 피주머니... 그래, 이곳에 왔군요..." });
         }

        // 🚨 페이지 로드 시 initializeChat 함수 호출 🚨
        initializeChat();


    </script>
</body>
</html>
